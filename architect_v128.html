<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tone & Structure Architect v5.1 (Stable)</title>
<style>
    /* --- 1. CSS VARIABLES & RESET --- */
    :root {
        --primary: #009688; --accent: #ff9800; 
        --bg: #f0f2f5; --card: #ffffff; --text: #37474f; 
        --border: #cfd8dc; --success: #4caf50; --error: #f44336;
        --tone-color: #9c27b0; --struct-color: #2196f3; --lang-color: #43a047;
        --reader-highlight: rgba(0, 150, 136, 0.08);
        --reader-highlight-border: rgba(0, 150, 136, 0.5);
        --reader-highlight-line: rgba(0, 150, 136, 0.6);
        --reader-highlight-line-height: 2px;
        --reader-window-height-base: 3.2em;
        --reader-window-height: 3.2em;
        --reader-zoom: 1.1rem;
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; transition: background 0.3s, color 0.3s; }

    /* --- 2. HEADER --- */
    header { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; background: var(--card); box-shadow: 0 2px 5px rgba(0,0,0,0.1); z-index: 100; flex-shrink: 0; border-bottom: 1px solid var(--border); }
    h1 { margin: 0; font-size: 1.1rem; color: var(--primary); display: flex; align-items: center; gap: 8px; font-weight: 800; }
    .score-badge { background: var(--accent); color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.85rem; font-weight: bold; }
    .header-controls { display: flex; gap: 8px; align-items: center; }
    .icon-btn { background: none; border: 1px solid var(--border); border-radius: 4px; font-size: 1.2rem; cursor: pointer; padding: 4px 8px; transition: background 0.2s; color: var(--text); }
    .icon-btn:hover { background: rgba(0,0,0,0.05); }
    select.level-select { padding: 5px; border-radius: 4px; border: 1px solid var(--border); font-weight: bold; color: var(--text); background: var(--card); }

    /* --- 3. MAIN LAYOUT --- */
    .viewport { flex-grow: 1; overflow-y: auto; padding: 15px; padding-bottom: 90px; scroll-behavior: smooth; }
    .hub { display: none; animation: fadeIn 0.3s ease-out; }
    .hub.active { display: block; }
    body:not(.tsa-init-done) #view-select { display: none !important; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

    /* --- 4. CARDS & GRID --- */
    .section-header { font-size: 0.85rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text); opacity: 0.7; margin: 20px 0 10px 0; border-bottom: 2px solid var(--border); padding-bottom: 5px; font-weight: bold; }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 10px; }
    #wizard-options.grid { grid-template-columns: repeat(auto-fill, 260px); gap: 12px; align-items: stretch; justify-content: start; }
    #wizard-options .btn { width: 100%; white-space: normal; word-wrap: break-word; overflow-wrap: break-word; text-align: left; min-height: 44px; height: auto; padding: 12px 15px; display: flex; justify-content: flex-start; align-items: flex-start; line-height: 1.4; box-sizing: border-box; }
    .card { background: var(--card); padding: 15px; border-radius: 8px; border: 1px solid var(--border); box-shadow: 0 2px 4px rgba(0,0,0,0.05); cursor: pointer; position: relative; transition: transform 0.1s; overflow: hidden; }
    .card-lab-quote { overflow: visible; }
    .card-lab-quote .card-edit-btn, .card-select-quote .card-edit-btn { position: absolute; top: 8px; right: 8px; background: var(--card); border: 1px solid var(--border); border-radius: 4px; padding: 6px 8px; font-size: 1rem; cursor: pointer; z-index: 5; opacity: 0.85; transition: opacity 0.2s, background 0.2s; }
    .card-lab-quote .card-edit-btn:hover, .card-select-quote .card-edit-btn:hover { opacity: 1; background: rgba(0, 150, 136, 0.15); border-color: var(--primary); }
    .card:hover { transform: translateY(-2px); border-color: var(--primary); }
    .card::before { content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 5px; }
    .card-tone::before { background: var(--tone-color); }
    .card-structure::before { background: var(--struct-color); }
    .card-language::before { background: var(--lang-color); }
    .card-global { border-left: 5px solid #607d8b; }
    .quote-text { font-family: 'Georgia', serif; font-style: italic; font-size: 1.05rem; color: var(--text); display: block; margin-bottom: 8px; }
    .quote-dim { opacity: 0.5; filter: grayscale(1); }
    .quote-picked { color: var(--success); font-weight: 700; }
    .card-meta { display: flex; justify-content: space-between; font-size: 0.75rem; text-transform: uppercase; font-weight: bold; opacity: 0.6; }

    /* --- 5. WRITING DESK --- */
    .builder-area { background: var(--card); padding: 15px; border-radius: 8px; border: 1px solid var(--border); margin-bottom: 20px; }
    .slot-row { margin-bottom: 10px; }
    .slot-label { font-size: 0.75rem; font-weight: 700; color: var(--primary); text-transform: uppercase; display: block; margin-bottom: 3px; }
    .slot-select, .slot-input { width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 4px; font-size: 1rem; background: var(--bg); color: var(--text); }
    .slot-static { background: rgba(0, 150, 136, 0.1); color: var(--primary); padding: 10px; border-radius: 4px; font-style: italic; border: 1px solid var(--border); }
    .preview-box { padding: 15px; background: var(--card); border: 2px dashed var(--accent); border-radius: 8px; font-size: 1.1rem; line-height: 1.5; min-height: 60px; margin-bottom: 15px; color: var(--text); }
    .hint-panel { background: rgba(255, 152, 0, 0.12); border: 1px solid var(--accent); color: var(--text); padding: 8px 10px; border-radius: 6px; font-size: 0.9rem; margin-bottom: 10px; }
    .hint-panel.hidden { display: none; }
    textarea.essay-area { width: 100%; height: 200px; padding: 10px; border: 1px solid var(--border); border-radius: 8px; font-size: 1rem; font-family: inherit; resize: vertical; margin-bottom: 10px; background: var(--card); color: var(--text); }

    /* --- 6. BUTTONS & UI --- */
    .btn { width: auto; padding: 8px 14px; border: none; border-radius: 6px; font-weight: bold; font-size: 0.95rem; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; gap: 5px; margin: 0 4px 4px 0; white-space: nowrap; }
    .btn-group { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px; }
    .btn-group .btn { margin: 0; }
    .btn-primary { background: var(--primary); color: white; }
    .btn-accent { background: var(--accent); color: white; }
    .btn-doc { background: #1565c0; color: white; }
    .btn-success { background: var(--success); color: white; }
    .btn-danger { background: var(--error); color: white; }
    .btn-outline { background: var(--card); border: 2px solid var(--border); color: var(--text); }
    .btn-small { padding: 4px 8px; font-size: 0.8rem; width: auto; margin: 0; }
    .tab-bar { display:flex; gap:6px; flex-wrap:wrap; margin-bottom:10px; }
    .tab-btn.active { border-color: var(--primary); color: var(--primary); background: rgba(0, 150, 136, 0.08); }
    .filter-bar { display: flex; gap: 5px; overflow-x: auto; padding-bottom: 5px; margin-bottom: 10px; }
    .filter-btn { flex: 1; min-width: 80px; padding: 8px; font-size: 0.85rem; }
    .filter-btn.active { border-color: var(--primary); color: var(--primary); background: rgba(0, 150, 136, 0.08); }

    /* --- 7. MODALS & ADMIN --- */
    .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center; backdrop-filter: blur(2px); }
    .modal.open { display: flex; }
    .modal-content { background: var(--bg); width: 95%; max-width: 900px; max-height: 95vh; border-radius: 10px; display: flex; flex-direction: column; box-shadow: 0 10px 40px rgba(0,0,0,0.3); overflow: hidden; color: var(--text); }
    .modal-header { padding: 15px; background: var(--card); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; font-weight: bold; font-size: 1.1rem; }
    .modal-body { padding: 20px; overflow-y: auto; overflow-x: auto; min-width: 0; }
    
    .admin-section { background: var(--card); border: 1px solid var(--border); border-radius: 6px; padding: 15px; margin-bottom: 15px; }
    .admin-h { color: var(--primary); margin: 0 0 10px 0; font-size: 1rem; border-bottom: 1px solid #eee; padding-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
    .admin-section summary { cursor: pointer; list-style: none; }
    .admin-section summary::-webkit-details-marker { display: none; }
    #level-bank-editor .level-bank-input { width: 100%; max-width: 100%; box-sizing: border-box; padding: 4px 6px; }
    #level-bank-editor .level-bank-row { grid-template-columns: 38px 52px 52px 78px 48px 48px 72px !important; }
    #level-bank-editor .level-bank-header { grid-template-columns: 38px 52px 52px 78px 48px 48px 72px !important; }
    .input-group { margin-bottom: 10px; }
    .input-group label { display: block; font-size: 0.8rem; font-weight: bold; margin-bottom: 3px; }
    .input-group input, .input-group textarea, .input-group select { width: 100%; padding: 8px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text); }
    
    .quote-editor, .struct-editor { border: 1px solid var(--border); border-radius: 6px; padding: 10px; margin-bottom: 10px; background: var(--bg); }
    .editor-header { display: flex; justify-content: space-between; align-items: center; font-weight: bold; margin-bottom: 8px; opacity: 0.8; font-size: 0.9rem; }
    .level-checks { display: flex; gap: 10px; margin-top: 5px; font-size: 0.85rem; align-items: center; }
    .level-checks label { display: flex; align-items: center; gap: 4px; cursor: pointer; }
    .level-checks input { margin: 0; }
    
    .level-rule-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 6px; margin-top: 6px; }
    .level-rule-grid input, .level-rule-grid select { width: 100%; padding: 6px; border: 1px solid var(--border); border-radius: 4px; background: var(--bg); color: var(--text); }
    
    .bank-tags { display: flex; flex-wrap: wrap; gap: 5px; margin-top: 5px; }
    .bank-tag { background: rgba(0,0,0,0.05); border: 1px solid var(--border); padding: 4px 8px; border-radius: 4px; font-size: 0.85rem; display: flex; align-items: center; gap: 5px; }
    .bank-tag button { background: none; border: none; color: var(--error); cursor: pointer; font-weight: bold; }
    .bank-btn-grid { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; }
    .bank-btn-grid button { flex: 0 0 auto; font-size: 0.85rem; padding: 6px 12px; }

    /* Guide Section */
    .guide-box { background: rgba(255, 152, 0, 0.1); border: 1px solid var(--accent); border-radius: 6px; padding: 10px; margin-bottom: 15px; }
    .guide-box summary { font-weight: bold; cursor: pointer; color: var(--accent); list-style: none; display: flex; align-items: center; gap: 5px; }
    .guide-box summary::-webkit-details-marker { display: none; }
    .guide-box summary::before { content: 'üìñ'; }
    .guide-content { margin-top: 10px; font-size: 0.9rem; line-height: 1.5; opacity: 0.9; white-space: pre-wrap; }
    .guide-content p { margin: 0 0 6px 0; }
    .guide-content h4 { margin: 10px 0 5px 0; color: var(--primary); }

    /* --- 8. UTILS & NAV --- */
    .bottom-nav { position: fixed; bottom: 0; left: 0; width: 100%; height: 65px; background: var(--card); border-top: 1px solid var(--border); display: flex; justify-content: space-around; z-index: 900; }
    .nav-item { flex: 1; background: none; border: none; color: var(--text); opacity: 0.5; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; }
    .nav-item.active { color: var(--primary); opacity: 1; background: rgba(0, 150, 136, 0.05); }
    .nav-icon { font-size: 1.4rem; margin-bottom: 2px; }
    .nav-label { font-size: 0.7rem; font-weight: 700; }
    
    .shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
    @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
    @keyframes highlight-pulse { 0% { box-shadow: 0 0 0 0 rgba(0, 150, 136, 0.4); } 50% { box-shadow: 0 0 0 6px rgba(0, 150, 136, 0); } 100% { box-shadow: 0 0 0 0 rgba(0, 150, 136, 0); } }
    .hidden { display: none !important; }
    
    .theme-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-weight: bold; }
    input[type="color"] { border: none; width: 40px; height: 40px; cursor: pointer; background: none; }
    .reader-controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:10px; }
    .reader-label { font-size:0.85rem; display:flex; align-items:center; gap:6px; }
    .reader-controls input[type="range"] { width:120px; }
    .reader-body { position: relative; }
    #source-content, #source-inline, #source-inline-select, #intro-text, #reader-window { font-size: var(--reader-zoom) !important; }
    #source-content, #source-inline-select, #selection-free-select-source { touch-action: manipulation; -webkit-touch-callout: default; }
    .reader-window { position: absolute; left: 10px; right: 10px; top: 72px; height: var(--reader-window-height); border: 2px solid var(--reader-highlight-border); border-radius: 8px; background: var(--reader-highlight); pointer-events: none; z-index: 2; }
    .reader-window-line { display:none; }
    .stage-tag { background: rgba(0,0,0,0.04); border: 1px solid var(--border); padding: 4px 8px; border-radius: 4px; font-size: 0.85rem; display: inline-flex; align-items: center; gap: 5px; }
    .stage-tag.clickable { cursor: pointer; }
    .question-banner { background: rgba(0, 150, 136, 0.08); border: 1px solid var(--border); border-radius: 6px; padding: 8px 10px; margin: 10px 0; font-size: 0.95rem; }

    @media print { .no-print { display: none; } }
    
    .celebration { position: fixed; inset: 0; background: rgba(12, 24, 28, 0.92); z-index: 2500; display: flex; align-items: center; justify-content: center; flex-direction: column; color: white; text-align: center; }
    .celebration.hidden { display: none; }
    .celebration-inner { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); padding: 20px; border-radius: 12px; max-width: 320px; width: 90%; }
    .celebration-inner.celebration-final { max-width: 420px; padding: 28px; border-radius: 16px; border: 2px solid rgba(255,215,0,0.4); box-shadow: 0 0 40px rgba(255,215,0,0.15); }
    .celebration-inner.celebration-final-reward { background: linear-gradient(145deg, rgba(30,60,90,0.95), rgba(20,40,60,0.95)); border-color: rgba(100,200,255,0.35); box-shadow: 0 0 50px rgba(100,200,255,0.2); }
    .celebration-title { font-size: 1.5rem; font-weight: 800; margin-bottom: 8px; }
    .celebration-title.celebration-final-title { font-size: 2rem; margin-bottom: 12px; }
    .celebration-actions { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 8px; }
    .celebration-confetti { position: absolute; inset: 0; overflow: hidden; pointer-events: none; }
    .celebration-emoji { position: absolute; font-size: 1.6rem; animation: floatDown 2.5s linear infinite; opacity: 0.9; }
    @keyframes floatDown { from { transform: translateY(-10vh) rotate(0deg); } to { transform: translateY(110vh) rotate(360deg); } }

    .splash { position: fixed; inset: 0; background: #0f1416; color: #e8f5f2; z-index: 2600; display: flex; align-items: center; justify-content: center; flex-direction: column; transition: opacity 0.6s ease; }
    .splash.hidden { opacity: 0; pointer-events: none; }
    .splash-title { font-size: 2rem; font-weight: 900; letter-spacing: 1px; color: var(--primary); }
    .splash-sub { font-size: 0.95rem; opacity: 0.8; margin-top: 6px; }
    .splash-glow { margin-top: 12px; width: 120px; height: 6px; background: linear-gradient(90deg, transparent, var(--accent), transparent); animation: pulse 1.2s ease-in-out infinite; border-radius: 999px; }
    @keyframes pulse { 0%, 100% { opacity: 0.2; transform: scaleX(0.7); } 50% { opacity: 1; transform: scaleX(1.1); } }
    .intro-screen { position: fixed; inset: 0; background: var(--bg); color: var(--text); z-index: 2550; display: flex; align-items: center; justify-content: center; padding: 20px; text-align: center; transition: opacity 0.6s ease; }
    .intro-screen.hidden { opacity: 0; pointer-events: none; }
    .intro-text { max-width: 700px; font-size: 1.05rem; line-height: 1.6; white-space: pre-wrap; }
    .intro-hint { margin-top: 12px; font-size: 0.85rem; opacity: 0.7; }
    .pick-screen { position: fixed; inset: 0; background: var(--bg); color: var(--text); z-index: 2540; display: flex; align-items: center; justify-content: center; transition: opacity 0.6s ease; }
    .pick-screen.hidden { opacity: 0; pointer-events: none; }
    .pick-title { font-size: 1.4rem; font-weight: 800; color: var(--primary); }

    #emergency-reset { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 9999; background: #d32f2f; color: white; padding: 20px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.5); text-align: center; display: none; }
</style>
</head>
<body>

    <div id="save-status" style="position:fixed; top:10px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); color:white; padding:5px 15px; border-radius:20px; font-size:0.8rem; opacity:0; transition:0.3s; z-index:3000;">üíæ Saved</div>

    <div id="emergency-reset">
        <h2>‚ö†Ô∏è App Crashed</h2>
        <p>The loaded data was corrupted.</p>
        <button class="btn btn-outline" style="background:white; color:black; margin-top:10px;" onclick="localStorage.clear(); location.reload();">Emergency Reset</button>
    </div>

    <div id="celebration-overlay" class="celebration hidden">
        <div class="celebration-confetti" id="celebration-confetti"></div>
        <div class="celebration-inner" id="celebration-inner">
            <div class="celebration-title" id="celebration-title">Level Complete! üéâ</div>
            <div id="celebration-sub" style="margin-bottom:15px; color:#cfd8dc;">Great work!</div>
            <div class="celebration-actions" id="celebration-actions">
                <button class="btn btn-primary" id="celebration-btn" onclick="ui.closeCelebration()">Continue</button>
                <button class="btn btn-outline" id="celebration-reward" style="display:none;">Play Reward</button>
                <button class="btn btn-outline" id="celebration-quit" style="display:none;">Quit</button>
            </div>
        </div>
    </div>

    <div id="splash-screen" class="splash hidden">
        <div class="splash-title">Answer Architect</div>
        <div class="splash-sub">Booting your analysis tools...</div>
        <div class="splash-glow"></div>
    </div>

    <div id="intro-text-screen" class="intro-screen hidden">
        <div>
            <div id="intro-text" class="intro-text">Loading text...</div>
            <div class="intro-hint">Get ready to explore the language.</div>
        </div>
    </div>

    <div id="pick-quote-screen" class="pick-screen hidden">
        <div class="pick-title">Pick a quote</div>
    </div>

    <header class="no-print">
        <h1>
            <button class="icon-btn" onclick="app.resetSession()" style="color:red; border-color:red;" title="Reset Session">‚ú®</button>
            Tone & Structure
            <span class="score-badge" id="score-display">0 XP</span>
            <span class="score-badge" id="level-display">Lvl 1</span>
        </h1>
        <div class="header-controls">
            <button class="icon-btn" onclick="ui.openModal('modal-help')">‚ùì</button>
            <button class="icon-btn" onclick="ui.openModal('modal-theme')" title="Colors">üé®</button>
            <select id="level-selector" class="level-select" onchange="app.setLevel(this.value)"></select>
            <button class="icon-btn" id="btn-admin" onclick="ui.openAdmin()">Data</button>
        </div>
    </header>

    <div class="viewport no-print">
        
        <div id="view-lab" class="hub">
            <div style="display:flex; justify-content:space-between; align-items:center; background:var(--card); padding:10px; border-bottom:1px solid var(--border);">
                <div><strong>Topic:</strong> <span id="lbl-title">...</span></div>
                <button class="btn btn-outline" style="width:auto; padding:5px 10px;" onclick="ui.openModal('modal-source')">üìÑ View Text</button>
            </div>
            
            <div style="padding:10px;">
                <div id="question-banner" class="question-banner hidden"></div>
                <details class="guide-box" open>
                    <summary>Source Text (Tap to collapse)</summary>
                    <div class="guide-content" id="source-inline"></div>
                </details>

                <div class="filter-bar">
                    <button class="btn btn-outline filter-btn" data-filter="all" onclick="app.setFilter('all')">All</button>
                    <button class="btn btn-outline filter-btn" data-filter="language" onclick="app.setFilter('language')">Lang</button>
                    <button class="btn btn-outline filter-btn" data-filter="structure" onclick="app.setFilter('structure')">Struct</button>
                    <button class="btn btn-outline filter-btn" data-filter="tone" onclick="app.setFilter('tone')">Tone</button>
                    <button class="btn btn-outline filter-btn" id="btn-show-done" onclick="app.toggleDone()">Show Done</button>
                </div>

                <div id="quote-grid" class="grid"></div>
                
                <div class="section-header" style="margin-top:20px;">Global Analysis</div>
                <div id="global-card-container"></div>
            </div>
        </div>

    <div id="view-select" class="hub">
        <div style="display:flex; justify-content:space-between; align-items:center; background:var(--card); padding:10px; border-bottom:1px solid var(--border);">
            <div><strong>Topic:</strong> <span id="lbl-title-select">...</span></div>
            <button class="btn btn-outline" style="width:auto; padding:5px 10px;" onclick="ui.openModal('modal-source')">üìÑ View Text</button>
        </div>
        <div style="padding:15px;">
            <div id="question-banner-select" class="question-banner hidden"></div>
            <details class="guide-box" open>
                <summary>Source Text (Tap to collapse)</summary>
                <div class="guide-content" id="source-inline-select"></div>
            </details>
            <div id="selection-area"></div>
        </div>
    </div>

        <div id="view-desk" class="hub active">
            <div style="display:flex; justify-content:space-between; align-items:center; background:var(--card); padding:10px; border-bottom:1px solid var(--border);">
                <div><strong>Topic:</strong> <span id="lbl-title-desk">...</span></div>
            </div>
            <div style="padding:15px;">
                <div id="question-banner-desk" class="question-banner hidden"></div>
                <div class="section-header" style="margin-top:0;">Sentence Construction</div>
                <div id="desk-quote-tabs" class="hidden" style="display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 10px 0;"></div>
                <div id="sentence-builder" class="builder-area">
                    <div style="text-align:center; opacity:0.6; padding:20px;" id="desk-placeholder">If you see this text, you are on the updated file (opens to Writing Desk). Select a quote in the Evidence Lab or Quote Select to start.</div>
                </div>

                <div class="section-header">Preview & Edit</div>
                <div id="preview-box" class="preview-box" contenteditable="true"></div>
                <div id="hint-panel" class="hint-panel hidden"></div>
                
                <div class="btn-group" style="margin-bottom:20px;">
                    <button class="btn btn-accent" onclick="app.undo()">Undo</button>
                    <button class="btn btn-primary" onclick="app.commitSentence()">Commit to Answer ‚¨á</button>
                </div>

                <div id="essay-topic-banner" class="question-banner hidden" style="margin-bottom:8px;"></div>
                <textarea id="essay-area" class="essay-area" placeholder="Your answer will appear here..." oninput="app.updateEssay(this.value)"></textarea>
                
                <div class="btn-group">
                    <button class="btn btn-doc" onclick="app.exportDoc()">Download .doc</button>
                    <button class="btn btn-danger" onclick="app.clearEssay()">Clear</button>
                </div>
            </div>
        </div>
    </div>

    <nav class="bottom-nav no-print">
        <button class="nav-item" onclick="ui.switchView('select')" id="nav-select">
            <span class="nav-icon">üéØ</span><span class="nav-label">Quote Select</span>
        </button>
        <button class="nav-item" onclick="ui.switchView('lab')" id="nav-lab">
            <span class="nav-icon">üß™</span><span class="nav-label">Evidence Lab</span>
        </button>
        <button class="nav-item active" onclick="ui.switchView('desk')" id="nav-desk">
            <span class="nav-icon">‚úçÔ∏è</span><span class="nav-label">Writing Desk</span>
        </button>
    </nav>

    <div id="modal-source" class="modal">
        <div class="modal-content">
            <div class="modal-header">Source Text <button class="icon-btn" onclick="ui.closeModal('modal-source')">‚úï</button></div>
            <div class="modal-body reader-body">
                <div class="reader-controls">
                    <button class="btn btn-outline btn-small" id="reader-toggle" onclick="ui.toggleReader()">Auto-Scroll</button>
                    <label class="reader-label">Speed
                        <input type="range" id="reader-speed" min="1" max="120" value="40">
                    </label>
                    <label class="reader-label">Zoom
                        <input type="range" id="reader-zoom" min="90" max="160" value="110" oninput="ui.applyReaderZoom(this.value)" onchange="ui.applyReaderZoom(this.value)">
                    </label>
                    <label class="reader-label">Window
                        <input type="range" id="reader-height" min="2" max="8" step="0.2" value="3.2">
                    </label>
                    <button class="btn btn-outline btn-small" onclick="ui.toggleHighlight()">Highlight</button>
                    <label class="reader-label">Color
                        <input type="color" id="col-reader" onchange="ui.setReaderHighlight(this.value)">
                    </label>
                    <label class="reader-label">Opacity
                        <input type="range" id="col-reader-alpha" min="0.02" max="0.2" step="0.01" onchange="ui.setReaderHighlightOpacity(this.value)">
                    </label>
                    <label class="reader-label">Line
                        <input type="range" id="col-reader-line" min="1" max="6" step="1" onchange="ui.setReaderLineThickness(this.value)">
                    </label>
                    <button class="btn btn-outline btn-small" onclick="ui.copySourceText()">Copy Text</button>
                    <button class="btn btn-outline btn-small" onclick="ui.resetReader()">Reset</button>
                </div>
                <div id="reader-window" class="reader-window hidden"><div class="reader-window-line"></div></div>
                <div id="source-content" style="white-space:pre-wrap; line-height:1.6; font-size:1.1rem; font-family:'Georgia'; max-height:60vh; overflow:auto; padding-right:4px; user-select:text; -webkit-user-select:text;"></div>
            </div>
        </div>
    </div>

    <div id="modal-wizard" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span id="wizard-title">Analysis</span> <button class="icon-btn" onclick="ui.closeModal('modal-wizard')">‚úï</button></div>
            <div class="modal-body">
                <div id="wizard-prompt" style="margin-bottom:15px;"></div>
                <div id="wizard-options" class="grid"></div>
            </div>
        </div>
    </div>

    <div id="modal-help" class="modal">
        <div class="modal-content" style="max-width:500px;">
            <div class="modal-header">Student Help <button class="icon-btn" onclick="ui.closeModal('modal-help')">‚úï</button></div>
            <div class="modal-body">
                <p><strong>1. Evidence Lab:</strong> Read the source text. Click on colored quote cards to analyze them. Correct answers earn XP.</p>
                <hr>
                <p><strong>2. Writing Desk:</strong> Use the dropdown menus to build professional analytical sentences. You can edit the text manually before adding it to your final essay.</p>
            </div>
        </div>
    </div>

    <div id="modal-theme" class="modal">
        <div class="modal-content" style="max-width:350px;">
            <div class="modal-header">Theme Colors <button class="icon-btn" onclick="ui.closeModal('modal-theme')">‚úï</button></div>
            <div class="modal-body">
                <div class="theme-row"><span>Background:</span> <input type="color" id="col-bg" onchange="ui.setTheme('bg', this.value)"></div>
                <div class="theme-row"><span>Text Color:</span> <input type="color" id="col-text" onchange="ui.setTheme('text', this.value)"></div>
                <div class="theme-row"><span>Card Color:</span> <input type="color" id="col-card" onchange="ui.setTheme('card', this.value)"></div>
                <hr>
                <button class="btn btn-outline" onclick="ui.resetTheme()">Reset to Defaults</button>
            </div>
        </div>
    </div>

    <div id="modal-admin" class="modal">
        <div class="modal-content">
            <div class="modal-header">Teacher Settings <button class="icon-btn" onclick="ui.closeModal('modal-admin')">‚úï</button></div>
            <div class="modal-body">
                <div class="tab-bar" id="admin-tabs">
                    <button class="btn btn-outline btn-small tab-btn" data-tab="controls">Controls</button>
                    <button class="btn btn-outline btn-small tab-btn" data-tab="edit">Editing Suite</button>
                    <button class="btn btn-outline btn-small tab-btn" data-tab="ai">Load & AI</button>
                    <button class="btn btn-outline btn-small tab-btn" data-tab="export">Lobby</button>
                </div>
                <div class="admin-tab" data-tab="controls">
                <div class="admin-section">
                    <h3 class="admin-h">üõ†Ô∏è Controls</h3>
                    <label style="display:block; margin-bottom:5px;"><input type="checkbox" id="keep-unlocked" onchange="admin.setUnlocked(this.checked)"> Keep Unlocked</label>
                    <label style="display:block; margin-bottom:5px;"><input type="checkbox" id="auto-progress" onchange="admin.setAutoProgress(this.checked)"> Auto-progress Levels</label>
                    <div class="input-group" style="margin-top:8px;">
                        <label>Reward Link (Student)</label>
                        <input type="text" id="reward-url" placeholder="https://example.com/game" onchange="admin.setRewardUrl(this.value)">
                        <div style="font-size:0.8rem; opacity:0.7; margin-top:4px;">Shown on Level Complete screen.</div>
                    </div>
                    <div class="input-group" style="margin-top:6px;">
                        <label>Reward Time (minutes)</label>
                        <input type="number" id="reward-minutes" min="0" value="0" onchange="admin.setRewardMinutes(this.value)">
                        <div style="font-size:0.8rem; opacity:0.7; margin-top:4px;">0 disables time limit.</div>
                    </div>
                    <div class="input-group" style="margin-top:6px;">
                        <label>Reward Every N Levels</label>
                        <input type="number" id="reward-every-levels" min="0" value="0" onchange="admin.setRewardEveryLevels(this.value)">
                        <div style="font-size:0.8rem; opacity:0.7; margin-top:4px;">0 disables; reward shows every N levels.</div>
                    </div>
                    <div class="input-group" style="margin-top:6px;">
                        <label>Reward Only at End</label>
                        <label style="display:flex; align-items:center; gap:6px; font-size:0.9rem;">
                            <input type="checkbox" id="reward-at-end" onchange="admin.setRewardAtEnd(this.checked)"> Show reward only after final level
                        </label>
                    </div>
                    <div class="input-group" style="margin-top:6px;">
                        <label>Quote Selection: Allow Partial</label>
                        <label style="display:flex; align-items:center; gap:6px; font-size:0.9rem;">
                            <input type="checkbox" id="allow-partial-selection" onchange="admin.setAllowPartialSelection(this.checked)"> Allow fewer correct quotes than target
                        </label>
                    </div>
                    <label style="display:block; margin-bottom:6px;"><input type="checkbox" id="practice-mode" onchange="admin.setPracticeMode(this.checked)"> Practice Mode (lock selected level)</label>
                    <div style="display:flex; gap:6px; align-items:center; margin-bottom:6px;">
                        <label style="font-size:0.85rem;">Start in:</label>
                        <select id="start-view" onchange="admin.setStartView(this.value)" style="padding:4px;">
                            <option value="select">Quote Select</option>
                            <option value="lab">Evidence Lab</option>
                            <option value="desk">Writing Desk</option>
                        </select>
                    </div>
                    <label style="display:block; margin-bottom:6px;"><input type="checkbox" id="strict-mode" onchange="admin.setStrictMode(this.checked)"> Strict Mode (block incorrect choices)</label>
                    <button class="btn btn-outline" onclick="admin.resetSelectionProgress()">Reset Selection Progress</button>
                    <div style="display:flex; gap:6px; align-items:center; font-size:0.85rem;">
                        <span>Practice Level:</span>
                        <select id="practice-level" onchange="admin.setPracticeLevel(this.value)" style="padding:4px;">
                            <option value="1">Level 1</option>
                            <option value="2">Level 2</option>
                            <option value="3">Level 3</option>
                            <option value="4">Level 4</option>
                            <option value="5">Level 5</option>
                            <option value="6">Level 6</option>
                            <option value="7">Level 7</option>
                            <option value="8">Level 8</option>
                            <option value="9">Level 9</option>
                        </select>
                    </div>
                    <div class="input-group" style="margin-top:10px;">
                        <label>Topic / Focus Question (student view)</label>
                        <input type="text" id="focus-question" placeholder="e.g. How does the writer use language?" onchange="admin.setFocusQuestion(this.value)">
                    </div>
                    <label style="display:block; margin-top:6px; font-size:0.85rem;"><input type="checkbox" id="practice-force-auto" onchange="admin.setPracticeForceAuto(this.checked)"> Practice Auto-only (no manual slots)</label>
                    <label style="display:block; margin-top:6px; font-size:0.85rem;"><input type="checkbox" id="practice-fixed-template" onchange="admin.setPracticeFixedTemplate(this.checked)"> Practice Fixed Template (ignore custom structure)</label>
                    <div style="margin-top:8px; font-size:0.85rem;">
                        Active Levels:
                        <div id="active-levels" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:6px;"></div>
                    </div>
                    <div style="margin-top:8px; font-size:0.85rem;">
                        Active Modules:
                        <div id="modules-active" style="display:flex; flex-wrap:wrap; gap:6px; margin-top:6px;"></div>
                        <div style="font-size:0.8rem; opacity:0.8; margin-top:4px;">Check <strong>Quote Select</strong> to show and use the Quote Select tab. If it is greyed out or missing, ensure this is checked and save.</div>
                    </div>
                </div>
                </div>

                <div class="admin-tab" data-tab="edit">
                <details class="admin-section" open>
                    <summary class="admin-h">üß≠ Quote Selection Editor</summary>
                    <div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">Mark quotes as analysis-worthy or noise. Edit reasons and distractors for teacher control.</div>
                    <div id="selection-editor-list" style="padding-right:5px;"></div>
                    <button class="btn btn-success" onclick="admin.addSelectionItem()">+ Add Selection Quote</button>
                </details>

                <details class="admin-section" open>
                    <summary class="admin-h">üìù Edit Evidence (Quotes)</summary>
                    <div id="quote-editor-list" style="padding-right:5px;"></div>
                    <div style="display:flex; gap:8px; flex-wrap:wrap; margin:6px 0 10px 0;">
                        <button class="btn btn-outline btn-small" onclick="admin.generateAndSplitModelAnswers()">Generate & Split Model Answers</button>
                    </div>
                    <button class="btn btn-success" onclick="admin.addQuote()">+ New Quote</button>
                </details>

                <details class="admin-section">
                    <summary class="admin-h">‚úçÔ∏è Analysis Banks Editor</summary>
                    <div class="bank-btn-grid">
                        <button class="btn btn-outline" onclick="admin.editBank('markers')">Markers</button>
                        <button class="btn btn-outline" onclick="admin.editBank('starters')">Starters</button>
                        <button class="btn btn-outline" onclick="admin.editBank('methods')">Methods</button>
                        <button class="btn btn-outline" onclick="admin.editBank('points')">Points</button>
                    </div>
                    <div class="bank-btn-grid">
                        <button class="btn btn-outline" style="border-color:var(--primary);" onclick="admin.editBank('link_l1')">Links L1</button>
                        <button class="btn btn-outline" style="border-color:var(--primary);" onclick="admin.editBank('link_l2')">Links L2</button>
                        <button class="btn btn-outline" style="border-color:var(--primary);" onclick="admin.editBank('link_l3')">Links L3</button>
                    </div>
                    
                    <div id="bank-editor-ui" class="hidden" style="background:var(--bg); padding:10px; border-radius:6px; border:1px solid var(--border);">
                        <strong id="bank-name-display" style="display:block; margin-bottom:5px; color:var(--primary);"></strong>
                        <div style="display:flex; gap:5px; margin-bottom:10px;">
                            <input id="bank-add-input" placeholder="New item..." style="flex:1;">
                            <button class="btn btn-primary" style="width:auto; margin:0;" onclick="admin.addBankItem()">Add</button>
                        </div>
                        <div id="bank-list-container"></div>
                    </div>
                </details>

                <details class="admin-section">
                    <summary class="admin-h">‚öôÔ∏è Sentence Structure</summary>
                    <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
                        <label style="font-size:0.85rem;">Level</label>
                        <select id="config-level-select" onchange="admin.renderConfig(parseInt(this.value, 10))" style="padding:4px;">
                            <option value="1">Level 1</option>
                            <option value="2">Level 2</option>
                            <option value="3">Level 3</option>
                            <option value="4">Level 4</option>
                            <option value="5">Level 5</option>
                            <option value="6">Level 6</option>
                            <option value="7">Level 7</option>
                            <option value="8">Level 8</option>
                            <option value="9">Level 9</option>
                        </select>
                    </div>
                    <div id="config-slots"></div>
                </details>

                <details class="admin-section">
                    <summary class="admin-h">üéöÔ∏è Level Bank (1‚Äì9)</summary>
                    <div style="font-size:0.85rem; opacity:0.8; margin-bottom:4px;">Controls word limits, ellipses, and language tier used across modules.</div>
                    <div style="font-size:0.8rem; opacity:0.7; margin-bottom:8px;">Quote targets = correct real quotes. Weak quotes = real quotes that do not answer the question.</div>
                    <div id="level-bank-editor"></div>
                </details>

                <details class="admin-section">
                    <summary class="admin-h">üèóÔ∏è Global Structure Questions</summary>
                    <div id="global-editor-list"></div>
                    <button class="btn btn-success" onclick="admin.addGlobalQuestion()">+ Add Question</button>
                </details>
                </div>

                <div class="admin-tab" data-tab="ai">
                
                <details class="guide-box">
                    <summary>Teacher Guide (Click to collapse)</summary>
                    <div class="guide-content">
                        <h4>ü§ñ AI Lesson Generator (Important)</h4>
                        <ol style="padding-left:20px; margin:0;">
                            <li>Paste your Source Text and Focus Question below.</li>
                            <li>Click <strong>Generate Prompt</strong>.</li>
                            <li><strong>Copy the generated prompt text.</strong></li>
                            <li>Paste it into ChatGPT, Claude, or Gemini.</li>
                            <li>Copy the <strong>JSON code</strong> the AI gives you.</li>
                            <li>Paste that JSON into the box below and click <strong>Load Data</strong>.</li>
                        </ol>
                        <h4>‚öôÔ∏è Structure & Banks</h4>
                        <p>Customize the sentence builders for Levels 1-3. Select 'point' to use AI-generated analysis points.</p>
                        <h4>üìÑ Worksheet</h4>
                        <p>Exports a Word doc with 'Match the Meaning' and 'Analysis' sections.</p>
                    </div>
                </details>

                <div class="admin-section" style="background:rgba(33, 150, 243, 0.1); border-color:#2196f3;">
                    <h3 class="admin-h" style="color:#1565c0;">ü§ñ AI Lesson Generator</h3>
                    <div class="input-group">
                        <label>Lesson Focus / Question</label>
                        <input type="text" id="ai-question" placeholder="e.g. How is tension created?" style="border:2px solid #2196f3;">
                    </div>
                    <div class="input-group">
                        <label>Source Text</label>
                        <textarea id="ai-input" style="height:60px; width:100%; border:1px solid #ccc;" placeholder="Paste text here..."></textarea>
                    </div>
                    <div style="display:flex; gap:6px; flex-wrap:wrap; margin-bottom:8px;">
                        <button class="btn btn-outline btn-small" onclick="admin.loadSavedSourceQuestion()">Use saved text + question</button>
                        <div style="font-size:0.8rem; opacity:0.7; align-self:center;">Source text is applied automatically on paste.</div>
                    </div>
                    <div style="display:flex; gap:10px; margin-bottom:6px;">
                        <div style="flex:1"><label style="font-size:0.8rem">Mode</label><select id="ai-mode" style="width:100%; padding:5px;"><option value="replace">Replace All</option><option value="append">Append</option></select></div>
                        <div style="width:120px"><label style="font-size:0.8rem">Quotes (lesson items)</label><input type="number" id="ai-count" value="6" min="1" max="20" style="width:100%; padding:5px;"></div>
                    </div>
                    <div style="font-size:0.75rem; opacity:0.7; margin-bottom:8px;">This count is for correct lesson quotes; distractors are generated inside each item.</div>
                    <div class="input-group" style="margin-bottom:8px;">
                        <label>Include for analysis (AI &amp; export)</label>
                        <div class="level-checks" style="margin-top:0;">
                            <label>Language<input type="checkbox" checked disabled></label>
                            <label>Tone<input type="checkbox" id="ai-include-tone" onchange="admin.setAiDevice('tone', this.checked)"></label>
                            <label>Structure<input type="checkbox" id="ai-include-structure" onchange="admin.setAiDevice('structure', this.checked)"></label>
                        </div>
                        <div style="font-size:0.75rem; opacity:0.7;">Controls both AI prompts and student app exports.</div>
                    </div>
                    <button class="btn btn-outline btn-small" onclick="admin.toggleAiPanel()" style="margin-bottom:8px;">Show/Hide JSON Panel</button>
                    <details class="guide-box">
                        <summary>Level Rules (1‚Äì9)</summary>
                        <div class="guide-content">
                    <div class="input-group">
                        <label>Levels Included</label>
                        <div class="level-checks" style="margin-top:0;">
                            <label>1<input type="checkbox" id="ai-level-1" checked></label>
                            <label>2<input type="checkbox" id="ai-level-2" checked></label>
                            <label>3<input type="checkbox" id="ai-level-3" checked></label>
                            <label>4<input type="checkbox" id="ai-level-4"></label>
                            <label>5<input type="checkbox" id="ai-level-5"></label>
                            <label>6<input type="checkbox" id="ai-level-6"></label>
                            <label>7<input type="checkbox" id="ai-level-7"></label>
                            <label>8<input type="checkbox" id="ai-level-8"></label>
                            <label>9<input type="checkbox" id="ai-level-9"></label>
                        </div>
                    </div>
                    <label style="display:block; font-size:0.85rem; margin-bottom:8px;"><input type="checkbox" id="ai-all-levels" onchange="admin.setAiAllLevels(this.checked)"> Include all 9 levels in prompt</label>
                    <div class="input-group">
                        <label>Level 1 Rules (Below GCSE Pass)</label>
                        <div class="level-rule-grid">
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Count</label>
                                <input type="number" id="ai-l1-count" min="0" placeholder="L1 count">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Max words</label>
                                <input type="number" id="ai-l1-words" min="3" value="12" placeholder="Max words">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Complexity</label>
                                <select id="ai-l1-complex">
                                    <option value="very simple">Very simple</option>
                                    <option value="simple">Simple</option>
                                    <option value="medium">Medium</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Subtlety</label>
                                <select id="ai-l1-subtle">
                                    <option value="obvious">Obvious distractors</option>
                                    <option value="medium">Medium subtlety</option>
                                    <option value="subtle">Subtle</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Ellipses if &gt;</label>
                                <input type="number" id="ai-l1-ellipsis" min="3" value="7" placeholder="Words">
                            </div>
                        </div>
                    </div>
                    <div class="input-group">
                        <label>Level 2 Rules (GCSE 3-4)</label>
                        <div class="level-rule-grid">
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Count</label>
                                <input type="number" id="ai-l2-count" min="0" placeholder="L2 count">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Max words</label>
                                <input type="number" id="ai-l2-words" min="3" value="20" placeholder="Max words">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Complexity</label>
                                <select id="ai-l2-complex">
                                    <option value="simple">Simple</option>
                                    <option value="medium" selected>Medium</option>
                                    <option value="advanced">Advanced</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Subtlety</label>
                                <select id="ai-l2-subtle">
                                    <option value="obvious">Obvious distractors</option>
                                    <option value="medium" selected>Medium subtlety</option>
                                    <option value="subtle">Subtle</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Ellipses if &gt;</label>
                                <input type="number" id="ai-l2-ellipsis" min="3" value="7" placeholder="Words">
                            </div>
                        </div>
                    </div>
                    <div class="input-group">
                        <label>Level 3 Rules (GCSE 4+)</label>
                        <div class="level-rule-grid">
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Count</label>
                                <input type="number" id="ai-l3-count" min="0" placeholder="L3 count">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Max words</label>
                                <input type="number" id="ai-l3-words" min="3" value="30" placeholder="Max words">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Complexity</label>
                                <select id="ai-l3-complex">
                                    <option value="medium">Medium</option>
                                    <option value="advanced" selected>Advanced</option>
                                    <option value="very advanced">Very advanced</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Subtlety</label>
                                <select id="ai-l3-subtle">
                                    <option value="medium">Medium subtlety</option>
                                    <option value="subtle" selected>Subtle</option>
                                    <option value="very subtle">Very subtle</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Ellipses if &gt;</label>
                                <input type="number" id="ai-l3-ellipsis" min="3" value="7" placeholder="Words">
                            </div>
                        </div>
                    </div>
                    <div class="input-group">
                        <label>Level 4 Rules</label>
                        <div class="level-rule-grid">
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Count</label>
                                <input type="number" id="ai-l4-count" min="0" placeholder="L4 count">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Max words</label>
                                <input type="number" id="ai-l4-words" min="3" value="34" placeholder="Max words">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Complexity</label>
                                <select id="ai-l4-complex">
                                    <option value="medium">Medium</option>
                                    <option value="advanced" selected>Advanced</option>
                                    <option value="very advanced">Very advanced</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Subtlety</label>
                                <select id="ai-l4-subtle">
                                    <option value="medium">Medium subtlety</option>
                                    <option value="subtle" selected>Subtle</option>
                                    <option value="very subtle">Very subtle</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Ellipses if &gt;</label>
                                <input type="number" id="ai-l4-ellipsis" min="3" value="7" placeholder="Words">
                            </div>
                        </div>
                    </div>
                    <div class="input-group">
                        <label>Level 5 Rules</label>
                        <div class="level-rule-grid">
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Count</label>
                                <input type="number" id="ai-l5-count" min="0" placeholder="L5 count">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Max words</label>
                                <input type="number" id="ai-l5-words" min="3" value="38" placeholder="Max words">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Complexity</label>
                                <select id="ai-l5-complex">
                                    <option value="medium">Medium</option>
                                    <option value="advanced" selected>Advanced</option>
                                    <option value="very advanced">Very advanced</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Subtlety</label>
                                <select id="ai-l5-subtle">
                                    <option value="medium">Medium subtlety</option>
                                    <option value="subtle" selected>Subtle</option>
                                    <option value="very subtle">Very subtle</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Ellipses if &gt;</label>
                                <input type="number" id="ai-l5-ellipsis" min="3" value="7" placeholder="Words">
                            </div>
                        </div>
                    </div>
                    <div class="input-group">
                        <label>Level 6 Rules</label>
                        <div class="level-rule-grid">
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Count</label>
                                <input type="number" id="ai-l6-count" min="0" placeholder="L6 count">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Max words</label>
                                <input type="number" id="ai-l6-words" min="3" value="42" placeholder="Max words">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Complexity</label>
                                <select id="ai-l6-complex">
                                    <option value="advanced">Advanced</option>
                                    <option value="very advanced" selected>Very advanced</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Subtlety</label>
                                <select id="ai-l6-subtle">
                                    <option value="subtle">Subtle</option>
                                    <option value="very subtle" selected>Very subtle</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Ellipses if &gt;</label>
                                <input type="number" id="ai-l6-ellipsis" min="3" value="7" placeholder="Words">
                            </div>
                        </div>
                    </div>
                    <div class="input-group">
                        <label>Level 7 Rules</label>
                        <div class="level-rule-grid">
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Count</label>
                                <input type="number" id="ai-l7-count" min="0" placeholder="L7 count">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Max words</label>
                                <input type="number" id="ai-l7-words" min="3" value="46" placeholder="Max words">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Complexity</label>
                                <select id="ai-l7-complex">
                                    <option value="advanced">Advanced</option>
                                    <option value="very advanced" selected>Very advanced</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Subtlety</label>
                                <select id="ai-l7-subtle">
                                    <option value="subtle">Subtle</option>
                                    <option value="very subtle" selected>Very subtle</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Ellipses if &gt;</label>
                                <input type="number" id="ai-l7-ellipsis" min="3" value="7" placeholder="Words">
                            </div>
                        </div>
                    </div>
                    <div class="input-group">
                        <label>Level 8 Rules</label>
                        <div class="level-rule-grid">
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Count</label>
                                <input type="number" id="ai-l8-count" min="0" placeholder="L8 count">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Max words</label>
                                <input type="number" id="ai-l8-words" min="3" value="50" placeholder="Max words">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Complexity</label>
                                <select id="ai-l8-complex">
                                    <option value="advanced">Advanced</option>
                                    <option value="very advanced" selected>Very advanced</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Subtlety</label>
                                <select id="ai-l8-subtle">
                                    <option value="subtle">Subtle</option>
                                    <option value="very subtle" selected>Very subtle</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Ellipses if &gt;</label>
                                <input type="number" id="ai-l8-ellipsis" min="3" value="7" placeholder="Words">
                            </div>
                        </div>
                    </div>
                    <div class="input-group">
                        <label>Level 9 Rules</label>
                        <div class="level-rule-grid">
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Count</label>
                                <input type="number" id="ai-l9-count" min="0" placeholder="L9 count">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Max words</label>
                                <input type="number" id="ai-l9-words" min="3" value="54" placeholder="Max words">
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Complexity</label>
                                <select id="ai-l9-complex">
                                    <option value="advanced">Advanced</option>
                                    <option value="very advanced" selected>Very advanced</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Subtlety</label>
                                <select id="ai-l9-subtle">
                                    <option value="subtle">Subtle</option>
                                    <option value="very subtle" selected>Very subtle</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size:0.75rem; opacity:0.7;">Ellipses if &gt;</label>
                                <input type="number" id="ai-l9-ellipsis" min="3" value="7" placeholder="Words">
                            </div>
                        </div>
                    </div>
                    <div style="display:flex; gap:8px; flex-wrap:wrap;">
                        <button class="btn btn-outline" onclick="admin.generatePrompt()">Generate Lesson Prompt</button>
                        <button class="btn btn-outline" onclick="admin.generateSelectionPrompt()">Generate Quote-Selection Prompt</button>
                        <button class="btn btn-outline" onclick="admin.copyLevelBankToAi()">Copy Level Bank ‚Üí AI</button>
                    </div>
                        </div>
                    </details>
                    <div class="input-group" style="margin-top:10px;">
                        <label>Quote Selection Stages (applies to all lessons)</label>
                        <div style="display:flex; gap:6px; align-items:center; margin-bottom:6px;">
                            <label style="font-size:0.85rem;">Preset</label>
                            <select id="selection-stage-preset" onchange="admin.applySelectionPreset(this.value)" style="padding:4px;">
                                <option value="custom">Custom</option>
                                <option value="beginner">Beginner</option>
                                <option value="intermediate">Intermediate</option>
                                <option value="advanced">Advanced</option>
                            </select>
                        </div>
                        <div id="selection-stages" style="display:flex; flex-wrap:wrap; gap:6px; font-size:0.85rem;"></div>
                    </div>
                <div class="input-group" style="margin-top:10px;">
                    <label>Combined Prompt (lesson + quote selection)</label>
                    <div style="display:flex; gap:6px; flex-wrap:wrap; margin-bottom:6px;">
                        <button class="btn btn-primary btn-small" onclick="admin.generateUnifiedPrompt()">Generate Combined Prompt</button>
                        <button class="btn btn-outline btn-small" onclick="admin.copyUnifiedPrompt()">Copy Combined Prompt</button>
                        <button class="btn btn-outline btn-small" onclick="admin.loadUnifiedFromClipboard()">Load Combined from Clipboard</button>
                        <button class="btn btn-outline btn-small" onclick="admin.pasteUnifiedJson()">Paste Combined JSON</button>
                        <button class="btn btn-success btn-small" onclick="admin.loadUnifiedJson()">Load Combined JSON</button>
                    </div>
                    <textarea id="unified-prompt-out" style="height:80px; width:100%; margin-bottom:6px;" readonly placeholder="Combined prompt will appear here..."></textarea>
                    <textarea id="unified-json-in" style="height:90px; width:100%;" placeholder="Paste combined JSON response here..."></textarea>
                </div>
                    <textarea id="ai-prompt-out" style="height:60px; width:100%; margin-top:10px;" readonly placeholder="Lesson prompt will appear here..."></textarea>
                </div>
                </div>

                <div class="admin-tab" data-tab="export">
                <details class="admin-section" open>
                    <summary class="admin-h">üìå Lesson Templates</summary>
                    <div class="input-group">
                        <label>Template Name</label>
                        <input type="text" id="template-name" placeholder="e.g. Persuasive Writing L2">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-outline" onclick="admin.saveTemplate()">Save Template</button>
                        <button class="btn btn-outline" onclick="admin.loadTemplate()">Load Template</button>
                        <button class="btn btn-outline" onclick="admin.exportTemplates()">Export Templates</button>
                        <label class="btn btn-outline" style="cursor:pointer;">Import Templates<input type="file" id="templates-up" class="hidden" onchange="admin.importTemplates(this)"></label>
                    </div>
                    <select id="template-select" style="width:100%; padding:6px; margin-bottom:6px;"></select>
                    <div style="font-size:0.85rem; opacity:0.7;">Templates store AI settings, sentence structures, level rules, and level bank.</div>
                </details>
                <div class="admin-section">
                    <h3 class="admin-h">üì¶ Export</h3>
                    <div class="btn-group">
                        <button class="btn btn-doc" onclick="admin.exportWorksheet()">üìÑ Worksheet (Word)</button>
                        <button class="btn btn-primary" style="background:#37474f;" onclick="admin.exportStandalone()">üì¶ Student App</button>
                        <label class="btn btn-outline" style="cursor:pointer;">üìÇ Load JSON<input type="file" id="file-up" class="hidden" onchange="admin.loadFile(this)"></label>
                        <button class="btn btn-outline" onclick="admin.saveConfig()">üíæ Save JSON</button>
                    </div>
                    <div style="margin-top:10px; font-size:0.85rem; opacity:0.8;">
                        Match Game Layout:
                        <select id="worksheet-match-mode" onchange="admin.setWorksheetMatchMode(this.value)" style="padding:4px; margin-left:6px;">
                            <option value="jumbled">Jumbled interpretations (draw lines)</option>
                            <option value="aligned">Aligned interpretations (copy lines)</option>
                            <option value="list">Simple list (original)</option>
                        </select>
                    </div>
                </div>

                <button class="btn btn-danger" onclick="app.factoryReset()">‚ö†Ô∏è Factory Reset</button>
                </div>
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
    <script>
        if(window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
        }
    </script>
    <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
    <script>
/** ARCHITECT v5.1 (Safety First) **/

/* --- DEFAULT DATA --- */
const defaultData = {
    meta: { title: "Demo Lesson", author: "System", version: "5.1" },
    sourceText: "The sky was a bruised purple...",
    question: "How is language used?",
    settings: { 
        autoProgress: true,
        practiceMode: false,
        practiceModeLevel: 1,
        practiceForceAuto: false,
        practiceFixedTemplate: false,
        worksheetMatchMode: "jumbled",
        activeLevels: [1,2,3],
        aiPromptAllLevels: false,
        aiIncludeTone: true,
        aiIncludeStructure: true,
        exportIncludeTone: true,
        exportIncludeStructure: true,
        quoteTarget: 4,
        rewardUrl: "",
        rewardMinutes: 0,
        rewardEveryLevels: 0,
        rewardAtEnd: false,
        allowPartialSelection: false,
        strictMode: false,
        selectionStages: ["discriminate","align","justify"],
        modulesActive: { selection: true, lab: true, desk: true },
        levelRules: {
            1: { maxWords: 12, ellipsesMaxWords: 7 },
            2: { maxWords: 20, ellipsesMaxWords: 7 },
            3: { maxWords: 30, ellipsesMaxWords: 7 }
        },
        levelBank: {
            1: { maxWords: 12, ellipsesMaxWords: 7, languageTier: "low", quoteTarget: 2, distractorCount: 3, freeSelectFromText: false },
            2: { maxWords: 20, ellipsesMaxWords: 7, languageTier: "low", quoteTarget: 3, distractorCount: 3, freeSelectFromText: false },
            3: { maxWords: 30, ellipsesMaxWords: 7, languageTier: "low", quoteTarget: 4, distractorCount: 4, freeSelectFromText: false },
            4: { maxWords: 34, ellipsesMaxWords: 7, languageTier: "medium", quoteTarget: 4, distractorCount: 4, freeSelectFromText: false },
            5: { maxWords: 38, ellipsesMaxWords: 7, languageTier: "medium", quoteTarget: 5, distractorCount: 4, freeSelectFromText: false },
            6: { maxWords: 42, ellipsesMaxWords: 7, languageTier: "medium", quoteTarget: 5, distractorCount: 5, freeSelectFromText: false },
            7: { maxWords: 46, ellipsesMaxWords: 7, languageTier: "advanced", quoteTarget: 6, distractorCount: 5, freeSelectFromText: false },
            8: { maxWords: 50, ellipsesMaxWords: 7, languageTier: "advanced", quoteTarget: 6, distractorCount: 6, freeSelectFromText: false },
            9: { maxWords: 54, ellipsesMaxWords: 7, languageTier: "advanced", quoteTarget: 6, distractorCount: 6, freeSelectFromText: false }
        }
    },
    selection: {
        enabled: true,
        text: { source: "" },
        question: { prompt: "", focusTags: [] },
        items: [],
        modes: { selectionMode: "closed", showHints: true, requireReason: true, quoteCount: 4 }
    },
    globalStructure: {
        enabled: true,
        items: [
            { id: "g1", question: "How does the text shift?", correct: "Outside to Inside", distractors: ["Inside to Outside", "No shift"] }
        ]
    },
    banks: {
        markers: ["Furthermore,", "However,"],
        starters: ["The writer implies", "The text suggests"],
        methods: ["Metaphor", "Simile"],
        points: ["a sense of fear is created", "tension builds for the reader"],
        links: { l1: ["This shows"], l2: ["This reinforces"], l3: ["This highlights"] }
    },
    sentenceConfig: {
        1: ["starter", "quote", "link_l1", "point"],
        2: ["marker", "starter", "quote", "method", "point", "link_l2"],
        3: ["marker", "starter", "quote", "method", "point", "link_l3"]
    },
    items: [
        { id: "q1", original: "bruised purple", translation: "Dark color", translationDistractors: ["Bright"], type: "language", effect: "gloomy mood", effectDistractors: ["happy"], levels: [1,2,3], includeInWorksheet: true }
    ],
    isStandalone: false 
};

let appData = null;
let userState = { score: 0, level: 1, view: "", essay: "", completed: [], completedLevels: [], filter: "all", showDone: false, selectionCompleted: false, selectionStage: 1, selectionKey: "", selectionProgress: {}, selectionEliminated: [], labCompleted: false };
let currentBankKey = null;
let saveTimeout = null;

/* --- APP LOGIC --- */
const app = {
    normalizeKey: function(raw) {
        return String(raw || "lesson").toLowerCase().replace(/[^a-z0-9]+/g, "_").slice(0, 60);
    },
    quoteKey: function(text) {
        return String(text || "").toLowerCase().replace(/\s+/g, " ").trim();
    },
    quoteIsMostlySame: function(a, b) {
        if(!a || !b) return false;
        const toWords = (t) => String(t).toLowerCase().replace(/\s+/g, " ").trim().split(/\s+/).filter(Boolean);
        const wa = toWords(a);
        const wb = toWords(b);
        if(wa.length < 3 || wb.length < 3) return app.quoteKey(a) === app.quoteKey(b);
        const setB = new Set(wb);
        const overlap = wa.filter(w => setB.has(w)).length;
        const minLen = Math.min(wa.length, wb.length);
        return overlap >= minLen - 1;
    },
    quoteMatchesExisting: function(quoteText, existingItems) {
        const q = String(quoteText || "").trim();
        if(!q) return null;
        const items = Array.isArray(existingItems) ? existingItems : [];
        return items.find(i => i && app.quoteIsMostlySame(q, i.original));
    },
    getStateKeyForMeta: function(meta) {
        const id = app.normalizeKey(meta && meta.id ? meta.id : "");
        if(id) return `tsa_v5_1_state_${id}`;
        const title = app.normalizeKey(meta && meta.title ? meta.title : "lesson");
        const version = app.normalizeKey(meta && meta.version ? meta.version : "v1");
        return `tsa_v5_1_state_${title}_${version}`;
    },
    getStateKey: function() {
        return app.getStateKeyForMeta(appData && appData.meta ? appData.meta : {});
    },
    getAiDevices: function() {
        const s = appData && appData.settings ? appData.settings : {};
        return {
            tone: s.aiIncludeTone !== false,
            structure: s.aiIncludeStructure !== false,
            language: true
        };
    },
    getExportDevices: function() {
        const s = appData && appData.settings ? appData.settings : {};
        return {
            tone: s.aiIncludeTone !== false,
            structure: s.aiIncludeStructure !== false,
            language: true
        };
    },
    getDeviceOptions: function() {
        const labels = { tone: "Tone", language: "Language", structure: "Structure" };
        const devices = appData && appData.isStandalone ? app.getExportDevices() : { tone: true, structure: true, language: true };
        const options = Object.keys(labels).filter(k => devices[k]);
        const labelText = options.length ? options.map(k => labels[k]).join(" / ") : "Language";
        const listText = options.length <= 1
            ? (options[0] || "language")
            : `${options.slice(0, -1).join(", ")} or ${options[options.length - 1]}`;
        const evidenceText = options.includes("structure")
            ? (options.includes("language") ? "words or structure" : "structure")
            : "words";
        return { options, labels, labelText, listText, evidenceText };
    },
    getEffectiveLevel: function() {
        const practice = appData && appData.settings && appData.settings.practiceMode;
        const autoProgress = appData && appData.settings && appData.settings.autoProgress;
        if(practice && !autoProgress) return appData.settings.practiceModeLevel || 1;
        const lvl = parseInt(userState && userState.level ? userState.level : 1, 10);
        return isNaN(lvl) || lvl < 1 ? 1 : lvl;
    },
    getLevelBank: function() {
        const bank = appData && appData.settings && appData.settings.levelBank ? appData.settings.levelBank : null;
        return bank || defaultData.settings.levelBank;
    },
    getLanguageTier: function(level) {
        const lvl = parseInt(level, 10) || 1;
        const bank = app.getLevelBank();
        const entry = bank && bank[lvl] ? bank[lvl] : null;
        if(entry && entry.languageTier) return entry.languageTier;
        if(lvl <= 3) return "low";
        if(lvl <= 6) return "medium";
        return "advanced";
    },
    simplifyText: function(text, tier) {
        let t = String(text || "").trim();
        if(!t) return "";
        if(tier === "advanced") return t;
        const ukReplacements = {
            "color": "colour",
            "colors": "colours",
            "colored": "coloured",
            "honor": "honour",
            "honors": "honours",
            "organize": "organise",
            "organizes": "organises",
            "organized": "organised",
            "organizing": "organising",
            "analyze": "analyse",
            "analyzes": "analyses",
            "analyzed": "analysed",
            "analyzing": "analysing",
            "emphasize": "emphasise",
            "emphasizes": "emphasises",
            "emphasized": "emphasised",
            "summarize": "summarise",
            "summarizes": "summarises",
            "summarized": "summarised",
            "recognize": "recognise",
            "recognizes": "recognises",
            "recognized": "recognised",
            "characterize": "characterise",
            "characterizes": "characterises",
            "characterized": "characterised",
            "prioritize": "prioritise",
            "prioritizes": "prioritises",
            "prioritized": "prioritised",
            "humanizes": "humanises",
            "humanized": "humanised",
            "humanize": "humanise",
            "dehumanizes": "dehumanises",
            "dehumanized": "dehumanised",
            "dehumanize": "dehumanise"
        };
        Object.keys(ukReplacements).forEach(key => {
            const re = new RegExp(`\\b${key}\\b`, "gi");
            t = t.replace(re, ukReplacements[key]);
        });
        let firstSentence = t.split(/(?<=[.!?])\s+/)[0] || t;
        if(tier === "low") {
            const replacements = {
                "however": "but",
                "therefore": "so",
                "demonstrates": "shows",
                "illustrates": "shows",
                "suggests": "shows",
                "reveals": "shows",
                "conveys": "shows",
                "emphasises": "shows",
                "emphasizes": "shows",
                "highlights": "shows",
                "portrays": "shows",
                "dehumanises": "makes them seem less human",
                "dehumanizes": "makes them seem less human",
                "prisoners": "people",
                "justify": "make",
                "extreme": "very harsh",
                "measures": "actions"
            };
            Object.keys(replacements).forEach(key => {
                const re = new RegExp(`\\b${key}\\b`, "gi");
                firstSentence = firstSentence.replace(re, replacements[key]);
            });
        }
        const maxWords = tier === "low" ? 14 : 22;
        const words = firstSentence.split(/\s+/).filter(Boolean);
        if(words.length <= maxWords) return firstSentence;
        return words.slice(0, maxWords).join(" ") + "...";
    },
    getPracticeTemplate: function(level) {
        const templates = {
            1: ["starter", "quote", "link_l1", "point"],
            2: ["marker", "starter", "quote", "method", "point", "link_l2"],
            3: ["marker", "starter", "quote", "method", "point", "link_l3"]
        };
        return templates[level] || templates[1];
    },
    escapeHtml: function(text) {
        return String(text || "")
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
    },
    isLikelyJson: function(text) {
        const t = String(text || "").trim();
        if(!t) return false;
        if(!(t.startsWith("{") || t.startsWith("["))) return false;
        return /\"items\"|\"quote\"|\"sourceText\"|\"selection\"/i.test(t);
    },
    formatSourceHtml: function(text) {
        const clean = app.cleanSourceText(text || "");
        if(!clean) return "Source text not provided.";
        const parts = clean.split(/\n\s*\n/);
        return parts.map(p => `<p style="margin:0 0 16px 0;">${app.escapeHtml(p).replace(/\n/g, "<br>")}</p>`).join("");
    },
    repairSelection: function(s, opts) {
        const safe = s && typeof s === "object" ? s : {};
        const text = safe.text && typeof safe.text === "object" ? safe.text : {};
        const question = safe.question && typeof safe.question === "object" ? safe.question : {};
        const items = Array.isArray(safe.items) ? safe.items : [];
        const modes = safe.modes && typeof safe.modes === "object" ? safe.modes : {};
        const options = opts && typeof opts === "object" ? opts : {};
        const rawLevels = Array.isArray(options.activeLevels)
            ? options.activeLevels
            : (appData && appData.settings && Array.isArray(appData.settings.activeLevels)
                ? appData.settings.activeLevels
                : [1,2,3]);
        const activeLevels = rawLevels
            .map(n => parseInt(n, 10))
            .filter(n => n >= 1 && n <= 9);
        const levelFallback = activeLevels.length ? activeLevels : [1,2,3];
        const lessonItems = Array.isArray(options.lessonItems)
            ? options.lessonItems
            : (appData && Array.isArray(appData.items) ? appData.items : []);
        const lessonLevelMap = new Map();
        lessonItems.forEach(it => {
            const key = it && it.original ? app.quoteKey(it.original) : "";
            const levels = Array.isArray(it.levels)
                ? it.levels.map(n => parseInt(n, 10)).filter(n => n >= 1 && n <= 9)
                : [];
            if(key && levels.length) lessonLevelMap.set(key, levels);
        });
        const stageKeys = Array.isArray(modes.stages) && modes.stages.length
            ? modes.stages.filter(v => ["justify","discriminate","boundary","align"].includes(v))
            : ["discriminate","align","justify"];
        const rawStageConfig = safe.stageConfigByLevel && typeof safe.stageConfigByLevel === "object"
            ? safe.stageConfigByLevel
            : {};
        const stageConfigByLevel = {};
        levelFallback.forEach(lvl => {
            const cfg = rawStageConfig[lvl] && typeof rawStageConfig[lvl] === "object" ? rawStageConfig[lvl] : {};
            stageConfigByLevel[lvl] = {};
            stageKeys.forEach(key => {
                stageConfigByLevel[lvl][key] = cfg[key] === "free" ? "free" : "choice";
            });
        });
        const rawPrimary = app.cleanSourceText(text.source || "");
        const rawFallback = app.cleanSourceText(safe.sourceText || (appData && appData.sourceText) || "");
        const sourceText = (rawPrimary && rawFallback && rawPrimary.length < 80 && rawFallback.length > rawPrimary.length)
            ? rawFallback
            : (rawPrimary || rawFallback);
        const normalizeCorrect = (value, hasReasons, item) => {
            if(value === true) return true;
            if(value === false) return false;
            if(typeof value === "number") return value > 0;
            if(typeof value === "string") {
                const v = value.trim().toLowerCase();
                if(["true","yes","y","1","analysis","correct"].includes(v)) return true;
                if(["false","no","n","0","noise","incorrect","wrong"].includes(v)) return false;
            }
            if(typeof value === "undefined" || value === null) {
                const hasDeviceReason = item && typeof item.deviceReason === "string" && item.deviceReason.trim().length > 3;
                return !!(hasReasons || hasDeviceReason);
            }
            return !!value && !!hasReasons;
        };
        return {
            enabled: !!safe.enabled || items.length > 0,
            text: { source: sourceText },
            question: {
                prompt: typeof question.prompt === "string" ? question.prompt : (typeof safe.question === "string" ? safe.question : ""),
                focusTags: Array.isArray(question.focusTags) ? question.focusTags.filter(v => typeof v === "string") : []
            },
            structurePrompts: Array.isArray(safe.structurePrompts)
                ? safe.structurePrompts.map(v => String(v || "").trim()).filter(Boolean)
                : [
                    "Paragraphing (shift in topic, time, place, or perspective)",
                    "Time/Sequence (linear, flashback, jump forward)",
                    "Focus/Zoom (zoom in or out)",
                    "Introduction/Placement (start, middle, end positioning)",
                    "Repetition/Return (return to an idea or image)",
                    "Circular structure (ending mirrors the beginning)",
                    "Juxtaposition (contrasting ideas placed together)"
                ],
            items: items.map((it, idx) => {
                const item = it && typeof it === "object" ? it : {};
                const stripLabel = (q) => {
                    const raw = String(q || "");
                    return raw.replace(/^(start|end|beginning|conclusion|intro|opening|closing|final)\s*:\s*/i, "").trim();
                };
                const rawDistractors = Array.isArray(item.distractors) ? item.distractors : [];
                const reasons = Array.isArray(item.reasons)
                    ? item.reasons.filter(v => typeof v === "string" && v.trim()).map(v => v.trim())
                    : (typeof item.reason === "string" && item.reason.trim() ? [item.reason.trim()] : []);
                const distractors = rawDistractors.map((d, di) => {
                    if(typeof d === "string") {
                        return { id: `sd${idx+1}_${di+1}`, quote: stripLabel(d), reason: "" };
                    }
                    return {
                        id: typeof d.id === "string" ? d.id : `sd${idx+1}_${di+1}`,
                        quote: typeof d.quote === "string" ? stripLabel(d.quote) : "",
                        reason: typeof d.reason === "string" ? d.reason.trim() : ""
                    };
                });
                const cleanedDistractors = distractors
                    .filter(d => d.quote)
                    .map(d => ({ id: d.id, quote: d.quote, reason: d.reason || "" }));
                const rawLevels = Array.isArray(item.levels)
                    ? item.levels
                    : (typeof item.level === "number" || typeof item.level === "string")
                        ? [item.level]
                        : (typeof item.levels === "string" ? item.levels.split(",") : []);
                let levels = Array.isArray(rawLevels)
                    ? rawLevels.map(n => parseInt(n, 10)).filter(n => n >= 1 && n <= 9)
                    : [];
                if(!levels.length) {
                    const match = lessonLevelMap.get(app.quoteKey(item.quote));
                    if(match && match.length) levels = match.slice();
                }
                if(!levels.length) levels = [levelFallback[idx % levelFallback.length]];
                levels = Array.from(new Set(levels.map(n => parseInt(n, 10)).filter(n => n >= 1 && n <= 9)));
                // Quote selection items should belong to a single level.
                if(levels.length > 1) levels = [levels[0]];
                const device = (item.device === "tone" || item.device === "language" || item.device === "structure")
                    ? item.device
                    : "";
                const deviceReason = typeof item.deviceReason === "string" ? item.deviceReason.trim() : "";
                const cleanedQuote = stripLabel(item.quote);
                const inSource = app.quoteInSource(cleanedQuote, sourceText);
                const correct = normalizeCorrect(item.correct, reasons.length > 0, item);
                return {
                    id: typeof item.id === "string" ? item.id : `s${idx+1}`,
                    quote: typeof item.quote === "string" ? cleanedQuote : "",
                    correct: correct,
                    reasons: reasons,
                    distractors: cleanedDistractors,
                    levels: levels,
                    device: device,
                    deviceReason: deviceReason,
                    inSource: inSource
                };
            }).filter(i => i.quote),
            modes: {
                selectionMode: modes.selectionMode === "open" ? "open" : "closed",
                showHints: typeof modes.showHints === "boolean" ? modes.showHints : true,
                requireReason: typeof modes.requireReason === "boolean" ? modes.requireReason : true,
                quoteCount: Math.max(2, parseInt(modes.quoteCount, 10) || 4),
                stages: stageKeys
            },
            stageConfigByLevel: stageConfigByLevel
        };
    },
    cleanSourceText: function(text) {
        if(typeof text !== "string") return "";
        let t = text;
        if(app.isLikelyJson(t)) return "";
        t = t.replace(/<[^>]*>/g, " ");
        t = t.replace(/&nbsp;/gi, " ").replace(/&amp;/gi, "&").replace(/&lt;/gi, "<").replace(/&gt;/gi, ">");
        const cutoffIdx = (() => {
            const markers = ["Part A: Match", "Part B: Analysis", "Worksheet", "Match Meanings"];
            let idx = -1;
            markers.forEach(m => {
                const i = t.indexOf(m);
                if(i >= 0 && (idx === -1 || i < idx)) idx = i;
            });
            return idx;
        })();
        if(cutoffIdx > 0) t = t.slice(0, cutoffIdx);
        t = t.replace(/\s+\n/g, "\n").replace(/\n{3,}/g, "\n\n").replace(/[ \t]{2,}/g, " ");
        return t.trim();
    },
    getSourceText: function() {
        const saved = appData && typeof appData.sourceText === "string" ? appData.sourceText : "";
        const selText = appData && appData.selection && appData.selection.text && appData.selection.text.source
            ? appData.selection.text.source
            : "";
        const aiText = (document.getElementById("ai-input") || {}).value || "";
        const savedClean = app.cleanSourceText(saved);
        const selClean = app.cleanSourceText(selText);
        const aiClean = app.cleanSourceText(aiText);
        const defaultClean = app.cleanSourceText(defaultData && defaultData.sourceText ? defaultData.sourceText : "");
        const preferSelection = !savedClean || (defaultClean && savedClean === defaultClean);
        const primary = preferSelection ? selClean : savedClean;
        const secondary = preferSelection ? savedClean : selClean;
        const longer = (a, b) => (a && b) ? (a.length >= b.length ? a : b) : (a || b);
        const candidates = [
            longer(primary, secondary),
            longer(savedClean, selClean),
            aiClean
        ].filter(Boolean);
        app._sourceWarn = !!preferSelection && !appData.isStandalone;
        if(!candidates.length) return "";
        const text = candidates[0];
        if(appData && (!appData.sourceText || !appData.sourceText.trim()) && text) {
            appData.sourceText = text;
            app.save();
        }
        return text;
    },
    quoteInSource: function(quote, sourceText) {
        const q = String(quote || "").trim();
        const s = String(sourceText || "").trim();
        if(!q || !s) return false;
        const normalize = (str) => str
            .toLowerCase()
            .replace(/[‚Äú‚Äù‚Äò‚Äô"']/g, "")
            .replace(/[^a-z0-9\s]/g, " ")
            .replace(/\s+/g, " ")
            .trim();
        const nq = normalize(q);
        const ns = normalize(s);
        if(!nq || !ns) return false;
        return ns.includes(nq);
    },
    getDefaultSentenceConfig: function(level) {
        if(level === 1) return ["starter", "quote", "link_l1", "point"];
        if(level === 2) return ["marker", "starter", "quote", "method", "point", "link_l2"];
        if(level === 3) return ["marker", "starter", "quote", "method", "point", "link_l3"];
        if(level === 4) return ["marker", "starter", "quote", "method", "manual_point", "link_l3"];
        if(level === 5) return ["marker", "starter", "quote", "manual_method", "point", "link_l3"];
        if(level === 6) return ["marker", "manual_starter", "quote", "method", "point", "link_l3"];
        if(level === 7) return ["manual_marker", "starter", "quote", "method", "point", "link_l3"];
        if(level === 8) return ["marker", "starter", "quote", "method", "point", "manual_link"];
        if(level === 9) return ["marker", "starter", "quote", "method", "manual_analysis", "link_l3"];
        return ["marker", "starter", "quote", "method", "manual_effect", "link_l3"];
    },
    getActiveLevels: function() {
        const raw = appData && appData.settings && Array.isArray(appData.settings.activeLevels)
            ? appData.settings.activeLevels
            : [1,2,3];
        const cleaned = raw
            .map(n => parseInt(n, 10))
            .filter(n => n >= 1 && n <= 9);
        return cleaned.length ? Array.from(new Set(cleaned)).sort((a,b)=>a-b) : [1,2,3];
    },
    getSelectionKey: function() {
        const sel = appData && appData.selection ? appData.selection : null;
        if(!sel || !sel.items || !sel.items.length) return "";
        let level = app.getEffectiveLevel();
        const activeLevels = app.getActiveLevels();
        if(!activeLevels.includes(level)) {
            level = activeLevels[0] || 1;
            userState.level = level;
            app.save();
        }
        const base = `${sel.text && sel.text.source ? sel.text.source.slice(0,120) : ""}|${sel.question && sel.question.prompt ? sel.question.prompt : ""}|${sel.items.length}|lvl:${level}`;
        return base;
    },
    shuffle: function(arr) {
        const a = arr.slice();
        for(let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
    },
    makeBoundaryChoices: function(quote) {
        const words = app.wordList(quote);
        if(words.length <= 2) return { options: [quote], correct: quote, tooShort: true };
        if(words.length <= 6) {
            const short = words.slice(0, Math.max(2, words.length - 1)).join(" ");
            const options = app.shuffle([short, quote]).filter((v, i, a) => a.indexOf(v) === i);
            return { options, correct: quote, tooShort: options.length < 2 };
        }
        const short = app.truncateWithEllipses(words, Math.min(6, words.length));
        const medium = app.truncateWithEllipses(words, Math.min(12, words.length));
        const long = quote;
        const candidates = [short, medium, long];
        const options = app.shuffle(candidates.filter((v, i, a) => a.findIndex(x => String(x).trim() === String(v).trim()) === i));
        return { options: options.length ? options : [medium], correct: medium };
    },
    wordList: function(text) {
        return String(text || "").trim().split(/\s+/).filter(Boolean);
    },
    truncateWithEllipses: function(words, maxWords) {
        if(!Array.isArray(words) || words.length <= maxWords || maxWords <= 0) {
            return words.join(" ");
        }
        const total = words.length;
        const minKeep = Math.min(2, maxWords - 1);
        const targetHead = Math.max(minKeep, Math.ceil(maxWords / 2));
        const isBoundary = (w) => /[.!?;:]$/.test(w || "");

        let headCount = targetHead;
        for(let i = targetHead; i >= minKeep; i--) {
            if(isBoundary(words[i - 1])) { headCount = i; break; }
        }
        headCount = Math.min(headCount, maxWords - 1);

        let tailCount = maxWords - headCount;
        if(tailCount < 1) {
            tailCount = 1;
            headCount = maxWords - 1;
        }

        let tailStart = total - tailCount;
        const tailWindowStart = Math.max(headCount, total - tailCount - 4);
        for(let i = total - 2; i >= tailWindowStart; i--) {
            if(isBoundary(words[i])) {
                const candidateStart = i + 1;
                if(total - candidateStart <= tailCount) {
                    tailStart = candidateStart;
                    tailCount = total - tailStart;
                    break;
                }
            }
        }

        const head = words.slice(0, headCount);
        const tail = words.slice(tailStart);
        return `${head.join(" ")} ... ${tail.join(" ")}`;
    },
    applyLevelRules: function(items, levelBank, overrideLevel) {
        if(!Array.isArray(items) || !levelBank) return items;
        items.forEach(item => {
            if(!item.originalFull) item.originalFull = item.original;
            const lvl = overrideLevel || (Array.isArray(item.levels) && item.levels.length ? item.levels[0] : 1);
            const rule = levelBank[lvl];
            if(!rule) return;
            const maxWords = parseInt(rule.maxWords, 10) || 0;
            const ellipsesAt = parseInt(rule.ellipsesMaxWords, 10) || 0;
            const words = app.wordList(item.original);
            const total = words.length;
            if(total === 0) return;
            let out = words.join(" ");
            if(maxWords > 0 && total > maxWords) {
                out = app.truncateWithEllipses(words, maxWords);
            } else if(ellipsesAt > 0 && total > ellipsesAt) {
                // No truncation needed, but indicate omission for long quotes
                if(!/(\.\.\.|‚Ä¶)$/.test(out)) out += "...";
            }
            item.original = out;
        });
        return items;
    },
    init: function() {
        window.onerror = function() {
            if(app.isImportingPdf) return;
            document.getElementById('emergency-reset').style.display = 'block';
        };

        // CHECK FOR INJECTED STANDALONE DATA
        if (typeof window.STANDALONE_LESSON !== 'undefined') {
            appData = app.repair(window.STANDALONE_LESSON);
            appData.isStandalone = true;
            
            // CLEANUP: If by some miracle HTML remains, kill it
            const btn = document.getElementById('btn-admin'); if(btn) btn.remove();
            const mod = document.getElementById('modal-admin'); if(mod) mod.remove();
            document.querySelectorAll('.modal.open').forEach(m => m.classList.remove('open'));

        } else {
            // NORMAL TEACHER MODE
            const d = localStorage.getItem('tsa_v5_1_data');
            if(d) {
                try { appData = app.repair(JSON.parse(d)); } 
                catch(e) { appData = app.repair(defaultData); }
            } else if (typeof teacherConfig !== "undefined") {
                appData = app.repair(teacherConfig);
            } else {
                appData = app.repair(defaultData);
            }
        }

        if(appData.isStandalone && (!Array.isArray(appData.items) || appData.items.length === 0)) {
            const fallback = app.repair(defaultData);
            appData.items = fallback.items;
            appData.banks = fallback.banks;
            appData.sentenceConfig = fallback.sentenceConfig;
            appData.globalStructure = fallback.globalStructure;
            if(!appData.sourceText) appData.sourceText = fallback.sourceText;
            if(!appData.question) appData.question = fallback.question;
            if(!appData.meta || !appData.meta.title) appData.meta = fallback.meta;
        }
        if((!appData.sourceText || !appData.sourceText.trim()) && appData.selection && appData.selection.text && appData.selection.text.source) {
            appData.sourceText = app.cleanSourceText(appData.selection.text.source);
        }

        if(!appData.settings) appData.settings = {};
        admin.syncTemplatesFromStorage();

        const s = localStorage.getItem(app.getStateKey());
        if(s) {
            try { userState = JSON.parse(s); } catch(e) { userState = { score: 0, level: 1, view: "", essay: "", completed: [], completedLevels: [], filter: "all", showDone: false, selectionCompleted: false, selectionStage: 1, selectionKey: "", selectionProgress: {}, selectionEliminated: [], labCompleted: false }; }
        }
        if(typeof userState.selectionCompleted !== "boolean") userState.selectionCompleted = false;
        if(typeof userState.selectionStage !== "number") userState.selectionStage = 1;
        if(typeof userState.selectionKey !== "string") userState.selectionKey = "";
        if(!userState.selectionProgress || typeof userState.selectionProgress !== "object") userState.selectionProgress = {};
        if(!Array.isArray(userState.selectionEliminated)) userState.selectionEliminated = [];
        if(!Array.isArray(userState.selectionChosen)) userState.selectionChosen = [];
        if(!Array.isArray(userState.deskQueue)) userState.deskQueue = [];
        if(typeof userState.labCompleted !== "boolean") userState.labCompleted = false;
        if(typeof userState.view !== "string") userState.view = "";

        if(ui._sendToBuilderGuard) ui._sendToBuilderGuard = false;
        try { ui.init(); } catch(e) { document.getElementById('emergency-reset').style.display = 'block'; }
        document.body.classList.add("tsa-init-done");
    },
    isImportingPdf: false,

    repair: function(d) {
        if(!d || typeof d !== 'object') return JSON.parse(JSON.stringify(defaultData));

        const safe = d;
        safe.meta = safe.meta && typeof safe.meta === 'object' ? safe.meta : {};
        safe.meta.title = typeof safe.meta.title === 'string' ? safe.meta.title : defaultData.meta.title;
        safe.meta.author = typeof safe.meta.author === 'string' ? safe.meta.author : defaultData.meta.author;
        safe.meta.version = typeof safe.meta.version === 'string' ? safe.meta.version : defaultData.meta.version;
        safe.sourceText = app.cleanSourceText(typeof safe.sourceText === 'string' ? safe.sourceText : defaultData.sourceText);
        safe.question = typeof safe.question === 'string' ? safe.question : defaultData.question;

        safe.settings = safe.settings && typeof safe.settings === 'object' ? safe.settings : {};
        if(typeof safe.settings.autoProgress !== 'boolean') safe.settings.autoProgress = false;
        if(typeof safe.settings.practiceMode !== 'boolean') safe.settings.practiceMode = false;
        safe.settings.practiceModeLevel = [1,2,3,4,5,6,7,8,9].includes(parseInt(safe.settings.practiceModeLevel, 10))
            ? parseInt(safe.settings.practiceModeLevel, 10)
            : 1;
        if(typeof safe.settings.practiceForceAuto !== 'boolean') safe.settings.practiceForceAuto = false;
        if(typeof safe.settings.practiceFixedTemplate !== 'boolean') safe.settings.practiceFixedTemplate = false;
        safe.settings.worksheetMatchMode = ["aligned","jumbled","list"].includes(safe.settings.worksheetMatchMode)
            ? safe.settings.worksheetMatchMode
            : "jumbled";
        safe.settings.templates = Array.isArray(safe.settings.templates) ? safe.settings.templates : [];
        safe.settings.activeLevels = Array.isArray(safe.settings.activeLevels)
            ? safe.settings.activeLevels.map(n => parseInt(n, 10)).filter(n => n >= 1 && n <= 9)
            : [1,2,3];
        if(!safe.settings.activeLevels.length) safe.settings.activeLevels = [1,2,3];
        if(typeof safe.settings.aiPromptAllLevels !== 'boolean') safe.settings.aiPromptAllLevels = false;
        if(typeof safe.settings.aiIncludeTone !== 'boolean') safe.settings.aiIncludeTone = true;
        if(typeof safe.settings.aiIncludeStructure !== 'boolean') safe.settings.aiIncludeStructure = true;
        if(typeof safe.settings.exportIncludeTone !== 'boolean') safe.settings.exportIncludeTone = true;
        if(typeof safe.settings.exportIncludeStructure !== 'boolean') safe.settings.exportIncludeStructure = true;
        if(!safe.settings.selectionDevices || typeof safe.settings.selectionDevices !== "object") {
            safe.settings.selectionDevices = {
                language: true,
                tone: safe.settings.aiIncludeTone !== false,
                structure: safe.settings.aiIncludeStructure !== false
            };
        }
        if(typeof safe.settings.rewardUrl !== "string") safe.settings.rewardUrl = "";
        safe.settings.rewardMinutes = parseInt(safe.settings.rewardMinutes, 10);
        if(isNaN(safe.settings.rewardMinutes) || safe.settings.rewardMinutes < 0) safe.settings.rewardMinutes = 0;
        safe.settings.rewardEveryLevels = parseInt(safe.settings.rewardEveryLevels, 10);
        if(isNaN(safe.settings.rewardEveryLevels) || safe.settings.rewardEveryLevels < 0) safe.settings.rewardEveryLevels = 0;
        if(typeof safe.settings.rewardAtEnd !== "boolean") safe.settings.rewardAtEnd = false;
        if(typeof safe.settings.allowPartialSelection !== "boolean") safe.settings.allowPartialSelection = false;
        if(typeof safe.settings.strictMode !== 'boolean') safe.settings.strictMode = false;
        safe.settings.selectionStages = Array.isArray(safe.settings.selectionStages) && safe.settings.selectionStages.length
            ? safe.settings.selectionStages.filter(v => ["discriminate","boundary","align","justify"].includes(v))
            : ["discriminate","align","justify"];
        safe.settings.modulesActive = safe.settings.modulesActive && typeof safe.settings.modulesActive === "object"
            ? safe.settings.modulesActive
            : { selection: true, lab: true, desk: true };
        if(typeof safe.settings.modulesActive.selection !== "boolean") safe.settings.modulesActive.selection = true;
        if(typeof safe.settings.modulesActive.lab !== "boolean") safe.settings.modulesActive.lab = true;
        if(typeof safe.settings.modulesActive.desk !== "boolean") safe.settings.modulesActive.desk = true;
        if(typeof safe.settings.startView !== "string") safe.settings.startView = "lab";
        safe.settings.levelRules = safe.settings.levelRules && typeof safe.settings.levelRules === 'object'
            ? safe.settings.levelRules
            : JSON.parse(JSON.stringify(defaultData.settings.levelRules));
        for(let lvl = 1; lvl <= 9; lvl++) {
            const r = safe.settings.levelRules[lvl] || {};
            safe.settings.levelRules[lvl] = {
                maxWords: parseInt(r.maxWords, 10) || (defaultData.settings.levelRules[lvl] ? defaultData.settings.levelRules[lvl].maxWords : defaultData.settings.levelRules[3].maxWords),
                ellipsesMaxWords: parseInt(r.ellipsesMaxWords, 10) || (defaultData.settings.levelRules[lvl] ? defaultData.settings.levelRules[lvl].ellipsesMaxWords : defaultData.settings.levelRules[3].ellipsesMaxWords)
            };
        }
        safe.settings.levelBank = safe.settings.levelBank && typeof safe.settings.levelBank === "object"
            ? safe.settings.levelBank
            : {};
        for(let lvl = 1; lvl <= 9; lvl++) {
            const r = safe.settings.levelBank[lvl] || {};
            const fallbackMax = defaultData.settings.levelBank[lvl] ? defaultData.settings.levelBank[lvl].maxWords : (lvl > 3 ? 30 + (lvl - 3) * 4 : (lvl === 1 ? 12 : lvl === 2 ? 20 : 30));
            const fallbackEllipses = defaultData.settings.levelBank[lvl] ? defaultData.settings.levelBank[lvl].ellipsesMaxWords : 7;
            const fallbackTier = defaultData.settings.levelBank[lvl] ? defaultData.settings.levelBank[lvl].languageTier : (lvl <= 3 ? "low" : lvl <= 6 ? "medium" : "advanced");
            const fallbackQuoteTarget = defaultData.settings.levelBank[lvl] ? defaultData.settings.levelBank[lvl].quoteTarget : 4;
            const fallbackDistractors = defaultData.settings.levelBank[lvl] ? defaultData.settings.levelBank[lvl].distractorCount : 4;
            safe.settings.levelBank[lvl] = {
                maxWords: parseInt(r.maxWords, 10) || safe.settings.levelRules[lvl].maxWords || fallbackMax,
                ellipsesMaxWords: parseInt(r.ellipsesMaxWords, 10) || safe.settings.levelRules[lvl].ellipsesMaxWords || fallbackEllipses,
                languageTier: (r.languageTier === "low" || r.languageTier === "medium" || r.languageTier === "advanced") ? r.languageTier : fallbackTier,
                quoteTarget: parseInt(r.quoteTarget, 10) || fallbackQuoteTarget,
                distractorCount: parseInt(r.distractorCount, 10) || fallbackDistractors,
                freeSelectFromText: r.freeSelectFromText === true
            };
        }

        safe.globalStructure = safe.globalStructure && typeof safe.globalStructure === 'object' ? safe.globalStructure : { enabled: true, items: [] };
        safe.globalStructure.enabled = true;
        if(safe.globalStructure.question && !safe.globalStructure.items) { 
            safe.globalStructure.items = [{ id:"g_old", question: safe.globalStructure.question, correct: safe.globalStructure.correct, distractors: safe.globalStructure.distractors }];
        }
        if(!Array.isArray(safe.globalStructure.items)) safe.globalStructure.items = [];
        safe.globalStructure.items = safe.globalStructure.items.map((q, idx) => {
            const item = q && typeof q === 'object' ? q : {};
            return {
                id: typeof item.id === 'string' ? item.id : `g${idx + 1}`,
                question: typeof item.question === 'string' ? item.question : 'New Question?',
                correct: typeof item.correct === 'string' ? item.correct : 'Answer',
                distractors: Array.isArray(item.distractors) ? item.distractors.filter(v => typeof v === 'string') : []
            };
        });

        safe.banks = safe.banks && typeof safe.banks === 'object' ? safe.banks : {};
        const altBanks = safe.sentenceBanks && typeof safe.sentenceBanks === 'object' ? safe.sentenceBanks : {};
        const bankMarkers = Array.isArray(safe.bankMarkers) ? safe.bankMarkers : Array.isArray(altBanks.markers) ? altBanks.markers : [];
        const bankStarters = Array.isArray(safe.bankStarters) ? safe.bankStarters : Array.isArray(altBanks.starters) ? altBanks.starters : [];
        const bankMethods = Array.isArray(safe.bankMethods) ? safe.bankMethods : Array.isArray(altBanks.methods) ? altBanks.methods : [];
        const bankPoints = Array.isArray(safe.bankPoints) ? safe.bankPoints : Array.isArray(altBanks.points) ? altBanks.points : [];
        safe.banks.markers = Array.isArray(safe.banks.markers) ? safe.banks.markers.filter(v => typeof v === 'string') : bankMarkers.filter(v => typeof v === 'string');
        safe.banks.starters = Array.isArray(safe.banks.starters) ? safe.banks.starters.filter(v => typeof v === 'string') : bankStarters.filter(v => typeof v === 'string');
        safe.banks.methods = Array.isArray(safe.banks.methods) ? safe.banks.methods.filter(v => typeof v === 'string') : bankMethods.filter(v => typeof v === 'string');
        safe.banks.points = Array.isArray(safe.banks.points) ? safe.banks.points.filter(v => typeof v === 'string') : bankPoints.filter(v => typeof v === 'string');
        safe.banks.links = safe.banks.links && typeof safe.banks.links === 'object' ? safe.banks.links : {};
        for(let lvl = 1; lvl <= 9; lvl++) {
            const key = `l${lvl}`;
            if(Array.isArray(safe.banks.links[key])) {
                safe.banks.links[key] = safe.banks.links[key].filter(v => typeof v === 'string');
            } else if(lvl >= 4 && Array.isArray(safe.banks.links.l3)) {
                safe.banks.links[key] = JSON.parse(JSON.stringify(safe.banks.links.l3));
            } else {
                safe.banks.links[key] = [];
            }
        }
        if(!safe.banks.markers.length) safe.banks.markers = JSON.parse(JSON.stringify(defaultData.banks.markers));
        if(!safe.banks.starters.length) safe.banks.starters = JSON.parse(JSON.stringify(defaultData.banks.starters));
        if(!safe.banks.methods.length) safe.banks.methods = JSON.parse(JSON.stringify(defaultData.banks.methods));
        if(!safe.banks.points.length) safe.banks.points = JSON.parse(JSON.stringify(defaultData.banks.points));
        if(!safe.banks.links || !Object.keys(safe.banks.links).length) {
            safe.banks.links = JSON.parse(JSON.stringify(defaultData.banks.links));
        }

        safe.sentenceConfig = safe.sentenceConfig && typeof safe.sentenceConfig === 'object' ? safe.sentenceConfig : JSON.parse(JSON.stringify(defaultData.sentenceConfig));
        for(let lvl = 1; lvl <= 9; lvl++) {
            const fallback = app.getDefaultSentenceConfig(lvl);
            if(!Array.isArray(safe.sentenceConfig[lvl])) safe.sentenceConfig[lvl] = JSON.parse(JSON.stringify(fallback));
        }

        if(!Array.isArray(safe.items)) safe.items = [];
        const activeLevelsRepair = Array.isArray(safe.settings.activeLevels) && safe.settings.activeLevels.length
            ? safe.settings.activeLevels.map(n => parseInt(n, 10)).filter(n => n >= 1 && n <= 9)
            : [1, 2, 3];
        const firstActiveLevel = activeLevelsRepair[0] || 1;
        safe.items = safe.items.map((i, idx) => {
            const item = i && typeof i === 'object' ? i : {};
            const stripLabel = (q) => {
                const raw = String(q || "");
                return raw.replace(/^(start|end|beginning|conclusion|intro|opening|closing|final)\s*:\s*/i, "").trim();
            };
            const rawLevels = Array.isArray(item.levels)
                ? item.levels
                : (typeof item.level === 'number' || typeof item.level === 'string')
                    ? [item.level]
                    : (typeof item.levels === 'string' ? item.levels.split(',') : []);
            let levels = Array.isArray(rawLevels)
                ? rawLevels.map(n => parseInt(n, 10)).filter(n => n >= 1 && n <= 9)
                : [];
            if(!levels.length) levels = [firstActiveLevel];
            else {
                const inActive = levels.filter(l => activeLevelsRepair.includes(l));
                levels = inActive.length ? [inActive[0]] : [firstActiveLevel];
            }
            const original = typeof item.original === 'string' ? item.original
                : (typeof item.quote === 'string' ? item.quote
                : (typeof item.evidence === 'string' ? item.evidence
                : (typeof item.text === 'string' ? item.text : 'New Quote')));
            const translation = typeof item.translation === 'string' ? item.translation
                : (typeof item.meaning === 'string' ? item.meaning
                : (typeof item.simpleMeaning === 'string' ? item.simpleMeaning : 'Meaning'));
            const translationDistractors = Array.isArray(item.translationDistractors)
                ? item.translationDistractors
                : (Array.isArray(item.wrongMeanings) ? item.wrongMeanings
                : (Array.isArray(item.translation_distractors) ? item.translation_distractors : []));
            const effect = typeof item.effect === 'string' ? item.effect
                : (typeof item.analysis === 'string' ? item.analysis
                : (typeof item.interpretation === 'string' ? item.interpretation : ''));
            const effectDistractors = Array.isArray(item.effectDistractors)
                ? item.effectDistractors
                : (Array.isArray(item.wrongAnalyses) ? item.wrongAnalyses
                : (Array.isArray(item.effect_distractors) ? item.effect_distractors : []));
            const type = ['tone','structure','language'].includes(item.type)
                ? item.type
                : (['tone','structure','language'].includes(item.category) ? item.category : 'tone');
            return {
                id: typeof item.id === 'string' ? item.id : `q${idx + 1}`,
                original: stripLabel(original),
                translation: translation,
                translationDistractors: translationDistractors.filter(v => typeof v === 'string'),
                type: type,
                effect: effect,
                effectDistractors: effectDistractors.filter(v => typeof v === 'string'),
                levels: levels,
                includeInWorksheet: typeof item.includeInWorksheet === 'boolean' ? item.includeInWorksheet : true
            };
        });

        if(safe.settings && safe.settings.levelBank) {
            if(safe.settings.practiceMode) {
                app.applyLevelRules(safe.items, safe.settings.levelBank, safe.settings.practiceModeLevel);
            } else {
                app.applyLevelRules(safe.items, safe.settings.levelBank);
            }
        }
        if(typeof safe.settings.quoteTarget !== "number" || !safe.settings.quoteTarget) {
            safe.settings.quoteTarget = Array.isArray(safe.items) ? safe.items.length : defaultData.settings.quoteTarget;
        }

        safe.selection = app.repairSelection(safe.selection, { activeLevels: safe.settings.activeLevels, lessonItems: safe.items });
        if(safe.settings.modulesActive && safe.settings.modulesActive.selection) safe.selection.enabled = true;
        return safe;
    },

    save: function() {
        if(!appData.isStandalone) {
            localStorage.setItem('tsa_v5_1_data', JSON.stringify(appData));
        }
        localStorage.setItem(app.getStateKey(), JSON.stringify(userState));
        document.getElementById('save-status').style.opacity = 1;
        setTimeout(()=>document.getElementById('save-status').style.opacity=0, 800);
        ui.renderLab();
    },

    updateEssay: function(text) {
        userState.essay = text;
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => { app.save(); }, 1000);
    },

    resetSession: function() {
        if(confirm("Reset progress?")) {
            userState = { score: 0, level: 1, view: "", essay: "", completed: [], completedLevels: [], filter: "all", showDone: false, selectionCompleted: false, selectionStage: 1, selectionKey: "", selectionProgress: {}, selectionEliminated: [], labCompleted: false };
            app.save(); location.reload();
        }
    },

    factoryReset: function() {
        if(confirm("Delete ALL data?")) { localStorage.clear(); location.reload(); }
    },

    setLevel: function(l) {
        const target = parseInt(l, 10);
        const levels = app.getActiveLevels();
        userState.level = levels.includes(target) ? target : levels[0];
        if(!(appData.settings && appData.settings.practiceMode && appData.settings.autoProgress)) {
            userState.showDone = false;
        }
        if(appData.selection && appData.selection.enabled) {
            userState.selectionCompleted = false;
            userState.selectionStage = 1;
            userState.selectionProgress = {};
            userState.selectionChosen = [];
            userState.selectionKey = app.getSelectionKey();
            ui._selectionCorrectItem = null;
            ui._selectionQuote = null;
            ui._freeSelectPendingQuote = "";
        }
        app.save();
        const levelBadge = document.getElementById("level-display");
        if(levelBadge) levelBadge.innerText = "Lvl " + userState.level;
        const levelSelectEl = document.getElementById("level-selector");
        if(levelSelectEl) levelSelectEl.value = String(userState.level);
        document.getElementById("sentence-builder").innerHTML = '<div style="text-align:center; opacity:0.6; padding:20px;">Level Changed. Select quote.</div>';
        if(userState.view === "select") ui.renderSelection();
    },

    setFilter: function(f) { userState.filter = f; ui.renderLab(); },
    toggleDone: function() { userState.showDone = !userState.showDone; document.getElementById('btn-show-done').classList.toggle('active', userState.showDone); ui.renderLab(); },

    selectQuote: function(id) {
        const item = appData.items.find(i=>i.id===id);
        if(item) ui.startWizard(item);
    },

    commitSentence: function() {
        const txt = document.getElementById("preview-box").innerText.trim();
        if(!txt) return alert("Empty sentence.");
        const wrong = ui.getIncorrectSelections();
        if(wrong.length && appData.settings && appData.settings.strictMode) {
            alert("Some choices may not fit the quote. Try again.");
            return;
        }
        
        document.getElementById("essay-area").value += (document.getElementById("essay-area").value ? "\n\n" : "") + txt;
        userState.essay = document.getElementById("essay-area").value;

        if(ui.activeQuoteId && !userState.completed.includes(ui.activeQuoteId)) {
            userState.completed.push(ui.activeQuoteId);
        }
        if(appData.settings && appData.settings.autoProgress) {
            userState.showDone = false;
        }
        if(Array.isArray(userState.deskQueue) && ui.activeQuoteId) {
            const active = appData.items.find(i => i.id === ui.activeQuoteId);
            if(active && active.original && userState.deskQueue.length) {
                const idx = userState.deskQueue.findIndex(q => q === active.original);
                if(idx >= 0) {
                    userState.deskQueue.splice(idx, 1);
                } else {
                    userState.deskQueue.shift();
                }
            }
        }
        
        app.save();
        app.checkLevelCompletion();
        if(Array.isArray(userState.deskQueue) && userState.deskQueue.length) {
            const nextItem = ui.ensureQuoteItem(userState.deskQueue[0]);
            if(nextItem) {
                ui.switchView('desk');
                ui.runBuilder(nextItem);
                return;
            }
        }
        const modules = appData.settings && appData.settings.modulesActive ? appData.settings.modulesActive : { selection: true, lab: true, desk: true };
        const activeLevels = app.getActiveLevels();
        const maxLevel = activeLevels.length ? Math.max(...activeLevels) : 1;
        if(userState.level < maxLevel) {
            app.setLevel(userState.level + 1);
            if(modules.selection) {
                ui.switchView('select');
                ui.renderSelection();
            } else if(modules.lab) {
                ui.switchView('lab');
                ui.renderLab();
            } else {
                ui.switchView('desk');
                ui.renderDeskQuoteTabs();
            }
            return;
        }
        if(modules.selection && !userState.selectionCompleted) {
            ui.switchView('select');
            ui.renderSelection();
        } else if(modules.lab) {
            ui.switchView('lab');
            ui.renderLab();
        } else {
            ui.switchView('desk');
            ui.renderDeskQuoteTabs();
        }
    },

    checkLevelCompletion: function() {
        const practiceMode = appData.settings && appData.settings.practiceMode;
        const autoProgress = appData.settings && appData.settings.autoProgress;
        if(practiceMode && !autoProgress) return;
        const levelItems = appData.items
            .filter(i => i.levels.includes(userState.level))
            .filter(i => {
                if(!ui._seenQuoteKeys) ui._seenQuoteKeys = new Set();
                const key = `${i.original}|${i.translation}|${i.type}|${i.effect}`;
                if(ui._seenQuoteKeys.has(key)) return false;
                ui._seenQuoteKeys.add(key);
                return true;
            });
        if(levelItems.length === 0) return;

        const allDone = levelItems.every(i => userState.completed.includes(i.id));
        let meetsTarget = false;
        if(autoProgress) {
            const bank = app.getLevelBank();
            const entry = bank && bank[userState.level] ? bank[userState.level] : {};
            const target = parseInt(entry.quoteTarget, 10) || parseInt(appData.settings.quoteTarget, 10) || 0;
            if(target > 0) {
                const completedInLevel = levelItems.filter(i => userState.completed.includes(i.id)).length;
                meetsTarget = completedInLevel >= target;
            }
        }

        if(allDone || meetsTarget) {
            if(!userState.completedLevels.includes(userState.level)) {
                userState.completedLevels.push(userState.level);
            }
            const levels = app.getActiveLevels();
            const maxLevel = Math.max(...levels);
            if(userState.level < maxLevel) {
                ui.showCelebration(appData.settings && appData.settings.autoProgress);
            } else {
                ui.showCelebration(false, true); 
            }
            app.save();
        }
    },

    undo: function() {
        let v = document.getElementById("essay-area").value;
        let p = v.split("\n\n"); p.pop();
        let newVal = p.join("\n\n");
        document.getElementById("essay-area").value = newVal;
        userState.essay = newVal;
        app.save();
    },

    clearEssay: function() { 
        if(confirm("Clear essay?")) { 
            document.getElementById("essay-area").value = ""; 
            userState.essay = "";
            app.save(); 
        } 
    },

    restartCourse: function() {
        if(confirm("Play again from Level 1?")) {
            userState = { score: 0, level: 1, view: "", essay: "", completed: [], completedLevels: [], filter: "all", showDone: false, selectionCompleted: false, selectionStage: 1, selectionKey: "", selectionProgress: {}, selectionEliminated: [], labCompleted: false };
            app.save(); location.reload();
        }
    },
    
    exportDoc: function() {
        const text = document.getElementById("essay-area").value || "";
        const title = appData && appData.meta && appData.meta.title ? appData.meta.title : "";
        const question = (appData.selection && appData.selection.question && appData.selection.question.prompt)
            ? appData.selection.question.prompt
            : (appData && appData.question ? appData.question : "");
        const headerHtml = title
            ? `<h1 style="margin:0 0 10px 0; font-size:1.2em;">${app.escapeHtml(title)}</h1>${question ? `<p style="margin:0 0 12px 0; font-weight:bold;"><strong>Question:</strong> ${app.escapeHtml(question)}</p>` : ""}`
            : "";
        const html = `<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
        <head><meta charset='utf-8'><title>Answer</title>
        <style>body{font-family:'Aptos','Calibri',sans-serif;} p{margin:0 0 10px 0;}</style>
        </head><body>${headerHtml}<p>${text.replace(/\n/g, '</p><p>')}</p></body></html>`;
        const b = new Blob(['\ufeff'+html], {type:'application/msword'});
        const a = document.createElement("a"); a.href=URL.createObjectURL(b); a.download="Answer.doc"; a.click();
    },

    playSound: function(type) {
        if(window.AudioContext) {
            const ctx = new window.AudioContext();
            const now = ctx.currentTime;
            
            if (type === 'celebrate') {
                [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain); gain.connect(ctx.destination);
                    osc.frequency.value = freq;
                    osc.type = 'triangle';
                    const start = now + (i * 0.15);
                    const dur = i === 3 ? 0.8 : 0.1; 
                    gain.gain.setValueAtTime(0.1, start);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + dur);
                    osc.start(start);
                    osc.stop(start + dur);
                });
            } else if (type === 'final') {
                [392.00, 523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain); gain.connect(ctx.destination);
                    osc.frequency.value = freq;
                    osc.type = 'sine';
                    const start = now + (i * 0.18);
                    const dur = i === 4 ? 0.9 : 0.12; 
                    gain.gain.setValueAtTime(0.12, start);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + dur);
                    osc.start(start);
                    osc.stop(start + dur);
                });
            } else {
                const osc = ctx.createOscillator();
                const g = ctx.createGain();
                osc.connect(g); g.connect(ctx.destination);
                osc.frequency.value = 600;
                g.gain.value = 0.1;
                osc.start(); osc.stop(now + 0.1);
            }
        }
    }
};

/* --- UI --- */
const ui = {
    activeQuoteId: null,
    _readerTimer: null,
    _stopWords: new Set(["the","a","an","and","or","but","to","of","in","on","for","with","is","are","was","were","be","been","being","how","does","do","did","what","why","where","when","which","who","whom","this","that","these","those","it","its","as","at","by","from","about"]),
    getStageLabel: function(key) {
        const map = {
            discriminate: "Choose best quote",
            align: app.getDeviceOptions().labelText,
            justify: "Justify",
            boundary: "Length"
        };
        return map[key] || key;
    },

    _initInProgress: false,
    init: function() {
        ui._initInProgress = true;
        if(userState.view === "select") {
            const mods = appData.settings && appData.settings.modulesActive ? appData.settings.modulesActive : { desk: true, lab: true };
            userState.view = mods.desk ? "desk" : (mods.lab ? "lab" : "desk");
        }
        if(!ui._textGuardBound) {
            ui._textGuardBound = true;
            const isEditable = (el) => {
                if(!el) return false;
                if(el.closest && el.closest("[contenteditable='true']")) return true;
                const tag = (el.tagName || "").toLowerCase();
                return tag === "input" || tag === "textarea";
            };
            document.addEventListener("mousedown", (e) => {
                ui._textSelecting = isEditable(e.target);
            }, true);
            document.addEventListener("mouseup", () => {
                setTimeout(() => { ui._textSelecting = false; }, 80);
            }, true);
        }
        const aiInputEl = document.getElementById("ai-input");
        const selectionText = appData.selection && appData.selection.text && appData.selection.text.source
            ? appData.selection.text.source
            : "";
        const fallbackText = aiInputEl && aiInputEl.value && aiInputEl.value.trim()
            ? aiInputEl.value.trim()
            : "";
        const rawSource = (appData.sourceText && appData.sourceText.trim())
            ? appData.sourceText
            : (selectionText || fallbackText);
        const sourceText = app.cleanSourceText(rawSource);
        if((!appData.sourceText || !appData.sourceText.trim()) && sourceText) {
            appData.sourceText = sourceText;
            app.save();
        }
        const title = appData.meta && appData.meta.title ? appData.meta.title : "";
        document.getElementById("lbl-title").innerText = title;
        const lblSelect = document.getElementById("lbl-title-select");
        if(lblSelect) lblSelect.innerText = title;
        const lblDesk = document.getElementById("lbl-title-desk");
        if(lblDesk) lblDesk.innerText = title;
        const essayTopic = document.getElementById("essay-topic-banner");
        if(essayTopic) {
            if(title) {
                essayTopic.classList.remove("hidden");
                essayTopic.innerHTML = `<strong>Topic:</strong> ${app.escapeHtml(title)}`;
            } else {
                essayTopic.classList.add("hidden");
                essayTopic.innerHTML = "";
            }
        }
        document.getElementById("source-content").innerHTML = app.formatSourceHtml(sourceText);
        const levelSelect = document.getElementById("level-selector");
        if(levelSelect) {
            const levels = app.getActiveLevels();
            levelSelect.innerHTML = levels.map(n => `<option value="${n}">Lvl ${n}</option>`).join("");
        }
        const inline = document.getElementById("source-inline");
        if(inline) {
            inline.innerHTML = app.formatSourceHtml(sourceText);
        }
        const introText = document.getElementById("intro-text");
        if(introText) {
            introText.innerHTML = app.formatSourceHtml(sourceText);
        }
        ui.renderQuestionBanner();
        ui.initReaderControls();
        document.getElementById("score-display").innerText = userState.score + " XP";
        const levelBadge = document.getElementById("level-display");
        if(levelBadge) levelBadge.innerText = "Lvl " + userState.level;
        document.getElementById("essay-area").value = userState.essay;
        const activeLevels = app.getActiveLevels();
        if(!activeLevels.includes(userState.level)) userState.level = activeLevels[0];
        if(levelSelect) levelSelect.value = userState.level;
        const modules = appData.settings && appData.settings.modulesActive
            ? appData.settings.modulesActive
            : { selection: true, lab: true, desk: true };
        const bank = app.getLevelBank();
        const anyFreeSelect = bank && Object.keys(bank).some(function(lvl) { return bank[lvl] && bank[lvl].freeSelectFromText === true; });
        if(modules.selection && appData.selection && !appData.selection.enabled) {
            appData.selection.enabled = true;
            app.save();
        }
        const selectionAvailable = modules.selection && appData.selection && (appData.selection.items.length > 0 || anyFreeSelect) && (appData.selection.enabled || anyFreeSelect);
        const pref = appData.settings && appData.settings.startView ? appData.settings.startView : "";
        const resolveStartView = () => {
            if(selectionAvailable) return "select";
            if(pref === "desk" && modules.desk) return "desk";
            if(pref === "lab" && modules.lab) return "lab";
            if(modules.lab) return "lab";
            return modules.desk ? "desk" : "lab";
        };
        if(pref) {
            userState.view = resolveStartView();
        } else if(!userState.view) {
            userState.view = resolveStartView();
        }
        ui.loadTheme();

        if(appData.settings && appData.settings.practiceMode && !(appData.settings && appData.settings.autoProgress)) {
            const lvl = appData.settings.practiceModeLevel || 1;
            userState.level = lvl;
            userState.showDone = true;
            const sel = document.getElementById("level-selector");
            if(sel) { sel.value = lvl; sel.disabled = true; sel.title = "Practice mode locks the selected level"; }
        }
        ui.renderLab();

        document.querySelectorAll(".modal").forEach(modal => {
            if(modal.dataset.backdropBound) return;
            modal.dataset.backdropBound = "true";
            modal.addEventListener("click", (e) => {
                if(e.target === modal && modal.id !== "modal-admin") ui.closeModal(modal.id);
            });
        });
        
        ui.showSplash();
        
        // Only sync admin UI if we are in Teacher Mode AND the element exists
        // This is the check that prevents freezing!
        if(!appData.isStandalone && document.getElementById('modal-admin')) {
            admin.syncUI();
        }

        const modulesActive = modules;
        const selectNav = document.getElementById("nav-select");
        if(selectNav) selectNav.classList.toggle("hidden", !modulesActive.selection);
        const selectionEnabled = selectionAvailable;
        if(selectionEnabled) {
            const key = app.getSelectionKey();
            if(key && userState.selectionKey !== key) {
                userState.selectionCompleted = false;
                userState.selectionStage = 1;
                userState.selectionKey = key;
                userState.selectionProgress = {};
                userState.selectionEliminated = [];
                userState.selectionChosen = [];
                ui._selectionCorrectItem = null;
                ui._selectionQuote = null;
                userState.labCompleted = false;
                app.save();
            }
        }
        const level = userState.level || 1;
        const entry = bank && bank[level] ? bank[level] : {};
        const targetCount = Math.max(1, parseInt(entry.quoteTarget, 10) || 2);
        const chosen = Array.isArray(userState.selectionChosen) ? userState.selectionChosen : [];
        const uniqueChosenCount = new Set(chosen.map(q => app.quoteKey(q))).size;
        const deskQueueLen = Array.isArray(userState.deskQueue) ? userState.deskQueue.length : 0;
        const targetAlreadyMet = uniqueChosenCount >= targetCount || deskQueueLen >= targetCount || deskQueueLen > 0;
        if(targetAlreadyMet) {
            userState.view = (modules.desk ? "desk" : modules.lab ? "lab" : "desk");
            if(!Array.isArray(userState.deskQueue) || !userState.deskQueue.length) {
                const seen = new Set();
                userState.deskQueue = chosen.filter(q => {
                    const k = app.quoteKey(q);
                    if(seen.has(k)) return false;
                    seen.add(k);
                    return true;
                });
            }
            userState.selectionCompleted = true;
            app.save();
        }
        ui.switchView(userState.view, true);
        if(userState.view === "desk" && Array.isArray(userState.deskQueue) && userState.deskQueue.length) {
            const first = ui.ensureQuoteItem(userState.deskQueue[0]);
            if(first) ui.runBuilder(first);
        }
        const navLab = document.getElementById("nav-lab");
        const navDesk = document.getElementById("nav-desk");
        if(navLab) navLab.classList.toggle("hidden", !modules.lab);
        if(navDesk) navDesk.classList.toggle("hidden", !modules.desk);
        ui._initInProgress = false;
        document.body.classList.add("tsa-init-done");
    },
    initReaderControls: function() {
        const zoom = document.getElementById("reader-zoom");
        if(zoom && !zoom.dataset.bound) {
            zoom.dataset.bound = "true";
            const onZoom = () => ui.applyReaderZoom(zoom.value);
            zoom.addEventListener("input", onZoom);
            zoom.addEventListener("change", onZoom);
        }
        const saved = localStorage.getItem("tsa_reader_zoom");
        if(zoom && saved) zoom.value = saved;
        ui.applyReaderZoom(zoom ? zoom.value : 110);
        const height = document.getElementById("reader-height");
        if(height && !height.dataset.bound) {
            height.dataset.bound = "true";
            const onHeight = () => ui.applyReaderHeight(height.value);
            height.addEventListener("input", onHeight);
            height.addEventListener("change", onHeight);
        }
        const savedHeight = localStorage.getItem("tsa_reader_height");
        if(height && savedHeight) height.value = savedHeight;
        ui.applyReaderHeight(height ? height.value : 3.2);
        ui.positionReaderWindow();
        if(!ui._readerPosBound) {
            ui._readerPosBound = true;
            window.addEventListener("resize", () => ui.positionReaderWindow());
        }
        const sourceContent = document.getElementById("source-content");
        if(sourceContent && !sourceContent.dataset.selectBound) {
            sourceContent.dataset.selectBound = "true";
            const tryProcessSelection = (sourceEl, sourceText, closeReaderThenSwitch, preCaptured) => {
                let text, anchor, focus;
                if(preCaptured && preCaptured.text) {
                    text = preCaptured.text;
                    anchor = preCaptured.anchorNode;
                    focus = preCaptured.focusNode;
                } else {
                    const selection = window.getSelection ? window.getSelection() : null;
                    if(!selection || selection.isCollapsed) return;
                    text = selection.toString().trim();
                    anchor = selection.anchorNode;
                    focus = selection.focusNode;
                }
                if(!text || text.length < 3) return;
                const ancEl = anchor && anchor.nodeType === 3 ? anchor.parentNode : anchor;
                const focEl = focus && focus.nodeType === 3 ? focus.parentNode : focus;
                if(!sourceEl || !sourceEl.contains(ancEl) || !sourceEl.contains(focEl)) return;
                if(!app.quoteInSource(text, sourceText)) return;
                ui._freeSelectPendingQuote = text;
                if(window.getSelection) window.getSelection().removeAllRanges();
                if(closeReaderThenSwitch) {
                    ui.closeModal("modal-source");
                    ui.switchView("select");
                }
                ui.renderSelection();
            };
            if(!document.body.dataset.freeSelectMouseBound) {
                document.body.dataset.freeSelectMouseBound = "true";
                const docSelectHandler = (e) => {
                    const sel = appData.selection;
                    const levelBank = app.getLevelBank();
                    const level = app.getEffectiveLevel();
                    const levelEntry = levelBank[level] || {};
                    const modules = appData.settings && appData.settings.modulesActive ? appData.settings.modulesActive : {};
                    if(!modules.selection || !sel || !sel.enabled || !levelEntry.freeSelectFromText) return;
                    const sourceText = app.getSourceText();
                    if(!sourceText || !String(sourceText).trim()) return;
                    let preCaptured = null;
                    if(e && e.type === "touchend") {
                        const selObj = window.getSelection ? window.getSelection() : null;
                        if(selObj && !selObj.isCollapsed) {
                            const txt = selObj.toString().trim();
                            if(txt && txt.length >= 3) {
                                const anc = selObj.anchorNode;
                                const foc = selObj.focusNode;
                                if(sourceContent && (sourceContent.contains(anc) || sourceContent.contains(foc))) {
                                    preCaptured = { text: txt, anchorNode: anc, focusNode: foc };
                                } else {
                                    const quoteSelectEl = document.getElementById("selection-free-select-source");
                                    if(quoteSelectEl && quoteSelectEl.offsetParent !== null && (quoteSelectEl.contains(anc) || quoteSelectEl.contains(foc))) {
                                        preCaptured = { text: txt, anchorNode: anc, focusNode: foc };
                                    }
                                }
                            }
                        }
                    }
                    const modal = document.getElementById("modal-source");
                    const quoteSelectEl = document.getElementById("selection-free-select-source");
                    const runProcess = () => {
                        const inModal = modal && modal.classList.contains("open");
                        const inQuoteSelect = quoteSelectEl && quoteSelectEl.offsetParent !== null;
                        const usePreForModal = preCaptured && sourceContent && (sourceContent.contains(preCaptured.anchorNode) || sourceContent.contains(preCaptured.focusNode));
                        const usePreForQuote = preCaptured && quoteSelectEl && (quoteSelectEl.contains(preCaptured.anchorNode) || quoteSelectEl.contains(preCaptured.focusNode));
                        if(inModal) {
                            tryProcessSelection(sourceContent, sourceText, true, usePreForModal ? preCaptured : null);
                        } else if(inQuoteSelect) {
                            tryProcessSelection(quoteSelectEl, sourceText, false, usePreForQuote ? preCaptured : null);
                        }
                    };
                    if(preCaptured) {
                        runProcess();
                    } else {
                        requestAnimationFrame(() => { setTimeout(runProcess, 10); });
                    }
                };
                document.addEventListener("mouseup", docSelectHandler, true);
                document.addEventListener("touchend", docSelectHandler, { capture: true, passive: true });
            }
        }
    },
    positionReaderWindow: function() {
        const win = document.getElementById("reader-window");
        const controls = document.querySelector(".reader-controls");
        if(!win || !controls) return;
        const body = controls.parentElement;
        const bodyRect = body ? body.getBoundingClientRect() : null;
        const ctrlRect = controls.getBoundingClientRect();
        const offset = bodyRect ? (ctrlRect.bottom - bodyRect.top + 6) : (controls.offsetHeight + 6);
        win.style.top = `${offset}px`;
    },
    applyReaderZoom: function(value) {
        const pct = Math.max(80, Math.min(180, parseInt(value, 10) || 110));
        const size = (pct / 100) + "rem";
        document.documentElement.style.setProperty("--reader-zoom", size);
        ui.updateReaderWindowHeight(pct);
        ["source-content", "source-inline", "source-inline-select", "intro-text"].forEach(id => {
            const el = document.getElementById(id);
            if(el) el.style.setProperty("font-size", size, "important");
        });
        const windowEl = document.getElementById("reader-window");
        if(windowEl) windowEl.style.setProperty("font-size", size, "important");
        localStorage.setItem("tsa_reader_zoom", String(pct));
    },
    updateReaderWindowHeight: function(pct) {
        const zoomPct = Math.max(80, Math.min(180, parseInt(pct, 10) || 110));
        const base = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--reader-window-height-base")) || 3.2;
        const scaled = base * (zoomPct / 110);
        document.documentElement.style.setProperty("--reader-window-height", `${scaled}em`);
        ui.positionReaderWindow();
    },
    applyReaderHeight: function(value) {
        const v = Math.max(2, Math.min(8, parseFloat(value) || 3.2));
        document.documentElement.style.setProperty("--reader-window-height-base", `${v}em`);
        localStorage.setItem("tsa_reader_height", String(v));
        const zoomEl = document.getElementById("reader-zoom");
        ui.updateReaderWindowHeight(zoomEl ? zoomEl.value : 110);
    },
    getKeywordMap: function(question, focusTags) {
        const map = {};
        if(Array.isArray(focusTags) && focusTags.length) {
            focusTags.forEach(tag => {
                const raw = String(tag || "").trim();
                if(!raw) return;
                const parts = raw.split(/[:=]/);
                const key = parts[0].trim().toLowerCase();
                if(!key) return;
                const syns = parts.slice(1).join(":").split(/[,|]/).map(s => s.trim().toLowerCase()).filter(Boolean);
                map[key] = Array.from(new Set([key, ...syns]));
            });
        }
        if(!Object.keys(map).length) {
            const words = String(question || "").toLowerCase().match(/\b[a-z']+\b/g) || [];
            words.filter(w => w.length >= 4 && !ui._stopWords.has(w)).forEach(w => {
                if(!map[w]) map[w] = [w];
            });
        }
        return map;
    },
    countTerm: function(term, text) {
        if(!term || !text) return 0;
        const safe = term.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const re = new RegExp(`\\b${safe}\\b`, "g");
        const matches = text.match(re);
        return matches ? matches.length : 0;
    },
    buildQuestionHtml: function(question, focusTags, quote) {
        const q = String(question || "");
        if(!q) return "";
        const map = ui.getKeywordMap(q, focusTags);
        const quoteText = String(quote || "").toLowerCase();
        return q.replace(/\b([A-Za-z][A-Za-z']*)\b/g, (m) => {
            const key = m.toLowerCase();
            const terms = map[key];
            if(!terms) return app.escapeHtml(m);
            let hits = 0;
            terms.forEach(t => { hits += ui.countTerm(t, quoteText); });
            const level = Math.min(3, hits);
            if(level <= 0) return app.escapeHtml(m);
            const glow = 6 + (level * 4);
            const alpha = 0.2 + (level * 0.15);
            const style = `style="color: var(--primary); box-shadow: 0 0 ${glow}px rgba(0,150,136,${alpha}); border-bottom:2px solid rgba(0,150,136,${alpha}); padding:0 2px; border-radius:4px;"`;
            return `<span ${style}>${app.escapeHtml(m)}</span>`;
        });
    },
    renderQuestionBanner: function() {
        const question = (appData.selection && appData.selection.question && appData.selection.question.prompt) 
            ? appData.selection.question.prompt 
            : (appData && appData.question ? appData.question : "");
        const focusTags = appData.selection && appData.selection.question ? (appData.selection.question.focusTags || []) : [];
        const html = question 
            ? `<strong>Focus Question:</strong> ${ui.buildQuestionHtml(question, focusTags, "")}` 
            : "";
        ["question-banner", "question-banner-select", "question-banner-desk"].forEach(id => {
            const el = document.getElementById(id);
            if(!el) return;
            if(!question) { el.classList.add("hidden"); el.innerHTML = ""; return; }
            el.classList.remove("hidden");
            el.innerHTML = html;
        });
    },

    // THEME
    setTheme: function(key, val) { document.documentElement.style.setProperty('--'+key, val); localStorage.setItem('tsa_theme_'+key, val); },
    applyReaderHighlightTheme: function() {
        const h = localStorage.getItem('tsa_theme_reader') || "#009688";
        const alpha = Math.max(0.02, Math.min(0.2, parseFloat(localStorage.getItem('tsa_reader_alpha')) || 0.08));
        const lineHeight = Math.max(1, Math.min(6, parseInt(localStorage.getItem('tsa_reader_line'), 10) || 2));
        const toRgb = (c) => {
            const v = c.replace("#", "");
            if(v.length === 3) {
                const r = parseInt(v[0] + v[0], 16);
                const g = parseInt(v[1] + v[1], 16);
                const b = parseInt(v[2] + v[2], 16);
                return { r, g, b };
            }
            if(v.length === 6) {
                const r = parseInt(v.slice(0,2), 16);
                const g = parseInt(v.slice(2,4), 16);
                const b = parseInt(v.slice(4,6), 16);
                return { r, g, b };
            }
            return { r: 0, g: 150, b: 136 };
        };
        const rgb = toRgb(h);
        const borderAlpha = Math.min(1, Math.max(0.2, alpha * 6));
        const lineAlpha = Math.min(1, Math.max(0.3, alpha * 7));
        document.documentElement.style.setProperty('--reader-highlight', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`);
        document.documentElement.style.setProperty('--reader-highlight-border', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${borderAlpha})`);
        document.documentElement.style.setProperty('--reader-highlight-line', `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${lineAlpha})`);
        document.documentElement.style.setProperty('--reader-highlight-line-height', `${lineHeight}px`);
    },
    setReaderHighlight: function(hex) {
        const h = String(hex || "").trim();
        if(!h) return;
        localStorage.setItem('tsa_theme_reader', h);
        ui.applyReaderHighlightTheme();
    },
    setReaderHighlightOpacity: function(val) {
        localStorage.setItem('tsa_reader_alpha', String(val));
        ui.applyReaderHighlightTheme();
    },
    setReaderLineThickness: function(val) {
        localStorage.setItem('tsa_reader_line', String(val));
        ui.applyReaderHighlightTheme();
    },
    loadTheme: function() {
        const bg = localStorage.getItem('tsa_theme_bg');
        const text = localStorage.getItem('tsa_theme_text');
        const card = localStorage.getItem('tsa_theme_card');
        const reader = localStorage.getItem('tsa_theme_reader');
        if(bg) document.documentElement.style.setProperty('--bg', bg);
        if(text) document.documentElement.style.setProperty('--text', text);
        if(card) document.documentElement.style.setProperty('--card', card);
        if(reader) ui.setReaderHighlight(reader);
        ui.applyReaderHighlightTheme();
        const readerEl = document.getElementById("col-reader");
        if(readerEl && reader) readerEl.value = reader;
        const alphaEl = document.getElementById("col-reader-alpha");
        if(alphaEl) alphaEl.value = localStorage.getItem('tsa_reader_alpha') || "0.08";
        const lineEl = document.getElementById("col-reader-line");
        if(lineEl) lineEl.value = localStorage.getItem('tsa_reader_line') || "2";
    },
    resetTheme: function() { 
        localStorage.removeItem('tsa_theme_bg'); 
        localStorage.removeItem('tsa_theme_text'); 
        localStorage.removeItem('tsa_theme_card'); 
        localStorage.removeItem('tsa_theme_reader');
        localStorage.removeItem('tsa_reader_alpha');
        localStorage.removeItem('tsa_reader_line');
        location.reload(); 
    },

    renderLab: function() {
        const src = app.getSourceText();
        const inline = document.getElementById("source-inline");
        if(inline) {
            const warn = app._sourceWarn
                ? `<div style="margin-bottom:8px; padding:6px 8px; border:1px solid var(--error); background:rgba(244,67,54,0.08); border-radius:6px; font-size:0.85rem;">Full source text missing please re-load.</div>`
                : "";
            inline.innerHTML = warn + app.formatSourceHtml(src);
        }
        const modal = document.getElementById("source-content");
        if(modal) modal.innerHTML = app.formatSourceHtml(src);
        const g = document.getElementById("quote-grid"); g.innerHTML = "";
        ui._seenQuoteKeys = new Set();
        
        if(!appData.items || appData.items.length === 0) {
            g.innerHTML = `
                <div class="card" style="cursor:default;">
                    <div style="font-weight:800; font-size:1.1rem; margin-bottom:6px;">No lesson data</div>
                    <div style="opacity:0.8;">This file doesn't contain any quotes yet.</div>
                </div>
            `;
            document.getElementById("global-card-container").innerHTML = "";
            return;
        }

        const deviceSettings = app.getExportDevices();
        const filterButtons = document.querySelectorAll(".filter-btn[data-filter]");
        filterButtons.forEach(btn => {
            const f = btn.dataset.filter;
            if(f === "tone" || f === "structure" || f === "language") {
                btn.classList.toggle("hidden", !deviceSettings[f]);
            }
        });
        if(userState.filter !== "all" && !deviceSettings[userState.filter]) {
            userState.filter = "all";
        }
        
        const practiceMode = appData.settings && appData.settings.practiceMode && !(appData.settings && appData.settings.autoProgress);
        const effectiveLevel = practiceMode ? (appData.settings.practiceModeLevel || 1) : userState.level;

        // If current level has no items, jump to first available level
        if(!practiceMode) {
            const availableLevels = app.getActiveLevels().filter(lvl => appData.items.some(i => i.levels.includes(lvl)));
            if(availableLevels.length && !availableLevels.includes(userState.level)) {
                userState.level = availableLevels[0];
                const sel = document.getElementById("level-selector");
                if(sel) sel.value = userState.level;
            }
        }

        let levelItems = appData.items.filter(i => practiceMode ? true : i.levels.includes(userState.level));
        levelItems = levelItems.filter(i => !i || !i.type || deviceSettings[i.type]);
        const levelDone = levelItems.length > 0 && levelItems.every(i => userState.completed.includes(i.id));
        const maxLevel = Math.max(...app.getActiveLevels());
        if(!practiceMode && userState.level === maxLevel && levelDone) {
            const essayPreview = (userState.essay || "").trim().replace(/\n/g, "<br>");
            g.innerHTML = `
                <div class="card" style="cursor:default;">
                    <div style="font-weight:800; font-size:1.1rem; margin-bottom:6px;">üèÅ Course Complete</div>
                    <div style="opacity:0.8; margin-bottom:10px;">You have finished all Level 3 quotes. Great work!</div>
                    <div style="border:1px solid var(--border); border-radius:6px; padding:8px; background:var(--bg); max-height:140px; overflow:auto; margin-bottom:10px;">
                        ${essayPreview ? essayPreview : "<span style='opacity:0.6;'>No essay text yet.</span>"}
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-outline" onclick="ui.switchView('desk')">Review Answer</button>
                        <button class="btn btn-doc" onclick="app.exportDoc()">Download Answer</button>
                        <button class="btn btn-outline" onclick="window.print()">Print</button>
                        <button class="btn btn-primary" onclick="app.restartCourse()">Play Again</button>
                    </div>
                </div>
            `;
            return;
        }
        let items = levelItems.filter(i => {
            const isType = (userState.filter==="all" || i.type===userState.filter);
            const isDone = userState.completed.includes(i.id);
            if(isDone && !userState.showDone) return false;
            return isType;
        });

        // If nothing shows but level has items, relax filters
        if(items.length === 0 && levelItems.length > 0) {
            if(userState.filter !== "all") userState.filter = "all";
            if(!userState.showDone) userState.showDone = true;
            items = levelItems.filter(i => true);
        }
        
        items.forEach(i => {
            const div = document.createElement("div");
            div.className = `card card-${i.type} card-lab-quote`;
            if(userState.completed.includes(i.id)) div.style.opacity = "0.5";
            const editBtn = !appData.isStandalone
                ? `<button type="button" class="card-edit-btn" onclick="event.stopPropagation(); ui.openAdminToQuote(this.dataset.itemId)" title="Edit this quote" data-item-id="${app.escapeHtml(String(i.id || ""))}">‚úèÔ∏è</button>`
                : "";
            div.innerHTML = `<span class="quote-text">"${app.escapeHtml(i.original || "")}"</span><div class="card-meta"><span>${i.type}</span><span>${userState.completed.includes(i.id)?'‚úÖ':''}</span></div>${editBtn}`;
            div.style.position = "relative";
            div.onclick = () => app.selectQuote(i.id);
            g.appendChild(div);
        });

        const gs = document.getElementById("global-card-container");
        if(deviceSettings.structure && appData.globalStructure.enabled && appData.globalStructure.items.length > 0) {
            gs.innerHTML = "";
            appData.globalStructure.items.forEach(q => {
                const div = document.createElement("div");
                div.className = "card card-global";
                div.innerHTML = `<strong>üèóÔ∏è Structure</strong><br><small>${q.question}</small>`;
                div.onclick = () => ui.runGlobal(q);
                gs.appendChild(div);
            });
        } else { gs.innerHTML = ""; }
        
        document.querySelectorAll(".filter-btn").forEach(b => b.classList.toggle("active", b.dataset.filter === userState.filter));
    },

    switchView: function(v, force) {
        let redirectedToDesk = false;
        const isInitialLoad = force === true || ui._initInProgress;
        if(v === "select" && ui._initInProgress) {
            const mods = appData.settings && appData.settings.modulesActive ? appData.settings.modulesActive : { desk: true, lab: true };
            v = mods.desk ? "desk" : (mods.lab ? "lab" : "desk");
            redirectedToDesk = (v === "desk");
            userState.view = v;
        }
        if(v === "select" && isInitialLoad) {
            const deskLenCheck = Array.isArray(userState.deskQueue) ? userState.deskQueue.length : 0;
            if((userState.selectionCompleted && deskLenCheck > 0) || deskLenCheck > 0) {
                const mods = appData.settings && appData.settings.modulesActive ? appData.settings.modulesActive : { desk: true, lab: true };
                v = mods.desk ? "desk" : (mods.lab ? "lab" : "desk");
                redirectedToDesk = (v === "desk");
                userState.view = v;
                app.save();
            } else {
                const level = userState.level || 1;
                const bank = app.getLevelBank();
                const entry = bank && bank[level] ? bank[level] : {};
                const targetCount = Math.max(1, parseInt(entry.quoteTarget, 10) || 2);
                const chosen = Array.isArray(userState.selectionChosen) ? userState.selectionChosen : [];
                const uniqueChosen = new Set(chosen.map(q => app.quoteKey(q))).size;
                const deskLen = Array.isArray(userState.deskQueue) ? userState.deskQueue.length : 0;
                if(uniqueChosen >= targetCount || deskLen >= targetCount || deskLen > 0) {
                    const mods = appData.settings && appData.settings.modulesActive ? appData.settings.modulesActive : { desk: true, lab: true };
                    v = mods.desk ? "desk" : (mods.lab ? "lab" : "desk");
                    redirectedToDesk = (v === "desk");
                    userState.view = v;
                    if(deskLen < targetCount && chosen.length) {
                        const seen = new Set();
                        userState.deskQueue = chosen.filter(q => {
                            const k = app.quoteKey(q);
                            if(seen.has(k)) return false;
                            seen.add(k);
                            return true;
                        });
                    }
                    userState.selectionCompleted = true;
                    app.save();
                }
            }
        }
        const adminModal = document.getElementById("modal-admin");
        if(!force && adminModal && adminModal.classList.contains("open")) return;
        if(!force) {
            const selection = window.getSelection ? window.getSelection() : null;
            if(selection && selection.type === "Range") return;
            if(ui._textSelecting) return;
        }
        if(window.getSelection) window.getSelection().removeAllRanges();
        ui._textSelecting = false;
        document.querySelectorAll(".hub").forEach(e=>e.classList.remove("active"));
        document.querySelectorAll(".nav-item").forEach(e=>e.classList.remove("active"));
        const viewEl = document.getElementById("view-"+v);
        const navEl = document.getElementById("nav-"+v);
        if(viewEl) viewEl.classList.add("active");
        if(navEl) navEl.classList.add("active");
        if(!appData.isStandalone) {
            userState.view = v;
            app.save();
        }
        if(v === "select") {
            ui.renderSelection();
        } else if(v === "desk" && redirectedToDesk && Array.isArray(userState.deskQueue) && userState.deskQueue.length) {
            const first = ui.ensureQuoteItem(userState.deskQueue[0]);
            if(first) ui.runBuilder(first);
        }
    },

    openModal: (id) => {
        const modal = document.getElementById(id);
        if(modal) modal.classList.add("open");
        if(id === "modal-source") {
            const zoom = document.getElementById("reader-zoom");
            const height = document.getElementById("reader-height");
            ui.applyReaderZoom(zoom ? zoom.value : 110);
            if(height) ui.applyReaderHeight(height.value);
            ui.positionReaderWindow();
        }
    },
    closeModal: (id) => {
        document.getElementById(id).classList.remove("open");
        if(id === 'modal-source') { ui.stopReader(); }
        if(id === 'modal-admin' && !appData.isStandalone) {
            ui._pauseSelectionGate = false;
            ui.renderLab();
            if(ui.activeQuoteId) {
                const item = appData.items.find(i=>i.id===ui.activeQuoteId);
                if(item) ui.runBuilder(item); 
            }
        }
    },
    
    openAdmin: () => {
        ui._pauseSelectionGate = true;
        admin.renderAll(); 
        if(admin.setTab) admin.setTab("controls");
        localStorage.setItem("tsa_admin_tab", "controls");
        if(localStorage.getItem('tsa_unlocked')==='true') { ui.openModal("modal-admin"); }
        else if(prompt("Password (1234)")==="1234") { ui.openModal("modal-admin"); }
    },
    openAdminToQuote: function(itemId) {
        if(appData.isStandalone) return;
        const idx = (appData.items || []).findIndex(i => i && (i.id === itemId || String(i.id) === String(itemId)));
        if(idx < 0) return;
        ui._pauseSelectionGate = true;
        admin.renderAll();
        if(admin.setTab) admin.setTab("edit");
        localStorage.setItem("tsa_admin_tab", "edit");
        if(localStorage.getItem('tsa_unlocked')!=='true' && prompt("Password (1234)")!=="1234") return;
        ui.openModal("modal-admin");
        const evidenceSection = document.getElementById("quote-editor-list");
        if(evidenceSection) {
            const detailsEl = evidenceSection.closest("details");
            if(detailsEl && !detailsEl.open) detailsEl.open = true;
        }
        setTimeout(() => {
            const el = document.getElementById("quote-editor-" + idx);
            if(el) {
                el.scrollIntoView({ behavior: "smooth", block: "nearest" });
                el.style.animation = "none";
                el.offsetHeight;
                el.style.animation = "highlight-pulse 0.8s ease";
            }
        }, 100);
    },
    openAdminToSelectionItem: function(idx) {
        if(appData.isStandalone) return;
        const sel = appData.selection && appData.selection.items;
        if(!sel || idx < 0 || idx >= sel.length) return;
        ui._pauseSelectionGate = true;
        admin.renderAll();
        if(admin.setTab) admin.setTab("edit");
        localStorage.setItem("tsa_admin_tab", "edit");
        if(localStorage.getItem('tsa_unlocked')!=='true' && prompt("Password (1234)")!=="1234") return;
        ui.openModal("modal-admin");
        const selectionSection = document.getElementById("selection-editor-list");
        if(selectionSection) {
            const detailsEl = selectionSection.closest("details");
            if(detailsEl && !detailsEl.open) detailsEl.open = true;
        }
        setTimeout(() => {
            const el = document.getElementById("selection-editor-" + idx);
            if(el) {
                el.scrollIntoView({ behavior: "smooth", block: "nearest" });
                el.style.animation = "none";
                el.offsetHeight;
                el.style.animation = "highlight-pulse 0.8s ease";
            }
        }, 100);
    },
    openAdminToQuoteOrSelection: function(quote, poolItem) {
        if(appData.isStandalone) return;
        const q = String(quote || "").trim();
        if(!q) return;
        const key = app.quoteKey(q);
        const evidenceItem = (appData.items || []).find(i => i && app.quoteKey(i.original) === key);
        if(evidenceItem) {
            ui.openAdminToQuote(evidenceItem.id);
            return;
        }
        const sel = appData.selection && appData.selection.items;
        if(sel) {
            let selIdx = sel.findIndex(i => i && app.quoteKey(i.quote) === key);
            if(selIdx >= 0) {
                ui.openAdminToSelectionItem(selIdx);
                return;
            }
            for(let i = 0; i < sel.length; i++) {
                const dist = (sel[i].distractors || []).find(d => d && app.quoteKey(d.quote) === key);
                if(dist) {
                    ui.openAdminToSelectionItem(i);
                    return;
                }
            }
        }
        ui.openAdmin();
    },
    openSourceText: () => {
        const src = app.getSourceText();
        const el = document.getElementById("source-content");
        if(el) el.innerHTML = app.formatSourceHtml(src);
        ui.openModal("modal-source");
    },
    getReaderScroller: function() {
        const content = document.getElementById("source-content");
        if(content && content.scrollHeight > content.clientHeight) return content;
        return document.querySelector("#modal-source .modal-body");
    },
    toggleReader: function() {
        const body = ui.getReaderScroller();
        if(!body) return;
        const btn = document.getElementById("reader-toggle");
        if(ui._readerTimer || ui._readerRaf) { ui.stopReader(); return; }
        const speedEl = document.getElementById("reader-speed");
        const zoomEl = document.getElementById("reader-zoom");
        ui._readerScrollRemainder = 0;
        const intervalMs = 16;
        ui._readerTimer = setInterval(() => {
            const speedVal = speedEl ? parseFloat(speedEl.value) : 40;
            const minSpeed = 1;
            const maxSpeed = 120;
            const zoomVal = zoomEl ? parseInt(zoomEl.value, 10) : 110;
            const zoomFactor = Math.max(0.2, Math.min(1, 110 / Math.max(80, zoomVal)));
            const speedNorm = Math.max(0, Math.min(1, (speedVal - minSpeed) / (maxSpeed - minSpeed)));
            const minPx = 0.4;
            const maxPx = 70;
            const pxPerSecond = minPx + (Math.pow(speedNorm, 2) * (maxPx - minPx));
            let step = pxPerSecond * zoomFactor * (intervalMs / 1000);
            if(step < 0.005) step = 0.005;
            ui._readerScrollRemainder += step;
            const delta = Math.floor(ui._readerScrollRemainder);
            if(delta >= 1) {
                body.scrollTop += delta;
                ui._readerScrollRemainder -= delta;
            }
            if(body.scrollTop + body.clientHeight >= body.scrollHeight - 2) {
                ui.stopReader();
            }
        }, intervalMs);
        if(btn) btn.textContent = "Pause";
    },
    stopReader: function() {
        if(ui._readerTimer) { clearInterval(ui._readerTimer); ui._readerTimer = null; }
        if(ui._readerRaf) { cancelAnimationFrame(ui._readerRaf); ui._readerRaf = null; }
        ui._readerLastTs = null;
        ui._readerScrollRemainder = 0;
        const btn = document.getElementById("reader-toggle");
        if(btn) btn.textContent = "Auto-Scroll";
    },
    resetReader: function() {
        const body = ui.getReaderScroller();
        if(body) body.scrollTop = 0;
        ui.stopReader();
    },
    toggleHighlight: function() {
        const windowEl = document.getElementById("reader-window");
        if(windowEl) windowEl.classList.toggle("hidden");
        ui.positionReaderWindow();
    },
    copySourceText: async function() {
        const text = (appData && appData.sourceText) ? appData.sourceText : (document.getElementById("source-content")?.innerText || "");
        try {
            if(navigator.clipboard && text) {
                await navigator.clipboard.writeText(text);
            }
        } catch(e) {}
        const status = document.getElementById("save-status");
        if(status) {
            const prev = status.textContent;
            status.textContent = "Copied";
            status.style.opacity = 1;
            setTimeout(() => { status.style.opacity = 0; status.textContent = prev; }, 900);
        } else {
            alert("Copied to clipboard.");
        }
    },

    startWizard: function(item) {
        const needsMeaning = !item.translation || item.translation === "Meaning not provided." || (item.fromSelection && String(item.translation || "").toLowerCase().includes("not provided"));
        if(needsMeaning) {
            ui.openModal("modal-wizard");
            document.getElementById("wizard-title").innerText = "Add meaning";
            document.getElementById("wizard-prompt").innerHTML = `<p class="quote-text">"${item.original}"</p><p>Give this quote a meaning (what it suggests or shows). It will be used in the Sentence Builder.</p>`;
            const grid = document.getElementById("wizard-options");
            grid.innerHTML = `<textarea id="wizard-meaning-input" placeholder="e.g. a sense of tension / the character's fear" style="width:100%; min-height:70px; padding:8px; border:1px solid var(--border); border-radius:6px; margin-bottom:10px; font-size:0.95rem;"></textarea><button class="btn btn-primary" id="wizard-meaning-done">Continue to analysis</button>`;
            const doneBtn = document.getElementById("wizard-meaning-done");
            const input = document.getElementById("wizard-meaning-input");
            if(doneBtn && input) {
                doneBtn.onclick = () => {
                    const val = (input.value || "").trim();
                    if(!val) return;
                    item.translation = val;
                    if(!Array.isArray(item.translationDistractors)) item.translationDistractors = [];
                    app.save();
                    ui.runAddEffectStep(item);
                };
            }
            return;
        }
        const tier = app.getLanguageTier(app.getEffectiveLevel());
        const opts = [item.translation, ...item.translationDistractors||[]]
            .map(v => ({ raw: v, display: app.simplifyText(v, tier) }))
            .sort(()=>Math.random()-0.5);
        ui.openModal("modal-wizard");
        document.getElementById("wizard-title").innerText = "Phase 1: Meaning";
        document.getElementById("wizard-prompt").innerHTML = `<p class="quote-text">"${item.original}"</p><p>What does this mean?</p>`;
        const grid = document.getElementById("wizard-options"); grid.innerHTML = "";
        opts.forEach(o => {
            const b = document.createElement("button"); b.className = "btn btn-outline"; b.textContent = o.display;
            b.onclick = () => {
                if(o.raw === item.translation) {
                    b.style.background = "var(--success)"; b.style.color="white"; app.playSound('correct');
                    setTimeout(() => {
                        const hasAnalysis = item.effect || (item.effectDistractors && item.effectDistractors.length);
                        if(hasAnalysis) {
                            ui.runAnalysisStep(item);
                        } else {
                            ui.closeModal("modal-wizard");
                            ui.runBuilder(item);
                        }
                    }, 500);
                } else { b.classList.add('shake'); b.style.background = "var(--error)"; b.style.color="white"; }
            };
            grid.appendChild(b);
        });
    },

    runAddEffectStep: function(item) {
        document.getElementById("wizard-title").innerText = "Add analysis";
        document.getElementById("wizard-prompt").innerHTML = `<p class="quote-text">"${item.original}"</p><p>Add an analysis sentence (how or why the writer uses this). It will appear in the Sentence Builder.</p>`;
        const grid = document.getElementById("wizard-options");
        grid.innerHTML = `<textarea id="wizard-effect-input" placeholder="e.g. The writer uses this to suggest the character's growing fear." style="width:100%; min-height:70px; padding:8px; border:1px solid var(--border); border-radius:6px; margin-bottom:10px; font-size:0.95rem;">${app.escapeHtml(item.effect || "")}</textarea><button class="btn btn-primary" id="wizard-effect-done">Done ‚Äî open Sentence Builder</button>`;
        const doneBtn = document.getElementById("wizard-effect-done");
        const input = document.getElementById("wizard-effect-input");
        if(doneBtn && input) {
            doneBtn.onclick = () => {
                const val = (input.value || "").trim();
                item.effect = val || item.effect || item.translation;
                if(!Array.isArray(item.effectDistractors)) item.effectDistractors = [];
                app.save();
                ui.closeModal("modal-wizard");
                ui.runBuilder(item);
            };
        }
    },

    runAnalysisStep: function(item) {
        const needsEffect = !item.effect || item.effect === "Meaning not provided." || String(item.effect || "").toLowerCase().includes("not provided");
        if(needsEffect) {
            ui.runAddEffectStep(item);
            return;
        }
        const tier = app.getLanguageTier(app.getEffectiveLevel());
        const opts = [item.effect, ...item.effectDistractors||[]]
            .filter(Boolean)
            .map(v => ({ raw: v, display: app.simplifyText(v, tier) }))
            .sort(()=>Math.random()-0.5);
        document.getElementById("wizard-title").innerText = "Phase 2: Analysis";
        document.getElementById("wizard-prompt").innerHTML = `<p class="quote-text">"${item.original}"</p><p>Which analysis is most accurate?</p>`;
        const grid = document.getElementById("wizard-options"); grid.innerHTML = "";
        opts.forEach(o => {
            const b = document.createElement("button"); b.className = "btn btn-outline"; b.textContent = o.display;
            b.onclick = () => {
                if(o.raw === item.effect) {
                    b.style.background = "var(--success)"; b.style.color="white"; app.playSound('correct');
                    setTimeout(() => {
                        ui.closeModal("modal-wizard");
                        ui.runBuilder(item);
                    }, 500);
                } else { b.classList.add('shake'); b.style.background = "var(--error)"; b.style.color="white"; }
            };
            grid.appendChild(b);
        });
    },

    runBuilder: function(item) {
        ui.activeQuoteId = item.id;
        ui.switchView("desk");
        ui.renderDeskQuoteTabs();
        const cont = document.getElementById("sentence-builder"); cont.innerHTML = "";
        const level = (appData.settings && appData.settings.practiceMode && !(appData.settings && appData.settings.autoProgress))
            ? (appData.settings.practiceModeLevel || 1)
            : userState.level;
        let cfg = appData.sentenceConfig[level] || appData.sentenceConfig[3] || [];
        const isValidBuilderSlot = (slot) => {
            if(!slot) return false;
            if(slot === "choice") return false;
            if(slot === "quote" || slot === "starter" || slot === "marker" || slot === "method" || slot === "point" || slot === "analysis") return true;
            if(slot.startsWith("manual_")) return true;
            if(slot.startsWith("link_")) return true;
            return false;
        };
        cfg = cfg.filter(isValidBuilderSlot);
        if(!cfg.length) cfg = app.getDefaultSentenceConfig(level);
        if(appData.settings && appData.settings.practiceMode && !appData.settings.autoProgress && appData.settings.practiceFixedTemplate) {
            cfg = app.getPracticeTemplate(level);
        }
        if(appData.settings && appData.settings.practiceMode && !appData.settings.autoProgress && appData.settings.practiceForceAuto) {
            const linkSlot = `link_l${level}`;
            const mapSlot = (slot) => {
                if(!slot || !slot.startsWith("manual")) return slot;
                const tail = slot.split("_")[1] || "";
                if(tail === "marker") return "marker";
                if(tail === "starter") return "starter";
                if(tail === "method") return "method";
                if(tail === "link") return linkSlot;
                return "point";
            };
            cfg = cfg.map(mapSlot);
        }
        
        cfg.forEach(slot => {
            const row = document.createElement("div"); row.className = "slot-row";
            if(slot === "quote") {
                row.innerHTML = `<span class="slot-label">EVIDENCE</span><div class="slot-static" data-v='"${item.original}"'>"${item.original}"</div>`;
            } else if(slot.startsWith("manual")) {
                let lbl = slot.split('_')[1] || "Text";
                // Manual slots are always student-filled (no auto-prefill).
                row.innerHTML = `<span class="slot-label">${lbl.toUpperCase()} (Idea)</span><input class="slot-input" oninput="ui.updPrev()">`;
            } else {
                let key = slot.includes("link") ? (slot.split('_')[1]||'l1') : slot+"s";
                if(slot==='point' || slot === "analysis") key='points';

                const perQuoteList = (() => {
                    if(slot === "point" || slot === "analysis") {
                        if(item.effect || (item.effectDistractors && item.effectDistractors.length)) {
                            return [item.effect, ...(item.effectDistractors || [])].filter(Boolean);
                        }
                    }
                    if(slot === "starter") {
                        const base = Array.isArray(item.starters) ? item.starters : (item.starter ? [item.starter] : null);
                        const perQuote = base && base.length ? [...base, ...(item.starterDistractors || [])].filter(Boolean) : [];
                        const bankStarters = Array.isArray(appData.banks && appData.banks.starters) ? appData.banks.starters : [];
                        const merged = [...new Set([...perQuote, ...bankStarters].map(String).filter(Boolean))];
                        if(merged.length) return merged;
                    }
                    if(slot === "marker") {
                        const base = Array.isArray(item.markers) ? item.markers : (item.marker ? [item.marker] : null);
                        if(base && base.length) return [...base, ...(item.markerDistractors || [])].filter(Boolean);
                    }
                    if(slot === "method") {
                        const base = Array.isArray(item.methods) ? item.methods : (item.method ? [item.method] : null);
                        if(base && base.length) return [...base, ...(item.methodDistractors || [])].filter(Boolean);
                    }
                    if(slot.includes("link")) {
                        const base = Array.isArray(item.links) ? item.links : (item.link ? [item.link] : null);
                        if(base && base.length) return [...base, ...(item.linkDistractors || [])].filter(Boolean);
                    }
                    return null;
                })();

                let list = null;
                let correct = null;
                if(perQuoteList) {
                    list = perQuoteList;
                    if(slot === "point" || slot === "analysis") correct = item.effect;
                    if(slot === "starter") correct = item.starter || (Array.isArray(item.starters) ? item.starters[0] : null);
                    if(slot === "marker") correct = item.marker || (Array.isArray(item.markers) ? item.markers[0] : null);
                    if(slot === "method") correct = item.method || (Array.isArray(item.methods) ? item.methods[0] : null);
                    if(slot.includes("link")) correct = item.link || (Array.isArray(item.links) ? item.links[0] : null);
                }
                else if(slot.includes("link")) {
                    list = appData.banks.links[key];
                    if(!list || !list.length) list = appData.banks.links.l3;
                } else {
                    list = appData.banks[key];
                }
                if(list) {
                    const toText = (o) => {
                        if(typeof o === "string") return o;
                        if(o && typeof o === "object" && typeof o.text === "string") return o.text;
                        return "";
                    };
                    const normalized = list.map(toText).filter(Boolean);
                    const options = correct ? app.shuffle(normalized) : normalized;
                    row.innerHTML = `<span class="slot-label">${slot.toUpperCase()}</span><select class="slot-select" onchange="ui.updPrev()"><option value="">Select...</option>${options.map(o=>`<option>${o}</option>`).join('')}</select>`;
                    if(correct) {
                        const sel = row.querySelector("select");
                        sel.dataset.correct = correct;
                        sel.dataset.hint = "Does that make sense? What word would work better here?";
                    }
                }
            }
            cont.appendChild(row);
        });
        ui.updPrev();
        
        if(!userState.completed.includes(item.id)) { 
            userState.score+=10; document.getElementById("score-display").innerText = userState.score + " XP";
        }
    },

    updPrev: function() {
        let txt = [];
        document.querySelectorAll("#sentence-builder select, #sentence-builder input, #sentence-builder .slot-static").forEach(el => {
            let v = el.tagName==="DIV"? el.dataset.v : el.value;
            if(v && v.trim()) txt.push(v);
        });
        document.getElementById("preview-box").innerText = txt.join(" ") + ".";
        ui.updateHintPanel();
    },
    updateHintPanel: function() {
        const hint = document.getElementById("hint-panel");
        if(!hint) return;
        const wrong = ui.getIncorrectSelections();
        if(!wrong.length) {
            hint.classList.add("hidden");
            return;
        }
        const el = wrong[0];
        const count = parseInt(el.dataset.wrong || "0", 10);
        const correct = el.dataset.correct || "";
        const messages = [
            "Does that make sense?",
            "Try a different option. Think about meaning and tone.",
            correct ? `Hint: The best fit is "${correct}".` : "Try a different option."
        ];
        hint.textContent = messages[Math.min(count, messages.length - 1)];
        hint.classList.remove("hidden");
    },
    getIncorrectSelections: function() {
        const wrong = [];
        document.querySelectorAll("#sentence-builder select[data-correct]").forEach(sel => {
            if(!sel.dataset.lastValue) sel.dataset.lastValue = sel.value || "";
            const isCorrect = sel.value && sel.value === sel.dataset.correct;
            if(isCorrect) {
                sel.dataset.wrong = "0";
            } else if(sel.value) {
                if(sel.dataset.lastValue !== sel.value) {
                    const next = parseInt(sel.dataset.wrong || "0", 10) + 1;
                    sel.dataset.wrong = String(next);
                }
            }
            sel.dataset.lastValue = sel.value || "";
            if(sel.value && sel.value !== sel.dataset.correct) wrong.push(sel);
        });
        return wrong;
    },

    runGlobal: function(q) {
        ui.openModal("modal-wizard");
        document.getElementById("wizard-title").innerText = "Structure Analysis";
        document.getElementById("wizard-prompt").innerHTML = `<p>${q.question}</p>`;
        const rawOpts = [q.correct, ...(Array.isArray(q.distractors) ? q.distractors : [])].filter(Boolean);
        const opts = [...new Map(rawOpts.map(o => [String(o).trim().toLowerCase(), o])).values()].sort(()=>Math.random()-0.5);
        const grid = document.getElementById("wizard-options"); grid.innerHTML = "";
        opts.forEach(o => {
            const b = document.createElement("button"); b.className = "btn btn-outline"; b.textContent = o;
            b.onclick = () => {
                if(o === q.correct) {
                    b.style.background = "var(--success)"; b.style.color="white"; userState.score+=20; app.save(); ui.init(); app.playSound('correct');
                    setTimeout(()=>ui.closeModal("modal-wizard"), 800);
                } else { b.classList.add('shake'); b.style.background = "var(--error)"; b.style.color="white"; }
            };
            grid.appendChild(b);
        });
    },

    renderSelection: function() {
        const cont = document.getElementById("selection-area");
        if(!cont) return;
        if(!appData.selection) {
            appData.selection = app.repairSelection({}, { activeLevels: app.getActiveLevels(), lessonItems: appData.items });
        }
        const sel = appData.selection;
        if(!sel || !sel.enabled) {
            cont.innerHTML = `<div class="card" style="cursor:default;">
                <div style="font-weight:800; font-size:1.1rem; margin-bottom:6px;">Quote Selection needs more data</div>
                <div style="opacity:0.8; margin-bottom:8px;">Enable Quote Selection in Settings.</div>
                <button class="btn btn-outline" onclick="ui.openAdmin()">Open Settings</button>
            </div>`;
            return;
        }
        const levelBank = app.getLevelBank();
        const level = app.getEffectiveLevel();
        const levelEntry = levelBank[level] || {};
        const sourceTextEarly = app.getSourceText();
        const hasSourceEarly = !!(sourceTextEarly && String(sourceTextEarly).trim());
        if((!sel.items.length || sel.items.length < 2) && !(levelEntry.freeSelectFromText && hasSourceEarly)) {
            cont.innerHTML = `<div class="card" style="cursor:default;">
                <div style="font-weight:800; font-size:1.1rem; margin-bottom:6px;">Quote Selection needs more data</div>
                <div style="opacity:0.8; margin-bottom:8px;">Add at least 2 quotes in the Quote Selection Editor, or enable "Tap text" for this level and add source text.</div>
                <button class="btn btn-outline" onclick="ui.openAdmin()">Open Settings</button>
            </div>`;
            return;
        }
        const quickPick = sel.modes && sel.modes.quickPick;
        const baseStages = sel.modes && sel.modes.stages ? sel.modes.stages : ["discriminate","align","justify"];
        const stages = quickPick ? ["guided"] : baseStages;
        const stageIndex = Math.max(1, Math.min(stages.length, userState.selectionStage || 1));
        const stageKey = stages[stageIndex - 1];
        const stageConfig = sel.stageConfigByLevel && sel.stageConfigByLevel[level] ? sel.stageConfigByLevel[level] : {};
        const stageMode = stageConfig[stageKey] || "choice";
        const selectionDevices = appData.settings && appData.settings.selectionDevices
            ? appData.settings.selectionDevices
            : { language: true, tone: true, structure: true };
        let targetCount = Math.max(
            1,
            (levelEntry.quoteTarget) ? parseInt(levelEntry.quoteTarget, 10)
                : (appData.settings && appData.settings.quoteTarget) ? parseInt(appData.settings.quoteTarget, 10)
                : (sel.modes && sel.modes.quoteTarget) ? parseInt(sel.modes.quoteTarget, 10)
                : sel.modes.quoteCount
        );
        const distractorTarget = parseInt(levelEntry.distractorCount, 10) || 0;
        const optionCount = Math.max(2, Math.min(10, targetCount + distractorTarget));
        const correctItemsAll = sel.items.filter(i => i.correct)
            .filter(i => !i.device || selectionDevices[i.device] !== false);
        const sourceText = app.getSourceText();
        const hasSource = !!(sourceText && String(sourceText).trim());
        const inlineSelect = document.getElementById("source-inline-select");
        if(inlineSelect) {
            if(hasSource) {
                const warn = app._sourceWarn ? `<div style="margin-bottom:8px; padding:6px 8px; border:1px solid var(--error); background:rgba(244,67,54,0.08); border-radius:6px; font-size:0.85rem;">Full source text missing please re-load.</div>` : "";
                inlineSelect.innerHTML = warn + app.formatSourceHtml(sourceText);
            } else {
                inlineSelect.innerHTML = `<div style="opacity:0.7; font-style:italic;">No source text available. Add source text in Settings to read the passage here.</div>`;
            }
        }
        const isInSource = (q) => hasSource ? app.quoteInSource(q, sourceText) : true;
        let correctItems = correctItemsAll.filter(i => Array.isArray(i.levels) ? i.levels.includes(level) : false);
        let correctInSource = correctItems.filter(i => isInSource(i.quote));
        if(correctInSource.length) {
            correctItems = correctInSource;
        } else if(!correctItems.length && correctItemsAll.length) {
            const anyInSource = correctItemsAll.filter(i => isInSource(i.quote));
            if(anyInSource.length) correctItems = anyInSource;
        }
        const chosenList = Array.isArray(userState.selectionChosen) ? userState.selectionChosen : [];
        const chosenSet = new Set(chosenList.map(q => app.quoteKey(q)));
        const uniqueChosenCount = chosenSet.size;
        const deskQueueLen = Array.isArray(userState.deskQueue) ? userState.deskQueue.length : 0;
        correctItems = correctItems.filter(i => !chosenSet.has(app.quoteKey(i.quote)));
        const canPickFromText = levelEntry.freeSelectFromText && hasSource;
        const questionTextGlobal = (sel.question && sel.question.prompt) ? sel.question.prompt : (appData.question || "");
        if(uniqueChosenCount >= targetCount && !canPickFromText) {
            cont.innerHTML = `${questionTextGlobal ? `<div class="card" style="margin-bottom:10px; padding:10px; background:rgba(0,150,136,0.06); border-left:4px solid var(--primary);"><div style="font-weight:700; font-size:0.85rem; margin-bottom:4px; opacity:0.9;">Question</div><div style="font-size:0.95rem;">${app.escapeHtml(questionTextGlobal)}</div></div>` : ""}<div class="card" style="cursor:default; padding:16px;">
                <div style="font-weight:700; margin-bottom:10px;">You have ${uniqueChosenCount} quote(s) selected (target: ${targetCount}).</div>
                <button class="btn btn-primary" onclick="ui.sendSelectionQuotesToBuilder()">Send to Sentence Builder</button>
                <span style="margin-left:8px; font-size:0.9rem; opacity:0.8;">Or stay here to change your selection.</span>
            </div>`;
            return;
        }
        if(levelEntry.freeSelectFromText) {
            if(!hasSource) {
                cont.innerHTML = `<div class="card" style="cursor:default;">
                    <div style="font-weight:800; font-size:1.1rem; margin-bottom:6px;">Source text needed</div>
                    <div style="opacity:0.8;">Add source text in Settings so you can select a quote from the passage.</div>
                    <button class="btn btn-outline" onclick="ui.openAdmin()">Open Settings</button>
                </div>`;
                return;
            }
            const questionText = (sel.question && sel.question.prompt) ? sel.question.prompt : (appData.question || "");
            const pendingQuote = ui._freeSelectPendingQuote || "";
            if(pendingQuote) {
                cont.innerHTML = `
                    <div class="section-header">Examine your quote</div>
                    <div class="card" style="margin-bottom:10px;">
                        <div style="font-weight:700; margin-bottom:6px;">Selected quote</div>
                        <div style="font-style:italic; margin-bottom:10px; padding:8px; background:var(--bg); border-radius:6px;">"${app.escapeHtml(pendingQuote)}"</div>
                        <div style="font-weight:700; margin-bottom:4px;">Question</div>
                        <div style="margin-bottom:10px; opacity:0.9;">${app.escapeHtml(questionText) || "‚Äî"}</div>
                        <div style="font-weight:700; margin-bottom:4px;">Does this quote support your answer? Why?</div>
                        <textarea id="free-select-why" placeholder="Optional: briefly say why this quote fits the question." style="width:100%; min-height:60px; padding:8px; border:1px solid var(--border); border-radius:6px; margin-bottom:10px; font-size:0.9rem;"></textarea>
                        <div style="display:flex; gap:8px;">
                            <button class="btn btn-primary btn-small" id="free-select-use">Use this quote</button>
                            <button class="btn btn-outline btn-small" id="free-select-cancel">Cancel</button>
                        </div>
                    </div>
                `;
                const useBtn = document.getElementById("free-select-use");
                const cancelBtn = document.getElementById("free-select-cancel");
                if(useBtn) useBtn.onclick = () => {
                    const q = pendingQuote;
                    if(!Array.isArray(userState.selectionChosen)) userState.selectionChosen = [];
                    userState.selectionChosen.push(q);
                    ui._freeSelectPendingQuote = "";
                    app.save();
                    ui.renderSelection();
                };
                if(cancelBtn) cancelBtn.onclick = () => {
                    ui._freeSelectPendingQuote = "";
                    if(window.getSelection) window.getSelection().removeAllRanges();
                    ui.renderSelection();
                };
                return;
            }
            const textHtml = app.formatSourceHtml(sourceTextEarly);
            const targetMetLine = uniqueChosenCount >= targetCount ? `<p style="font-size:0.9rem; opacity:0.9; margin:0 0 8px 0;">You have enough quotes. Send to Sentence Builder when ready, or pick another quote from the text below.</p>` : `<p style="font-size:0.9rem; opacity:0.9; margin:0;">Tap and drag in the text below to highlight a quote. You will then be asked to confirm it supports your answer.</p>`;
            cont.innerHTML = `
                <div class="section-header">Quote Selection ‚Äî tap to select</div>
                ${questionText ? `<div class="card" style="margin-bottom:10px; padding:10px; background:rgba(0,150,136,0.06); border-left:4px solid var(--primary);"><div style="font-weight:700; font-size:0.85rem; margin-bottom:4px; opacity:0.9;">Question</div><div style="font-size:0.95rem;">${app.escapeHtml(questionText)}</div></div>` : ""}
                <div class="card" style="margin-bottom:10px;">
                    <div style="font-weight:700; margin-bottom:6px;">Selected quotes: ${uniqueChosenCount} / ${targetCount}</div>
                    ${targetMetLine}
                    ${uniqueChosenCount > 0 ? `<div style="margin-top:8px;"><button class="btn btn-primary btn-small" onclick="ui.sendSelectionQuotesToBuilder()">Send quotes to Sentence Builder</button></div>` : ""}
                </div>
                <div style="margin-bottom:6px;"><strong>Pick next quote from source text</strong></div>
                <div id="selection-free-select-source" class="guide-content" style="max-height:360px; overflow:auto; border:1px solid var(--border); border-radius:6px; padding:8px; background:var(--bg); user-select:text; -webkit-user-select:text;">${textHtml}</div>
            `;
            return;
        }
        const totalCorrect = correctItemsAll.length;
        const inSourceCorrect = correctItemsAll.filter(i => isInSource(i.quote)).length;
        const levelCorrect = correctItemsAll.filter(i => Array.isArray(i.levels) ? i.levels.includes(level) : false).length;
        const notChosenCorrect = correctItems.length;
        const debugLine = `<div style="font-size:0.8rem; opacity:0.7; margin-top:6px;">Debug: lvl=${level}, quoteTarget=${levelEntry.quoteTarget || ""}, distractors=${levelEntry.distractorCount || ""}, optionCount=${optionCount}, total=${totalCorrect}, inSource=${inSourceCorrect}, levelCorrect=${levelCorrect}, remaining=${notChosenCorrect}, chosen=${uniqueChosenCount}</div>`;
        const shortBy = Math.max(0, targetCount - (correctItems.length + uniqueChosenCount));
        const allowPartial = (sel.modes && sel.modes.allowPartial) || (appData.settings && appData.settings.allowPartialSelection) || shortBy <= 1;
        if(shortBy > 0 && allowPartial) {
            targetCount = Math.max(1, correctItems.length + uniqueChosenCount);
        }
        if((correctItems.length + uniqueChosenCount) < targetCount) {
            if(!allowPartial) {
                cont.innerHTML = `<div class="card" style="cursor:default;">
                    <div style="font-weight:800; font-size:1.1rem; margin-bottom:6px;">Not enough correct quotes</div>
                    <div style="opacity:0.8; margin-bottom:8px;">Target: ${targetCount} correct quotes. Remaining: ${correctItems.length}. Add more correct quotes in the Quote Selection Editor.</div>
                    ${debugLine}
                    <button class="btn btn-outline" onclick="ui.openAdmin()">Open Settings</button>
                </div>`;
                return;
            }
        }
        const primaryCorrect = correctItems[0] || sel.items[0];
        const validChosen = ui._selectionCorrectItem && Array.isArray(ui._selectionCorrectItem.levels)
            ? ui._selectionCorrectItem.levels.includes(level)
            : false;
        const chosenCorrect = validChosen ? ui._selectionCorrectItem : primaryCorrect;
        if(!validChosen) { ui._selectionCorrectItem = null; ui._selectionQuote = null; }
        const baseDistractors = Array.isArray(primaryCorrect.distractors) ? primaryCorrect.distractors : [];
        const tokenize = (text) => String(text || "")
            .toLowerCase()
            .replace(/[^a-z0-9\s]/g, " ")
            .split(/\s+/)
            .filter(w => w.length >= 5);
        const overlapScore = (a, b) => {
            const aSet = new Set(tokenize(a));
            const bSet = new Set(tokenize(b));
            let score = 0;
            aSet.forEach(w => { if(bSet.has(w)) score += 1; });
            return score;
        };
        const similarLength = (a, b) => {
            const aw = app.wordList(a).length;
            const bw = app.wordList(b).length;
            return Math.abs(aw - bw) <= 6;
        };
        const distractorItems = baseDistractors.map(d => ({ quote: d.quote, reason: d.reason, correct: false }))
            .filter(d => d.quote && isInSource(d.quote));
        const levelIncorrect = sel.items.filter(i => !i.correct && (Array.isArray(i.levels) ? i.levels.includes(level) : true))
            .filter(i => !i.device || selectionDevices[i.device] !== false);
        const incorrectItems = (levelIncorrect.length ? levelIncorrect : sel.items.filter(i => !i.correct))
            .map(i => ({ quote: i.quote, correct: false, item: i }))
            .filter(i => i.quote && isInSource(i.quote));
        const fallbackIncorrect = incorrectItems.length
            ? incorrectItems
            : distractorItems.map(d => ({ quote: d.quote, correct: false, item: { quote: d.quote, correct: false } }))
                .filter(i => i.quote);
        const eliminatedSet = new Set((userState.selectionEliminated || []).map(q => app.quoteKey(q)));
        const reasonMap = new Map();
        correctItems.forEach(i => {
            const r = Array.isArray(i.reasons) ? i.reasons.find(Boolean) : "";
            if(i.quote && r) reasonMap.set(app.quoteKey(i.quote), r);
        });
        incorrectItems.forEach(i => {
            const r = i.item && Array.isArray(i.item.reasons) ? i.item.reasons.find(Boolean) : "";
            if(i.quote && r) reasonMap.set(app.quoteKey(i.quote), r);
        });
        baseDistractors.forEach(d => {
            if(d && d.quote && d.reason && isInSource(d.quote)) reasonMap.set(app.quoteKey(d.quote), d.reason);
        });
        const otherCorrect = correctItems.filter(i => i !== primaryCorrect).map(i => ({ quote: i.quote, correct: true, item: i }));
        const distractorPool = distractorItems.map(d => ({ quote: d.quote, correct: false, item: { quote: d.quote, correct: false, reasons: [d.reason].filter(Boolean) } }));
        const lessonPool = (appData.items || [])
            .map(i => i && i.original)
            .filter(Boolean)
            .map(q => ({ quote: q, correct: false, item: { quote: q, correct: false } }));
        const buildPool = () => {
            const combined = [
                ...otherCorrect,
                ...fallbackIncorrect,
                ...distractorPool,
                ...lessonPool
            ].filter(o => o && o.quote && o.quote !== primaryCorrect.quote)
            .filter((o, idx, arr) => arr.findIndex(x => app.quoteKey(x.quote) === app.quoteKey(o.quote)) === idx);
            const scored = combined.map(o => ({
                item: o,
                score: overlapScore(primaryCorrect.quote, o.quote) + (similarLength(primaryCorrect.quote, o.quote) ? 1 : 0)
            }));
            scored.sort((a, b) => b.score - a.score);
            const best = scored.filter(s => s.score > 0).map(s => s.item);
            const rest = scored.filter(s => s.score === 0).map(s => s.item);
            return app.shuffle([...best, ...rest]);
        };
        const poolCandidates = buildPool();
        const options = app.shuffle([{ quote: primaryCorrect.quote, correct: true, item: primaryCorrect }, ...poolCandidates])
            .filter(o => o && o.quote)
            .filter((o, idx, arr) => arr.findIndex(x => app.quoteKey(x.quote) === app.quoteKey(o.quote)) === idx)
            .filter(o => !eliminatedSet.has(app.quoteKey(o.quote)) || o.correct)
            .slice(0, optionCount);
        const rawReasons = [...(chosenCorrect.reasons || []), ...distractorItems.map(d => d.reason).filter(Boolean)];
        const reasons = app.shuffle([...new Map(rawReasons.map(r => [String(r || "").trim().toLowerCase(), r])).values()].filter(Boolean));
        const textHtml = app.formatSourceHtml(sel.text && sel.text.source ? sel.text.source : appData.sourceText);
        const tier = app.getLanguageTier(level);
        const easy = tier === "low";
        const canJumpStages = !appData.isStandalone;
        const questionForChoice = sel.question && sel.question.prompt ? sel.question.prompt : appData.question || "";
        cont.innerHTML = `
            <div class="section-header" style="margin-top:0;">Quote Selection</div>
            ${questionForChoice ? `<div class="card" style="margin-bottom:10px; padding:10px; background:rgba(0,150,136,0.06); border-left:4px solid var(--primary);"><div style="font-weight:700; font-size:0.85rem; margin-bottom:4px; opacity:0.9;">Question</div><div style="font-size:0.95rem;">${app.escapeHtml(questionForChoice)}</div></div>` : ""}
            <div style="display:flex; gap:6px; flex-wrap:wrap; margin-bottom:10px;">
                ${stages.map((s, i)=>{
                    const label = ui.getStageLabel ? ui.getStageLabel(s) : s;
                    return canJumpStages
                    ? `<button class="stage-tag clickable" onclick="ui.setSelectionStage(${i+1})" style="border-color:${i+1===stageIndex?'var(--primary)':'var(--border)'}; background:${i+1===stageIndex?'rgba(0,150,136,0.12)':'rgba(0,0,0,0.04)'};">${i+1}. ${label}</button>`
                    : `<span class="stage-tag" style="border-color:${i+1===stageIndex?'var(--primary)':'var(--border)'}; background:${i+1===stageIndex?'rgba(0,150,136,0.12)':'rgba(0,0,0,0.04)'};">${i+1}. ${label}</span>`;
                }).join("")}
            </div>
            <div class="card" style="cursor:default; margin-bottom:10px;">
                <div style="font-weight:700; margin-bottom:6px;">Selected quotes: ${uniqueChosenCount} / ${targetCount}</div>
                <div id="selection-chosen-list" style="font-size:0.9rem; opacity:0.9;"></div>
                <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
                    <button class="btn btn-outline btn-small" id="selection-clear-chosen">Clear selected quotes</button>
                    <button class="btn btn-primary btn-small" id="selection-send-chosen" ${uniqueChosenCount ? "" : "disabled"}>Send quotes to Sentence Builder</button>
                </div>
            </div>
            <details class="card" style="cursor:default; margin-bottom:10px;">
                <summary style="font-weight:700;">Why quote choice matters</summary>
                <div style="margin-top:8px; font-size:0.9rem; opacity:0.9;">
                    Choosing evidence is like being a literary lawyer. You are not just picking a "good line" ‚Äî you are building a case.
                    The best quote must show how the writer uses ${app.getDeviceOptions().evidenceText} to support your exact claim.
                </div>
                <div style="margin-top:8px; font-size:0.9rem; opacity:0.9;">
                    Three skills:
                    <div>1) Signal vs. noise: does it show writer's craft, or just plot?</div>
                <div>2) Length: is the quote the right length (not too short, not too long)?</div>
                    <div>3) Alignment: does it answer the question you were asked?</div>
                </div>
                <div style="margin-top:8px; font-size:0.9rem; opacity:0.9;">
                    Three‚Äëstep check: mirror the prompt words, zoom in on a key word in the quote, and explain why the author chose that wording.
                </div>
            </details>
            <div class="builder-area">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                    <strong>Source Text</strong>
                    <button class="btn btn-outline btn-small" onclick="ui.openModal('modal-source')">Open Full Text</button>
                </div>
                <div class="guide-content" style="max-height:360px; overflow:auto; border:1px solid var(--border); border-radius:6px; padding:8px; background:var(--bg); margin-bottom:10px;">${textHtml}</div>
                <div id="selection-body"></div>
            </div>
        `;
        const body = cont.querySelector("#selection-body");
        const chosenListEl = cont.querySelector("#selection-chosen-list");
        if(chosenListEl) {
            if(!chosenList.length) {
                chosenListEl.innerHTML = `<div style="opacity:0.7;">No quotes selected yet.</div>`;
            } else {
                const editBtnHtml = !appData.isStandalone
                    ? (quote => {
                        const qEsc = String(quote || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'");
                        return `<button type="button" class="card-edit-btn" onclick="event.stopPropagation(); ui.openAdminToQuoteOrSelection('${qEsc}', null)" title="Edit quote" style="flex-shrink:0; padding:4px 6px;">‚úèÔ∏è</button>`;
                    })
                    : () => "";
                chosenListEl.innerHTML = chosenList.map((q, i) => `
                    <div style="margin-bottom:6px; display:flex; gap:8px; align-items:center;">
                        ${typeof editBtnHtml === "function" ? editBtnHtml(q) : ""}
                        <span class="quote-picked" style="flex:1;">"${app.escapeHtml(q)}"</span>
                        <button class="btn btn-outline btn-small" data-remove="${i}">Remove</button>
                    </div>
                `).join("");
                Array.from(chosenListEl.querySelectorAll("button[data-remove]")).forEach(btn => {
                    btn.onclick = () => {
                        const idx = parseInt(btn.dataset.remove, 10);
                        if(!isNaN(idx)) {
                            userState.selectionChosen.splice(idx, 1);
                            app.save();
                            ui.renderSelection();
                        }
                    };
                });
            }
        }
        const clearBtn = cont.querySelector("#selection-clear-chosen");
        if(clearBtn) {
            clearBtn.onclick = () => {
                userState.selectionChosen = [];
                userState.deskQueue = [];
                app.save();
                ui.renderSelection();
            };
        }
        const sendBtn = cont.querySelector("#selection-send-chosen");
        if(sendBtn) {
            sendBtn.onclick = () => ui.sendSelectionQuotesToBuilder();
        }
        if(options.length < 2) {
            body.innerHTML = `<div class="card" style="cursor:default;">
                <div style="font-weight:800; font-size:1.05rem; margin-bottom:6px;">Not enough choices</div>
                <div style="opacity:0.8;">Add more distractors or correct quotes in the editor.</div>
            </div>`;
            return;
        }
        if(stageKey === "discriminate") {
            const pool = app.shuffle([
                ...correctItems.map(i => ({ quote: i.quote, correct: true, item: i })),
                ...fallbackIncorrect.map(i => ({ quote: i.quote, correct: false, item: i.item || i })),
                ...distractorPool
            ])
                .filter(o => o && o.quote)
                .filter((o, idx, arr) => arr.findIndex(x => app.quoteKey(x.quote) === app.quoteKey(o.quote)) === idx)
                .slice(0, optionCount);
            userState.selectionProgress.discriminate = userState.selectionProgress.discriminate || {};
            if(pool.length < 2) {
                body.innerHTML = `<div style="font-weight:700; margin-bottom:6px;">Choose the best quote for the question.</div>
                    <div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">Not enough choices yet. Add more correct quotes or distractors for this level.</div>
                    <button class="btn btn-outline" onclick="ui.openAdmin()">Open Settings</button>
                    <button class="btn btn-primary" id="selection-continue" style="margin-top:8px;">Continue</button>`;
                const continueBtn = body.querySelector("#selection-continue");
                if(continueBtn) {
                    continueBtn.onclick = () => {
                        userState.selectionStage = stageIndex + 1;
                        app.save();
                        ui.renderSelection();
                    };
                }
                return;
            }
            body.innerHTML = `<div style="font-weight:700; margin-bottom:6px;">Choose the best quote for the question.</div>
                <div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">${easy
                    ? 'Choose "Strong" if it answers the question. Choose "Not strong" if it is just what happened.'
                    : 'Choose "Strong" if it answers the question, or "Not strong" if it is mostly plot/detail.'}</div>
                <div class="grid" id="selection-quotes"></div>
                <div style="margin-top:10px;"><button class="btn btn-primary" id="selection-continue" disabled>Continue</button></div>`;
            const grid = body.querySelector("#selection-quotes");
            const continueBtn = body.querySelector("#selection-continue");
            pool.forEach(o => {
                const card = document.createElement("div");
                card.className = "card card-select-quote";
                card.style.position = "relative";
                const qEsc = String(o.quote || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/</g, "\\u003c");
                const editBtnHtml = !appData.isStandalone ? `<button type="button" class="card-edit-btn" onclick="event.stopPropagation(); ui.openAdminToQuoteOrSelection('${qEsc}', null)" title="Edit quote">‚úèÔ∏è</button>` : "";
                card.innerHTML = `${editBtnHtml}<div class="quote-text">"${app.escapeHtml(o.quote || "")}"</div>
                    <div style="display:flex; gap:6px; margin-top:8px;">
                        <button class="btn btn-outline btn-small">Strong</button>
                        <button class="btn btn-outline btn-small">Not strong</button>
                    </div>
                    <div class="card-meta" style="margin-top:6px;"><span></span></div>`;
                const [yesBtn, noBtn] = card.querySelectorAll("button.btn");
                const meta = card.querySelector(".card-meta span");
                const key = o.quote;
                const update = (choice) => {
                    if(!userState.selectionProgress || typeof userState.selectionProgress !== "object") {
                        userState.selectionProgress = {};
                    }
                    if(!userState.selectionProgress.discriminate || typeof userState.selectionProgress.discriminate !== "object") {
                        userState.selectionProgress.discriminate = {};
                    }
                    const correct = o.correct ? "analysis" : "noise";
                    userState.selectionProgress.discriminate[key] = choice;
                    let reasonRaw = reasonMap.get(app.quoteKey(o.quote)) || (o.correct
                        ? `Good choice: it shows the writer's ${app.getDeviceOptions().evidenceText}.`
                        : "Not strong: this is mostly what happened.");
                    if(!o.correct && (/weaker\s*choice|^weak\s*\d*$/i.test(String(reasonRaw).trim()))) reasonRaw = "This quote doesn't support the answer as well.";
                    const reason = app.simplifyText(reasonRaw, tier);
                    if(choice === correct) {
                        meta.textContent = `‚úÖ ${reason}`;
                        card.classList.remove("quote-dim");
                    } else {
                        meta.textContent = `‚ö†Ô∏è Try again: ${reason}`;
                        card.classList.add("quote-dim");
                        userState.selectionEliminated = Array.from(new Set([...(userState.selectionEliminated || []), o.quote]));
                    }
                    if(pool.length <= 2 && o.correct) {
                        pool.forEach(p => {
                            if(p.quote !== o.quote && !userState.selectionProgress.discriminate[p.quote]) {
                                userState.selectionProgress.discriminate[p.quote] = "noise";
                            }
                        });
                    }
                    app.save();
                    const done = pool.every(p => userState.selectionProgress.discriminate[p.quote]);
                    const allCorrect = done && pool.every(p => {
                        const c = userState.selectionProgress.discriminate[p.quote];
                        return (p.correct && c === "analysis") || (!p.correct && c === "noise");
                    });
                    if(continueBtn) {
                        continueBtn.disabled = !done;
                        continueBtn.textContent = !done
                            ? "Finish all choices to continue"
                            : (allCorrect ? "Continue" : "Continue (some incorrect)");
                    }
                };
                yesBtn.onclick = () => update("analysis");
                noBtn.onclick = () => update("noise");
                grid.appendChild(card);
            });
            if(continueBtn) {
                continueBtn.onclick = () => {
                    userState.selectionStage = stageIndex + 1;
                    app.save();
                    ui.renderSelection();
                };
            }
            return;
        }
        if(stageKey === "boundary") {
            const boundary = app.makeBoundaryChoices(chosenCorrect.quote);
            if(boundary.tooShort || boundary.options.length < 2) {
                userState.selectionStage = stageIndex + 1;
                app.save();
                ui.renderSelection();
                return;
            }
            body.innerHTML = `<div style="font-weight:700; margin-bottom:6px;">Pick the best length.</div>
                <div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">${easy
                    ? "Pick the one that is not too short and not too long."
                    : "Avoid too long or too short."}</div>
                <div class="grid" id="selection-quotes"></div>`;
            const grid = body.querySelector("#selection-quotes");
            boundary.options.forEach(q => {
                const btn = document.createElement("button");
                btn.className = "btn btn-outline";
                btn.textContent = `"${q}"`;
                btn.onclick = () => {
                    if(q === boundary.correct) {
                        btn.style.background = "var(--success)";
                        btn.style.color = "white";
                        userState.selectionStage = stageIndex + 1;
                        app.save();
                        ui.renderSelection();
                    } else if(sel.modes.showHints) {
                        btn.classList.add("shake");
                        btn.classList.add("quote-dim");
                    }
                };
                grid.appendChild(btn);
            });
            return;
        }
        if(stageKey === "align") {
            const deviceInfo = app.getDeviceOptions();
            const deviceOptions = deviceInfo.options;
            const deviceLabels = deviceInfo.labels;
            const deviceLabelText = deviceInfo.labelText;
            const storedKey = `${level}:${stageKey}`;
            userState.selectionProgress.freeText = userState.selectionProgress.freeText || {};
            userState.selectionProgress.alignDone = userState.selectionProgress.alignDone || {};
            if(!userState.selectionProgress.alignDone[level]) {
                userState.selectionProgress.alignDone[level] = {};
            }
            const alignDone = userState.selectionProgress.alignDone[level];
            userState.selectionProgress.alignIndex = userState.selectionProgress.alignIndex || {};
            if(typeof userState.selectionProgress.alignIndex[level] !== "number") {
                userState.selectionProgress.alignIndex[level] = 0;
            }
            const alignIndex = userState.selectionProgress.alignIndex[level];
            const alignPool = correctItems.filter(i => i.quote);
            const alignCandidates = alignPool.filter(i => !alignDone[app.quoteKey(i.quote)]);
            const alignCorrect = alignCandidates.length
                ? alignCandidates[0]
                : (alignPool.length ? alignPool[alignIndex % alignPool.length] : (correctItems[0] || chosenCorrect));
            if(stageMode === "free") {
                const existing = userState.selectionProgress.freeText[storedKey] || "";
                const freeAlignEditBtn = !appData.isStandalone && alignCorrect && alignCorrect.quote
                    ? `<button type="button" class="card-edit-btn" onclick="event.stopPropagation(); ui.openAdminToQuoteOrSelection('${String(alignCorrect.quote || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'")}', null)" title="Edit quote" style="position:absolute;top:8px;right:8px;">‚úèÔ∏è</button>`
                    : "";
                body.innerHTML = `<div style="font-weight:700; margin-bottom:6px;">${deviceLabelText}</div>
                    <div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">Which category best fits this quote, and why? Use the question and key words to explain.</div>
                    <div class="card card-select-quote" style="cursor:default; margin-bottom:8px; position:relative;">${freeAlignEditBtn}<div class="quote-text">"${app.escapeHtml(alignCorrect.quote)}"</div></div>
                    ${alignCorrect && alignCorrect.device === "structure" ? `<div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">If this is structure, consider: ${structurePrompts.map(p=>`<span class="bank-tag">${app.escapeHtml(p)}</span>`).join(" ")}</div>` : ""}
                    <textarea id="selection-free-align" style="height:90px; width:100%; margin-bottom:8px;" placeholder="Write your answer...">${app.escapeHtml(existing)}</textarea>
                    <button class="btn btn-primary" id="selection-free-align-next">Continue</button>`;
                const box = body.querySelector("#selection-free-align");
                const btn = body.querySelector("#selection-free-align-next");
                if(box) {
                    box.addEventListener("input", () => {
                        userState.selectionProgress.freeText[storedKey] = box.value;
                        app.save();
                    });
                }
                if(btn) {
                    btn.onclick = () => {
                        if(alignCorrect && alignCorrect.quote) {
                            alignDone[app.quoteKey(alignCorrect.quote)] = true;
                            ui._selectionCorrectItem = alignCorrect;
                            ui._selectionQuote = alignCorrect.quote;
                            userState.selectionProgress.alignIndex[level] = (userState.selectionProgress.alignIndex[level] + 1) || 1;
                        }
                        userState.selectionStage = stageIndex + 1;
                        app.save();
                        ui.renderSelection();
                    };
                }
                return;
            }
            const correctDevice = (alignCorrect && alignCorrect.device) ? alignCorrect.device : "";
            if(!correctDevice) {
                body.innerHTML = `<div style="font-weight:700; margin-bottom:6px;">${deviceLabelText}</div>
                    <div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">Set the device for this quote in the Quote Selection Editor to use this stage.</div>
                    <button class="btn btn-outline" onclick="ui.openAdmin()">Open Settings</button>`;
                return;
            }
            userState.selectionProgress.align = userState.selectionProgress.align || {};
            const questionText = sel.question && sel.question.prompt ? sel.question.prompt : (appData.question || "");
            const structurePrompts = Array.isArray(sel.structurePrompts) && sel.structurePrompts.length
                ? sel.structurePrompts
                : [
                    "Paragraphing (shift in topic, time, place, or perspective)",
                    "Time/Sequence (linear, flashback, jump forward)",
                    "Focus/Zoom (zoom in or out)",
                    "Introduction/Placement (start, middle, end positioning)",
                    "Repetition/Return (return to an idea or image)",
                    "Circular structure (ending mirrors the beginning)",
                    "Juxtaposition (contrasting ideas placed together)"
                ];
            const alignEditBtn = !appData.isStandalone && alignCorrect && alignCorrect.quote
                ? `<button type="button" class="card-edit-btn" onclick="event.stopPropagation(); ui.openAdminToQuoteOrSelection('${String(alignCorrect.quote || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'")}', null)" title="Edit quote" style="position:absolute;top:8px;right:8px;">‚úèÔ∏è</button>`
                : "";
            body.innerHTML = `<div style="font-weight:700; margin-bottom:6px;">${deviceLabelText}</div>
                <div class="card card-select-quote" style="cursor:default; margin-bottom:8px; position:relative;">${alignEditBtn}<div class="quote-text">"${app.escapeHtml(alignCorrect.quote)}"</div></div>
                <div style="font-size:0.85rem; opacity:0.7; margin-bottom:6px;"><strong>Question:</strong> ${app.escapeHtml(questionText)}</div>
                ${correctDevice === "structure" ? `<div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">Structure prompts: ${structurePrompts.map(p=>`<span class="bank-tag">${app.escapeHtml(p)}</span>`).join(" ")}</div>` : ""}
                <div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">Which category best matches this quote?</div>
                <div style="display:flex; gap:8px; flex-wrap:wrap;" id="selection-device-options"></div>
                <div id="selection-device-feedback" style="margin-top:8px; font-size:0.85rem; opacity:0.8;"></div>
                <div style="margin-top:10px;"><button class="btn btn-primary" id="selection-device-next" disabled>Continue</button></div>`;
            const wrap = body.querySelector("#selection-device-options");
            const feedback = body.querySelector("#selection-device-feedback");
            const nextBtn = body.querySelector("#selection-device-next");
            deviceOptions.forEach(opt => {
                const btn = document.createElement("button");
                btn.className = "btn btn-outline btn-small";
                btn.textContent = deviceLabels[opt];
                btn.onclick = () => {
                    userState.selectionProgress.align[storedKey] = opt;
                    const isCorrect = opt === correctDevice;
                    if(isCorrect) {
                        btn.style.background = "var(--success)";
                        btn.style.color = "white";
                        if(feedback) {
                            const reason = alignCorrect.deviceReason || "Good choice. This category matches how the quote supports the question.";
                            feedback.textContent = reason;
                        }
                        if(nextBtn) nextBtn.disabled = false;
                    } else {
                        if(feedback) feedback.textContent = `Try again. Think about whether the wording shows ${deviceInfo.listText}.`;
                        if(sel.modes.showHints) btn.classList.add("shake");
                    }
                    app.save();
                };
                wrap.appendChild(btn);
            });
            if(nextBtn) {
                nextBtn.onclick = () => {
                    if(alignCorrect && alignCorrect.quote) {
                        alignDone[app.quoteKey(alignCorrect.quote)] = true;
                        ui._selectionCorrectItem = alignCorrect;
                        ui._selectionQuote = alignCorrect.quote;
                        userState.selectionProgress.alignIndex[level] = (userState.selectionProgress.alignIndex[level] + 1) || 1;
                    }
                    userState.selectionStage = stageIndex + 1;
                    app.save();
                    ui.renderSelection();
                };
            }
            return;
        }
        if(stageKey === "recognize") {
            body.innerHTML = `<div style="font-weight:700; margin-bottom:6px;">Pick the best quote.</div>
                <div class="grid" id="selection-quotes"></div>
                <button class="btn btn-outline" id="selection-reveal">Reveal best quote</button>`;
            const grid = body.querySelector("#selection-quotes");
            const recogOptions = app.shuffle(options).slice(0, optionCount);
            recogOptions.forEach(o => {
                const btn = document.createElement("button");
                btn.className = "btn btn-outline";
                btn.textContent = `"${o.quote}"`;
                if(chosenSet.has(app.quoteKey(o.quote))) btn.classList.add("quote-picked");
                btn.onclick = () => {
                    if(o.correct) { btn.style.background = "var(--success)"; btn.style.color = "white"; btn.classList.add("quote-picked"); }
                    else if(sel.modes.showHints) { btn.classList.add("shake"); btn.classList.add("quote-dim"); }
                };
                grid.appendChild(btn);
            });
            body.querySelector("#selection-reveal").onclick = () => {
                ui._selectionQuote = primaryCorrect.quote;
                ui._selectionCorrectItem = primaryCorrect;
                userState.selectionStage = stageIndex + 1;
                app.save();
                ui.renderSelection();
            };
            return;
        }
        if(stageKey === "guided") {
            body.innerHTML = `<div style="font-weight:700; margin-bottom:6px;">Pick the best quote:</div>
                <div class="grid" id="selection-quotes"></div>`;
            const grid = body.querySelector("#selection-quotes");
            const baseOptions = sel.modes && sel.modes.correctOnly
                ? options.filter(o => o.correct)
                : options;
            const guidedOptions = app.shuffle(baseOptions).slice(0, optionCount);
            guidedOptions.forEach(o => {
                const btn = document.createElement("button");
                btn.className = "btn btn-outline";
                btn.textContent = `"${o.quote}"`;
                if(chosenSet.has(app.quoteKey(o.quote))) btn.classList.add("quote-picked");
                btn.onclick = () => {
                    if(o.correct) {
                        btn.style.background = "var(--success)";
                        btn.style.color = "white";
                        btn.classList.add("quote-picked");
                        ui._selectionQuote = o.quote;
                        ui._selectionCorrectItem = o.item || primaryCorrect;
                        const addChosenAndMaybeAdvance = () => {
                            const quoteToAdd = o.quote || "";
                            const chosenKeys = new Set((userState.selectionChosen || []).map(q => app.quoteKey(q)));
                            if(quoteToAdd && !chosenKeys.has(app.quoteKey(quoteToAdd))) {
                                userState.selectionChosen.push(quoteToAdd);
                            }
                            const uniqueCount = new Set((userState.selectionChosen || []).map(q => app.quoteKey(q))).size;
                            if(uniqueCount >= targetCount) {
                                userState.selectionCompleted = true;
                                app.save();
                                ui.sendSelectionQuotesToBuilder();
                                return;
                            }
                            userState.selectionCompleted = false;
                            if(stages.includes("align")) {
                                userState.selectionStage = stages.indexOf("align") + 1;
                            } else if(stages.includes("guided")) {
                                userState.selectionStage = stages.indexOf("guided") + 1;
                            } else if(stages.includes("recognize")) {
                                userState.selectionStage = stages.indexOf("recognize") + 1;
                            }
                            app.save();
                            ui.showSelectionMessage("Well done!", "Quote saved. Pick your next quote.");
                            ui.renderSelection();
                        };
                        if(sel.modes.requireReason && stages.includes("justify")) {
                            userState.selectionStage = stages.indexOf("justify") + 1;
                        } else if(stages.includes("open")) {
                            userState.selectionStage = stages.indexOf("open") + 1;
                        } else {
                            addChosenAndMaybeAdvance();
                            return;
                        }
                        app.save();
                        ui.renderSelection();
                    } else if(sel.modes.showHints) {
                        btn.classList.add("shake");
                        btn.classList.add("quote-dim");
                    }
                };
                grid.appendChild(btn);
            });
            return;
        }
        if(stageKey === "justify") {
            const level = app.getEffectiveLevel();
            const tier = app.getLanguageTier(level);
            const easy = tier === "low";
            if(stageMode === "free") {
                const storedKey = `${level}:${stageKey}`;
                userState.selectionProgress.freeText = userState.selectionProgress.freeText || {};
                const existing = userState.selectionProgress.freeText[storedKey] || "";
                const structurePrompts = Array.isArray(sel.structurePrompts) && sel.structurePrompts.length
                    ? sel.structurePrompts
                    : [
                        "Paragraphing (shift in topic, time, place, or perspective)",
                        "Time/Sequence (linear, flashback, jump forward)",
                        "Focus/Zoom (zoom in or out)",
                        "Introduction/Placement (start, middle, end positioning)",
                        "Repetition/Return (return to an idea or image)",
                        "Circular structure (ending mirrors the beginning)",
                        "Juxtaposition (contrasting ideas placed together)"
                    ];
                const freeJustifyEditBtn = !appData.isStandalone && chosenCorrect && chosenCorrect.quote
                    ? `<button type="button" class="card-edit-btn" onclick="event.stopPropagation(); ui.openAdminToQuoteOrSelection('${String(chosenCorrect.quote || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'")}', null)" title="Edit quote" style="position:absolute;top:8px;right:8px;">‚úèÔ∏è</button>`
                    : "";
                body.innerHTML = `<div style="font-weight:700; margin-bottom:6px;">Justify</div>
                    <div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">Does the quote answer the question? How does it do so? Identify key words or phrases that prove it.</div>
                    <div class="card card-select-quote" style="cursor:default; margin-bottom:10px; position:relative;">${freeJustifyEditBtn}
                        <div style="font-weight:700; margin-bottom:6px;">Your chosen quote</div>
                        <div class="quote-text">"${app.escapeHtml(chosenCorrect && chosenCorrect.quote ? chosenCorrect.quote : "")}"</div>
                    </div>
                    ${chosenCorrect && chosenCorrect.device === "structure" ? `<div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">If structure is involved, consider: ${structurePrompts.map(p=>`<span class="bank-tag">${app.escapeHtml(p)}</span>`).join(" ")}</div>` : ""}
                    <textarea id="selection-free-justify" style="height:110px; width:100%; margin-bottom:8px;" placeholder="Write your justification...">${app.escapeHtml(existing)}</textarea>
                    <button class="btn btn-primary" id="selection-free-justify-next">Continue</button>`;
                const box = body.querySelector("#selection-free-justify");
                const btn = body.querySelector("#selection-free-justify-next");
                if(box) {
                    box.addEventListener("input", () => {
                        userState.selectionProgress.freeText[storedKey] = box.value;
                        app.save();
                    });
                }
                if(btn) {
                    btn.onclick = () => {
                        const quoteToAdd = chosenCorrect && chosenCorrect.quote ? chosenCorrect.quote : "";
                        const chosenKeys = new Set((userState.selectionChosen || []).map(q => app.quoteKey(q)));
                        if(quoteToAdd && !chosenKeys.has(app.quoteKey(quoteToAdd))) {
                            userState.selectionChosen.push(quoteToAdd);
                        }
                        const uniqueCount = new Set((userState.selectionChosen || []).map(q => app.quoteKey(q))).size;
                        if(uniqueCount >= targetCount) {
                            userState.selectionCompleted = true;
                            app.save();
                            ui.sendSelectionQuotesToBuilder();
                            return;
                        }
                        userState.selectionCompleted = false;
                        userState.selectionStage = stages.includes("guided") ? (stages.indexOf("guided") + 1) : 1;
                        if(stages.includes("align")) {
                            userState.selectionStage = stages.indexOf("align") + 1;
                        } else if(stages.includes("guided")) {
                            userState.selectionStage = stages.indexOf("guided") + 1;
                        } else if(stages.includes("recognize")) {
                            userState.selectionStage = stages.indexOf("recognize") + 1;
                        }
                        app.save();
                        ui.showSelectionMessage("Well done!", "Quote saved. Pick your next quote.");
                        ui.renderSelection();
                    };
                }
                return;
            }
            const justifyTitle = "Justify";
            const justifyHelp = easy
                ? "Choose the reason that shows how this quote answers the question."
                : "Choose the reason that best explains how this quote answers the question.";
            const justifyPurpose = easy
                ? "This reason goes into your sentence."
                : "This reason will be used in your sentence.";
            const justifyEditBtn = !appData.isStandalone && chosenCorrect && chosenCorrect.quote
                ? `<button type="button" class="card-edit-btn" onclick="event.stopPropagation(); ui.openAdminToQuoteOrSelection('${String(chosenCorrect.quote || "").replace(/\\/g, "\\\\").replace(/'/g, "\\'")}', null)" title="Edit quote" style="position:absolute;top:8px;right:8px;">‚úèÔ∏è</button>`
                : "";
            body.innerHTML = `<div style="font-weight:700; margin-bottom:6px;">${justifyTitle}</div>
                <div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">${justifyHelp}</div>
                <div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">${justifyPurpose}</div>
                <div class="card card-select-quote" style="cursor:default; margin-bottom:10px; position:relative;">${justifyEditBtn}
                    <div style="font-weight:700; margin-bottom:6px;">Your chosen quote</div>
                    <div class="quote-text">"${app.escapeHtml(chosenCorrect && chosenCorrect.quote ? chosenCorrect.quote : "")}"</div>
                </div>`;
            reasons.forEach(r => {
                const rb = document.createElement("button");
                rb.className = "btn btn-outline";
                rb.dataset.reason = r;
                rb.textContent = app.simplifyText(r, tier);
                rb.onclick = () => {
                    if((chosenCorrect.reasons || []).includes(rb.dataset.reason)) {
                        rb.style.background = "var(--success)";
                        rb.style.color = "white";
                        const quoteToAdd = chosenCorrect && chosenCorrect.quote ? chosenCorrect.quote : "";
                        const chosenKeys = new Set((userState.selectionChosen || []).map(q => app.quoteKey(q)));
                        if(quoteToAdd && !chosenKeys.has(app.quoteKey(quoteToAdd))) {
                            userState.selectionChosen.push(quoteToAdd);
                        }
                        const uniqueCount = new Set((userState.selectionChosen || []).map(q => app.quoteKey(q))).size;
                        if(uniqueCount >= targetCount) {
                            userState.selectionCompleted = true;
                            app.save();
                            ui.sendSelectionQuotesToBuilder();
                            return;
                        }
                        userState.selectionCompleted = false;
                        userState.selectionStage = stages.includes("guided") ? (stages.indexOf("guided") + 1) : 1;
                        if(stages.includes("align")) {
                            userState.selectionStage = stages.indexOf("align") + 1;
                        } else if(stages.includes("guided")) {
                            userState.selectionStage = stages.indexOf("guided") + 1;
                        } else if(stages.includes("recognize")) {
                            userState.selectionStage = stages.indexOf("recognize") + 1;
                        }
                        app.save();
                        ui.showSelectionMessage("Well done!", "Quote saved. Pick your next quote.");
                        ui.renderSelection();
                    } else if(sel.modes.showHints) {
                        rb.classList.add("shake");
                    }
                };
                body.appendChild(rb);
            });
            return;
        }
        if(stageKey === "open") {
            body.innerHTML = `<div style="font-weight:700; margin-bottom:6px;">You already selected your quotes.</div>
                <div style="font-size:0.85rem; opacity:0.7; margin-bottom:8px;">Use the selected quotes box above to review and send them to the Sentence Builder.</div>`;
            return;
        }
    },
    useSelectionQuote: function() {
        const q = ui._selectionQuote;
        if(!q) return;
        const item = ui.ensureQuoteItem(q);
        if(!item) return alert("No matching quote found in this lesson.");
        userState.selectionCompleted = true;
        app.save();
        if(appData.settings.modulesActive.lab) {
            ui.switchView("lab");
            ui.startWizard(item);
        } else if(appData.settings.modulesActive.desk) {
            ui.switchView("desk");
            ui.runBuilder(item);
        }
    },
    ensureQuoteItem: function(q) {
        const trimmed = String(q || "").trim();
        if(!trimmed) return null;
        let item = appData.items.find(i => i.original === trimmed);
        if(!item) item = appData.items.find(i => i.original && trimmed && i.original.includes(trimmed));
        const selItems = appData.selection && Array.isArray(appData.selection.items) ? appData.selection.items : [];
        const selItem = selItems.find(i => i && i.quote === trimmed)
            || selItems.find(i => i && i.quote && trimmed && i.quote.includes(trimmed))
            || selItems.find(i => i && i.quote && trimmed && trimmed.includes(i.quote));
        const starterOptionsByDevice = (device) => {
            if(device === "tone") {
                return [
                    "The writer admiringly uses the phrase",
                    "The writer approvingly uses the phrase",
                    "The writer positively presents the phrase",
                    "The writer celebrates the phrase"
                ];
            }
            if(device === "structure") {
                return [
                    "The writer structures the text by stating",
                    "The writer signals a shift by stating",
                    "The writer organises the text by stating",
                    "The writer moves the narrative on by stating"
                ];
            }
            return [
                "The writer uses the phrase",
                "The writer presents the scene as",
                "The writer portrays the moment as",
                "The writer describes the moment as"
            ];
        };
        const pickStarter = (device, bankStarters) => {
            const base = starterOptionsByDevice(device);
            const extras = bankStarters.map(v => v.trim()).filter(Boolean);
            const pool = [...base, ...extras].filter(Boolean);
            const unique = Array.from(new Set(pool));
            const correct = unique[0] || "The writer uses the phrase";
            const distractors = app.shuffle(unique.filter(v => v !== correct)).slice(0, 3);
            return { correct, distractors };
        };
        const normalizeEffect = (raw) => {
            if(!raw) return "";
            let txt = String(raw).trim();
            if(!txt) return "";
            txt = txt.replace(/\.$/, "");
            txt = txt.replace(/^(this|it)\s+(shows|suggests|implies|indicates|reveals|demonstrates)\s+(that\s+)?/i, "");
            const smoothNounPhrase = (phrase) => {
                const p = String(phrase || "").trim();
                if(!p) return p;
                if(/^skill\b/i.test(p)) return `his ${p}`;
                if(/^agility\b/i.test(p)) return `his ${p}`;
                if(/^confidence\b/i.test(p)) return `his ${p}`;
                if(/^control\b/i.test(p)) return `his ${p}`;
                return p;
            };
            const nounifyVerb = (verb, rest) => {
                const r = smoothNounPhrase(rest);
                const v = verb.toLowerCase();
                if(v === "uses" || v === "use") return `the use of ${r}`;
                if(v === "shows" || v === "show") return `the showing of ${r}`;
                if(v === "demonstrates" || v === "demonstrate") return `the demonstration of ${r}`;
                if(v === "highlights" || v === "highlight") return `the highlighting of ${r}`;
                if(v === "emphasises" || v === "emphasizes" || v === "emphasise" || v === "emphasize") return `the emphasis on ${r}`;
                if(v === "conveys" || v === "convey") return `the conveying of ${r}`;
                if(v === "suggests" || v === "suggest") return `the suggestion of ${r}`;
                if(v === "reveals" || v === "reveal") return `the revelation of ${r}`;
                if(v === "reflects" || v === "reflect") return `the reflection of ${r}`;
                if(v === "creates" || v === "create") return `the creation of ${r}`;
                if(v === "evokes" || v === "evoke") return `the evocation of ${r}`;
                if(v === "portrays" || v === "portray") return `the portrayal of ${r}`;
                if(v === "indicates" || v === "indicate") return `the indication of ${r}`;
                if(v === "focuses" || v === "focus") {
                    const cleaned = r.replace(/^on\s+/i, "");
                    return `the focus on ${cleaned}`;
                }
                if(v === "builds" || v === "build") return `the building of ${r}`;
                return `the ${v} of ${r}`;
            };
            const writerVerb = txt.match(/^the writer\s+([a-z]+)\s+(.*)$/i);
            if(writerVerb && writerVerb[2]) {
                const rest = writerVerb[2].trim();
                return `the writer's ${nounifyVerb(writerVerb[1], rest).replace(/^the\s+/i, "")}`;
            }
            const leadingVerb = txt.match(/^([a-z]+)\s+(.*)$/i);
            if(leadingVerb && leadingVerb[2]) {
                return nounifyVerb(leadingVerb[1], leadingVerb[2].trim());
            }
            const verbStarters = [
                "uses","use","shows","show","demonstrates","demonstrate","highlights","highlight",
                "emphasises","emphasizes","conveys","suggests","suggest","reveals","reflects",
                "creates","evokes","portrays","indicates","focuses","focus","builds","build"
            ];
            const lower = txt.toLowerCase();
            const startsWithVerb = verbStarters.some(v => lower.startsWith(v + " "));
            if(startsWithVerb) {
                const lowered = txt.charAt(0).toLowerCase() + txt.slice(1);
                return `the writer ${lowered}`;
            }
            return txt.charAt(0).toLowerCase() + txt.slice(1);
        };
        const linkOptionsByTier = (tier) => {
            if(tier === "low") return ["This shows that", "This shows", "This means that", "This tells us that"];
            if(tier === "medium") return ["This suggests that", "This shows that", "This indicates that", "This creates"];
            return ["This implies that", "This suggests that", "This highlights", "This establishes"];
        };
        const pickLinkForPoint = (point, level) => {
            const tier = app.getLanguageTier(level);
            const p = String(point || "").trim().toLowerCase();
            const options = linkOptionsByTier(tier);
            if(!p) return options[0];
            if(p.startsWith("the writer ")) return options.find(v => !/that$/i.test(v)) || options[0];
            if(p.startsWith("a ") || p.startsWith("an ") || p.startsWith("the ")) return options.find(v => !/that$/i.test(v)) || options[0];
            if(p.startsWith("using ") || p.startsWith("showing ") || p.startsWith("highlighting ") || p.startsWith("emphasising ") || p.startsWith("emphasizing ")) {
                return options.find(v => !/that$/i.test(v)) || options[0];
            }
            return options[0];
        };
        const tuneLinkPoint = (linkText, pointText) => {
            let link = String(linkText || "").trim();
            let point = String(pointText || "").trim();
            if(!point) return { link, point };
            if(/^that\s+/i.test(point)) {
                point = point.replace(/^that\s+/i, "");
                link = link.replace(/\s+that\s*$/i, "");
            }
            if(/to\s*$/i.test(link)) {
                point = point.replace(/^to\s+/i, "");
            }
            if(/creates$/i.test(link) && !/^a\s|^an\s|^the\s/i.test(point)) {
                link = "This shows that";
            }
            return { link: link.trim(), point: point.trim() };
        };
        const buildSelectionDefaults = () => {
            const reasons = selItem && Array.isArray(selItem.reasons) ? selItem.reasons.filter(Boolean) : [];
            const distractorReasons = selItem && Array.isArray(selItem.distractors)
                ? selItem.distractors.map(d => d && d.reason).filter(Boolean)
                : [];
            const device = selItem && selItem.device ? String(selItem.device).toLowerCase() : "language";
            const effectRaw = (selItem && selItem.deviceReason) || reasons[1] || reasons[0] || "";
            const effect = normalizeEffect(effectRaw);
            // Use device-specific starter pool only to avoid old-lesson bleed.
            const pickedStarter = pickStarter(device, []);
            const starter = pickedStarter.correct;
            const starterDistractors = pickedStarter.distractors;
            const tempLevel = admin.getItemLevel({ levels: (selItem && selItem.levels) ? selItem.levels : [1] });
            const tuned = tuneLinkPoint(pickLinkForPoint(effect, tempLevel), effect);
            const link = tuned.link;
            const tunedEffect = tuned.point;
            const linkPool = linkOptionsByTier(app.getLanguageTier(tempLevel)).filter(v => v !== link);
            const linkDistractors = app.shuffle(linkPool).slice(0, 3);
            const modelAnswer = [
                starter ? `STARTER: ${starter}` : "",
                trimmed ? `QUOTE: ${trimmed}` : "",
                link ? `LINK: ${link}` : "",
                tunedEffect ? `POINT: ${tunedEffect}` : ""
            ].filter(Boolean).join(" | ");
            return { reasons, distractorReasons, device, starter, starterDistractors, link, linkDistractors, effect: tunedEffect, modelAnswer };
        };
        const inDeskQueue = Array.isArray(userState.deskQueue) && userState.deskQueue.includes(trimmed);
        if(item && selItem && (item.fromSelection || String(item.id || "").startsWith("sel_") || inDeskQueue)) {
            const defaults = buildSelectionDefaults();
            item.type = defaults.device || item.type || "language";
            item.starter = defaults.starter || item.starter;
            item.starters = [item.starter].filter(Boolean);
            if(defaults.starterDistractors && defaults.starterDistractors.length) {
                item.starterDistractors = defaults.starterDistractors;
            } else if(!item.starterDistractors) {
                item.starterDistractors = [];
            }
            item.link = defaults.link || item.link;
            if(defaults.linkDistractors && defaults.linkDistractors.length) {
                item.linkDistractors = defaults.linkDistractors;
            } else if(!item.linkDistractors) {
                item.linkDistractors = [];
            }
            if(inDeskQueue || item.fromSelection || String(item.id || "").startsWith("sel_")) {
                if(defaults.effect) item.effect = defaults.effect;
                if(defaults.modelAnswer) item.modelAnswer = defaults.modelAnswer;
                item.links = [item.link].filter(Boolean);
            } else if(defaults.effect && (!item.effect || item.effect === item.translation)) {
                item.effect = defaults.effect;
            }
        }
        if(!item) {
            const existing = app.quoteMatchesExisting(trimmed, appData.items || []);
            if(existing) return existing;
            const defaults = buildSelectionDefaults();
            const activeLevels = app.getActiveLevels();
            const levelsForNew = (selItem && Array.isArray(selItem.levels) && selItem.levels.length) ? selItem.levels.slice() : (activeLevels.length ? activeLevels.slice() : [1,2,3]);
            const newItem = {
                id: `sel_${Date.now()}`,
                original: trimmed,
                translation: defaults.reasons[0] || defaults.effect || "Meaning not provided.",
                translationDistractors: defaults.distractorReasons.slice(0, 3),
                type: defaults.device || "language",
                effect: defaults.effect || defaults.reasons[0] || "",
                effectDistractors: defaults.distractorReasons,
                levels: levelsForNew,
                includeInWorksheet: true,
                starter: defaults.starter,
                starters: [defaults.starter].filter(Boolean),
                starterDistractors: defaults.starterDistractors || [],
                link: defaults.link,
                links: [defaults.link].filter(Boolean),
                linkDistractors: defaults.linkDistractors || [],
                modelAnswer: defaults.modelAnswer,
                fromSelection: true
            };
            appData.items.push(newItem);
            item = newItem;
        }
        return item || null;
    },
    renderDeskQuoteTabs: function() {
        const wrap = document.getElementById("desk-quote-tabs");
        if(!wrap) return;
        const queue = Array.isArray(userState.deskQueue) ? userState.deskQueue : [];
        if(!queue.length) { wrap.innerHTML = ""; wrap.classList.add("hidden"); return; }
        const items = queue.map(q => ui.ensureQuoteItem(q)).filter(Boolean);
        if(!items.length) { wrap.innerHTML = ""; wrap.classList.add("hidden"); return; }
        wrap.classList.remove("hidden");
        wrap.innerHTML = items.map(i => {
            const label = (i.original || "").length > 60 ? `${i.original.slice(0, 60)}...` : (i.original || "");
            const active = i.id === ui.activeQuoteId ? "active" : "";
            const encoded = encodeURIComponent(i.original || "");
            return `<button class="btn btn-outline btn-small ${active}" data-quote-enc="${encoded}">${app.escapeHtml(label)}</button>`;
        }).join("");
        Array.from(wrap.querySelectorAll("button[data-quote-enc]")).forEach(btn => {
            btn.onclick = () => {
                const q = decodeURIComponent(btn.dataset.quoteEnc || "");
                const item = ui.ensureQuoteItem(q);
                if(item) ui.runBuilder(item);
            };
        });
    },
    _sendToBuilderGuard: false,
    sendSelectionQuotesToBuilder: function() {
        if(ui._sendToBuilderGuard) return;
        const chosen = Array.isArray(userState.selectionChosen) ? userState.selectionChosen : [];
        const seen = new Set();
        const uniqueChosen = chosen.filter(q => {
            const k = app.quoteKey(q);
            if(seen.has(k)) return false;
            seen.add(k);
            return true;
        });
        if(!uniqueChosen.length) return;
        ui._sendToBuilderGuard = true;
        try {
            userState.deskQueue = uniqueChosen.slice();
            uniqueChosen.forEach(q => ui.ensureQuoteItem(q));
            userState.selectionCompleted = true;
            const modules = appData.settings && appData.settings.modulesActive ? appData.settings.modulesActive : { lab: true, desk: true };
            userState.view = modules.lab ? "lab" : "desk";
            app.save();
            const first = ui.ensureQuoteItem(uniqueChosen[0]);
            if(window.getSelection) window.getSelection().removeAllRanges();
            ui._textSelecting = false;
            if(modules.lab) {
                ui.switchView("lab", true);
                if(first) ui.startWizard(first);
            } else {
                ui.switchView("desk", true);
                if(first) ui.runBuilder(first);
            }
        } finally {
            ui._sendToBuilderGuard = false;
        }
    },
    setSelectionStage: function(stage) {
        const sel = appData.selection;
        if(!sel || !sel.modes || !sel.modes.stages) return;
        const maxStage = sel.modes.stages.length;
        const target = Math.max(1, Math.min(maxStage, parseInt(stage, 10) || 1));
        userState.selectionStage = target;
        app.save();
        ui.renderSelection();
    },

    showCelebration: function(autoAdvance, isFinal) {
        const overlay = document.getElementById('celebration-overlay');
        const inner = document.getElementById('celebration-inner');
        const title = document.getElementById('celebration-title');
        const sub = document.getElementById('celebration-sub');
        const btn = document.getElementById('celebration-btn');
        const rewardBtn = document.getElementById('celebration-reward');
        const quitBtn = document.getElementById('celebration-quit');
        const rewardUrl = appData.settings && appData.settings.rewardUrl ? String(appData.settings.rewardUrl).trim() : "";
        const rewardMinutes = appData.settings && typeof appData.settings.rewardMinutes === "number" ? appData.settings.rewardMinutes : 0;
        const rewardEvery = appData.settings && typeof appData.settings.rewardEveryLevels === "number" ? appData.settings.rewardEveryLevels : 0;
        const rewardAtEnd = appData.settings && appData.settings.rewardAtEnd === true;
        const rewardUntilKey = "tsa_reward_until";
        const rewardLevelKey = "tsa_reward_level";
        const now = Date.now();
        const rewardUntil = parseInt(localStorage.getItem(rewardUntilKey) || "0", 10) || 0;
        const rewardLevel = parseInt(localStorage.getItem(rewardLevelKey) || "0", 10) || 0;

        inner.classList.remove('celebration-final', 'celebration-final-reward');
        title.classList.remove('celebration-final-title');
        if(quitBtn) quitBtn.style.display = 'none';

        overlay.classList.remove('hidden');
        app.playSound(isFinal ? 'final' : 'celebrate');

        if (isFinal) {
            inner.classList.add('celebration-final');
            title.classList.add('celebration-final-title');
            if (!rewardUrl) {
                title.innerText = "Game Over";
                sub.innerText = "Play again?";
                btn.innerText = "Play again";
                btn.style.display = 'block';
                btn.onclick = () => {
                    ui.closeCelebration();
                    userState = { score: 0, level: 1, view: "", essay: "", completed: [], completedLevels: [], filter: "all", showDone: false, selectionCompleted: false, selectionStage: 1, selectionKey: "", selectionProgress: {}, selectionEliminated: [], labCompleted: false };
                    app.save();
                    location.reload();
                };
                if(rewardBtn) rewardBtn.style.display = 'none';
            } else {
                inner.classList.add('celebration-final-reward');
                title.innerText = "Course Complete! üèÜ";
                sub.innerText = "Well done! Choose an option below.";
                btn.innerText = "Start again";
                btn.style.display = 'block';
                btn.onclick = () => {
                    ui.closeCelebration();
                    userState = { score: 0, level: 1, view: "", essay: "", completed: [], completedLevels: [], filter: "all", showDone: false, selectionCompleted: false, selectionStage: 1, selectionKey: "", selectionProgress: {}, selectionEliminated: [], labCompleted: false };
                    app.save();
                    location.reload();
                };
                if(rewardBtn) {
                    rewardBtn.style.display = "inline-flex";
                    rewardBtn.disabled = false;
                    rewardBtn.textContent = rewardMinutes > 0 ? `Go to game (${rewardMinutes} min)` : "Go to game site";
                    rewardBtn.onclick = () => {
                        if(rewardMinutes > 0) {
                            localStorage.setItem(rewardUntilKey, String(Date.now() + rewardMinutes * 60000));
                            localStorage.setItem(rewardLevelKey, String(userState.level || 0));
                        }
                        window.open(rewardUrl, "_blank");
                    };
                }
                if(quitBtn) {
                    quitBtn.style.display = 'inline-flex';
                    quitBtn.onclick = ui.closeCelebration;
                }
            }
        } else {
            if(rewardBtn) {
                const maxLevel = Math.max(...app.getActiveLevels());
                const shouldShowReward = rewardAtEnd
                    ? (userState.level >= maxLevel)
                    : (rewardEvery > 0 ? (userState.level % rewardEvery === 0) : true);
                if(rewardUrl && shouldShowReward) {
                    rewardBtn.style.display = "inline-flex";
                    if(rewardMinutes > 0 && rewardLevel === userState.level && rewardUntil && now > rewardUntil) {
                        rewardBtn.disabled = true;
                        rewardBtn.textContent = "Reward locked (complete next level)";
                        rewardBtn.onclick = null;
                    } else {
                        rewardBtn.disabled = false;
                        rewardBtn.textContent = rewardMinutes > 0 ? `Play Reward (${rewardMinutes} min)` : "Play Reward";
                        rewardBtn.onclick = () => {
                            if(rewardMinutes > 0) {
                                localStorage.setItem(rewardUntilKey, String(Date.now() + rewardMinutes * 60000));
                                localStorage.setItem(rewardLevelKey, String(userState.level || 0));
                            }
                            window.open(rewardUrl, "_blank");
                        };
                    }
                } else {
                    rewardBtn.style.display = "none";
                    rewardBtn.onclick = null;
                }
            }
            title.innerText = `Level ${userState.level} Complete! üéâ`;
            sub.innerText = "Great work! Moving up...";
            if (autoAdvance && !rewardUrl) {
                btn.style.display = 'none';
                setTimeout(() => {
                    ui.closeCelebration();
                    app.setLevel(userState.level + 1);
                }, 3000);
            } else {
                btn.innerText = "Continue";
                btn.style.display = 'block';
                btn.onclick = () => {
                    ui.closeCelebration();
                    app.setLevel(userState.level + 1);
                    ui.switchView('lab');
                };
            }
        }
    },
    showSelectionMessage: function(titleText, subText) {
        const overlay = document.getElementById('celebration-overlay');
        const title = document.getElementById('celebration-title');
        const sub = document.getElementById('celebration-sub');
        const btn = document.getElementById('celebration-btn');
        if(!overlay || !title || !sub || !btn) return;
        title.innerText = titleText || "Well done!";
        sub.innerText = subText || "";
        btn.innerText = "Continue";
        btn.style.display = "block";
        btn.onclick = ui.closeCelebration;
        overlay.classList.remove('hidden');
        app.playSound('celebrate');
    },

    closeCelebration: function() {
        document.getElementById("celebration-overlay").classList.add("hidden");
    },

    showSplash: function() {
        const splash = document.getElementById("splash-screen");
        if(!splash || splash.dataset.shown) return;
        splash.dataset.shown = "true";
        splash.classList.remove("hidden");
        setTimeout(() => {
            app.playSound("celebrate");
        }, 600);

        const intro = document.getElementById("intro-text-screen");
        const pick = document.getElementById("pick-quote-screen");

        setTimeout(() => {
            splash.classList.add("hidden");
            if(intro) intro.classList.add("hidden");
            if(pick) pick.classList.add("hidden");
        }, 3500);
    }
};

/* --- ADMIN --- */
const admin = {
    aiAutoBound: false,
    tabsBound: false,
    initTabs: () => {
        if(admin.tabsBound) return;
        const wrap = document.getElementById("admin-tabs");
        if(!wrap) return;
        const buttons = Array.from(wrap.querySelectorAll(".tab-btn"));
        const tabs = Array.from(document.querySelectorAll(".admin-tab"));
        const activate = (key) => {
            buttons.forEach(b => b.classList.toggle("active", b.dataset.tab === key));
            tabs.forEach(t => t.classList.toggle("hidden", t.dataset.tab !== key));
            localStorage.setItem("tsa_admin_tab", key);
        };
        admin.setTab = (key) => {
            if(!buttons.length || !tabs.length) return;
            activate(key);
        };
        buttons.forEach(btn => {
            btn.addEventListener("click", () => activate(btn.dataset.tab));
        });
        const saved = localStorage.getItem("tsa_admin_tab");
        activate(saved || "controls");
        admin.tabsBound = true;
    },
    syncTemplatesFromStorage: () => {
        let local = [];
        try {
            const raw = JSON.parse(localStorage.getItem("tsa_templates_v1") || "[]");
            if(Array.isArray(raw)) local = raw;
        } catch(e) {}
        if(!appData.settings) appData.settings = {};
        if(!Array.isArray(appData.settings.templates)) appData.settings.templates = [];
        let changed = false;
        local.forEach(t => {
            if(!t || !t.name) return;
            if(!appData.settings.templates.find(x => x && x.name === t.name)) {
                appData.settings.templates.push(t);
                changed = true;
            }
        });
        if(changed) app.save();
    },
    renderAll: function() {
        admin.syncUI();
        admin.bindAiAutoPrompt();
        admin.ensureAiStepVisible();
        admin.refreshTemplateList();
        admin.renderQuoteList();
        admin.renderSelectionEditor();
        admin.renderGlobalList();
        const lvl = typeof currentConfigLevel === 'number' ? currentConfigLevel : 1;
        admin.renderConfig(lvl);
        admin.renderLevelBank();
        admin.initTabs();
    },
    ensureSelectionData: () => {
        if(!appData.selection || typeof appData.selection !== "object") {
            appData.selection = app.repairSelection({}, { activeLevels: app.getActiveLevels(), lessonItems: appData.items });
        }
        if(!appData.selection.question || typeof appData.selection.question !== "object") {
            appData.selection.question = { prompt: "", focusTags: [] };
        }
        if(!appData.selection.modes || typeof appData.selection.modes !== "object") {
            appData.selection.modes = { selectionMode: "closed", showHints: true, requireReason: true, quoteCount: 4 };
        }
        if(!Array.isArray(appData.selection.items)) appData.selection.items = [];
        const bank = app.getLevelBank();
        const anyFreeSelect = bank && Object.keys(bank).some(function(lvl) { return bank[lvl] && bank[lvl].freeSelectFromText === true; });
        if(typeof appData.selection.enabled !== "boolean") appData.selection.enabled = appData.selection.items.length > 0 || !!anyFreeSelect;
        if(!appData.selection.stageConfigByLevel || typeof appData.selection.stageConfigByLevel !== "object") {
            const stageKeys = appData.settings && Array.isArray(appData.settings.selectionStages)
                ? appData.settings.selectionStages
                : ["discriminate","align","justify"];
            appData.selection.stageConfigByLevel = {};
            app.getActiveLevels().forEach(lvl => {
                appData.selection.stageConfigByLevel[lvl] = {};
                stageKeys.forEach(key => { appData.selection.stageConfigByLevel[lvl][key] = "choice"; });
            });
        }
    },
    syncUI: function() {
        const keepUnlocked = document.getElementById("keep-unlocked");
        if(keepUnlocked) keepUnlocked.checked = localStorage.getItem("tsa_unlocked") === "true";
        const autoProgress = document.getElementById("auto-progress");
        if(autoProgress) autoProgress.checked = appData.settings.autoProgress;
        const practiceMode = document.getElementById("practice-mode");
        if(practiceMode) practiceMode.checked = !!appData.settings.practiceMode;
        const fq = document.getElementById("focus-question");
        if(fq) fq.value = appData.question || "";
        const pl = document.getElementById("practice-level");
        if(pl) pl.value = appData.settings.practiceModeLevel || 1;
        const pfa = document.getElementById("practice-force-auto");
        if(pfa) pfa.checked = !!appData.settings.practiceForceAuto;
        const pft = document.getElementById("practice-fixed-template");
        if(pft) pft.checked = !!appData.settings.practiceFixedTemplate;
        const wmm = document.getElementById("worksheet-match-mode");
        if(wmm) wmm.value = appData.settings.worksheetMatchMode || "jumbled";
        const allLevels = document.getElementById("ai-all-levels");
        if(allLevels) allLevels.checked = !!appData.settings.aiPromptAllLevels;
        const reward = document.getElementById("reward-url");
        if(reward) reward.value = appData.settings.rewardUrl || "";
        const rewardMinutes = document.getElementById("reward-minutes");
        if(rewardMinutes) rewardMinutes.value = String(appData.settings.rewardMinutes || 0);
        const rewardEvery = document.getElementById("reward-every-levels");
        if(rewardEvery) rewardEvery.value = String(appData.settings.rewardEveryLevels || 0);
        const rewardAtEnd = document.getElementById("reward-at-end");
        if(rewardAtEnd) rewardAtEnd.checked = !!appData.settings.rewardAtEnd;
        const allowPartial = document.getElementById("allow-partial-selection");
        if(allowPartial) allowPartial.checked = !!appData.settings.allowPartialSelection;
        const aiTone = document.getElementById("ai-include-tone");
        if(aiTone) aiTone.checked = appData.settings.aiIncludeTone !== false;
        const aiStructure = document.getElementById("ai-include-structure");
        if(aiStructure) aiStructure.checked = appData.settings.aiIncludeStructure !== false;
        const strict = document.getElementById("strict-mode");
        if(strict) strict.checked = !!appData.settings.strictMode;
        const startView = document.getElementById("start-view");
        if(startView) {
            const pref = appData.settings && appData.settings.startView ? appData.settings.startView : "lab";
            startView.value = pref;
        }
        const modulesWrap = document.getElementById("modules-active");
        if(modulesWrap) {
            const modules = ["selection","lab","desk"];
            const labels = { selection: "Quote Select", lab: "Evidence Lab", desk: "Writing Desk" };
            modulesWrap.innerHTML = "";
            modules.forEach(m => {
                const lbl = document.createElement("label");
                lbl.style.display = "flex";
                lbl.style.alignItems = "center";
                lbl.style.gap = "4px";
                lbl.style.fontSize = "0.85rem";
                lbl.innerHTML = `<input type="checkbox" ${appData.settings.modulesActive[m] ? "checked" : ""} data-module="${m}"> ${labels[m]}`;
                const cb = lbl.querySelector("input");
                cb.addEventListener("change", admin.updateModulesActive);
                modulesWrap.appendChild(lbl);
            });
        }
        const stageWrap = document.getElementById("selection-stages");
        if(stageWrap) {
            const allStages = ["discriminate","boundary","align","justify"];
            const active = new Set(appData.settings.selectionStages || []);
            stageWrap.innerHTML = "";
            allStages.forEach(s => {
                const lbl = document.createElement("label");
                lbl.style.display = "flex";
                lbl.style.alignItems = "center";
                lbl.style.gap = "4px";
                lbl.style.fontSize = "0.85rem";
                const labelText = (ui.getStageLabel ? ui.getStageLabel(s) : s);
                lbl.innerHTML = `<input type="checkbox" ${active.has(s) ? "checked" : ""} data-stage="${s}"> ${labelText}`;
                const cb = lbl.querySelector("input");
                cb.addEventListener("change", admin.updateSelectionStages);
                stageWrap.appendChild(lbl);
            });
            const preset = document.getElementById("selection-stage-preset");
            if(preset) preset.value = "custom";
        }
        const activeWrap = document.getElementById("active-levels");
        if(activeWrap) {
            const active = new Set(app.getActiveLevels());
            activeWrap.innerHTML = "";
            for(let i = 1; i <= 9; i++) {
                const lbl = document.createElement("label");
                lbl.style.display = "flex";
                lbl.style.alignItems = "center";
                lbl.style.gap = "4px";
                lbl.style.fontSize = "0.85rem";
                lbl.innerHTML = `<input type="checkbox" ${active.has(i) ? "checked" : ""} data-level="${i}"> L${i}`;
                const cb = lbl.querySelector("input");
                cb.addEventListener("change", admin.updateActiveLevels);
                activeWrap.appendChild(lbl);
            }
        }
        const step2 = document.getElementById("ai-step2");
        const jsonIn = document.getElementById("ai-json-in");
        const promptOut = document.getElementById("ai-prompt-out");
        const keepOpen = localStorage.getItem("tsa_ai_step2") === "true";
        if(step2 && (keepOpen || (jsonIn && jsonIn.value && jsonIn.value.trim()) || (promptOut && promptOut.value && promptOut.value.trim()))) {
            step2.classList.remove("hidden");
        }
    },
    setUnlocked: (c) => localStorage.setItem("tsa_unlocked", c),
    setAutoProgress: (c) => { 
        if(!appData.settings) appData.settings = {};
        appData.settings.autoProgress = c; 
        app.save(); 
    },
    setRewardUrl: (v) => {
        if(!appData.settings) appData.settings = {};
        appData.settings.rewardUrl = String(v || "").trim();
        app.save();
    },
    setRewardMinutes: (v) => {
        if(!appData.settings) appData.settings = {};
        const n = parseInt(v, 10);
        appData.settings.rewardMinutes = isNaN(n) || n < 0 ? 0 : n;
        app.save();
    },
    setRewardEveryLevels: (v) => {
        if(!appData.settings) appData.settings = {};
        const n = parseInt(v, 10);
        appData.settings.rewardEveryLevels = isNaN(n) || n < 0 ? 0 : n;
        app.save();
    },
    setRewardAtEnd: (c) => {
        if(!appData.settings) appData.settings = {};
        appData.settings.rewardAtEnd = !!c;
        app.save();
    },
    setSelectionDevice: (device, enabled) => {
        if(!appData.settings) appData.settings = {};
        if(!appData.settings.selectionDevices || typeof appData.settings.selectionDevices !== "object") {
            appData.settings.selectionDevices = { language: true, tone: true, structure: true };
        }
        appData.settings.selectionDevices[device] = !!enabled;
        app.save();
        ui.renderSelection();
    },
    setAllowPartialSelection: (c) => {
        if(!appData.settings) appData.settings = {};
        appData.settings.allowPartialSelection = !!c;
        app.save();
        ui.renderSelection();
    },
    setFocusQuestion: (v) => {
        if(!appData) return;
        const text = String(v || "");
        appData.question = text;
        if(appData.selection && appData.selection.question) {
            appData.selection.question.prompt = text;
        }
        app.save();
        ui.renderQuestionBanner();
        ui.renderSelection();
    },
    setPracticeMode: (c) => {
        if(!appData.settings) appData.settings = {};
        appData.settings.practiceMode = c;
        app.save();
        ui.init();
        admin.syncUI();
    },
    setPracticeLevel: (v) => {
        if(!appData.settings) appData.settings = {};
        const lvl = parseInt(v, 10);
        appData.settings.practiceModeLevel = (lvl >= 1 && lvl <= 9) ? lvl : 1;
        app.save();
        if(appData.settings.practiceMode) { ui.init(); admin.syncUI(); }
    },
    setPracticeForceAuto: (c) => {
        if(!appData.settings) appData.settings = {};
        appData.settings.practiceForceAuto = c;
        app.save();
        if(appData.settings.practiceMode) { ui.init(); admin.syncUI(); }
    },
    setPracticeFixedTemplate: (c) => {
        if(!appData.settings) appData.settings = {};
        appData.settings.practiceFixedTemplate = c;
        app.save();
        if(appData.settings.practiceMode) { ui.init(); admin.syncUI(); }
    },
    setStrictMode: (c) => {
        if(!appData.settings) appData.settings = {};
        appData.settings.strictMode = c;
        app.save();
    },
    setAiAllLevels: (c) => {
        if(!appData.settings) appData.settings = {};
        appData.settings.aiPromptAllLevels = c;
        app.save();
    },
    setAiDevice: (device, enabled) => {
        if(!appData.settings) appData.settings = {};
        if(device === "tone") appData.settings.aiIncludeTone = !!enabled;
        if(device === "structure") appData.settings.aiIncludeStructure = !!enabled;
        app.save();
    },
    setExportDevice: (device, enabled) => {
        if(!appData.settings) appData.settings = {};
        if(device === "tone") appData.settings.exportIncludeTone = !!enabled;
        if(device === "structure") appData.settings.exportIncludeStructure = !!enabled;
        app.save();
    },
    setStartView: (v) => {
        if(!appData.settings) appData.settings = {};
        const valid = ["select","lab","desk"].includes(v) ? v : "lab";
        appData.settings.startView = valid;
        app.save();
    },
    updateActiveLevels: () => {
        const activeWrap = document.getElementById("active-levels");
        if(!activeWrap) return;
        const selected = Array.from(activeWrap.querySelectorAll("input[type='checkbox']"))
            .filter(cb => cb.checked)
            .map(cb => parseInt(cb.dataset.level, 10))
            .filter(n => n >= 1 && n <= 9);
        if(!selected.length) return;
        if(!appData.settings) appData.settings = {};
        appData.settings.activeLevels = selected;
        app.save();
        ui.init();
        admin.syncUI();
    },
    updateSelectionStages: () => {
        const wrap = document.getElementById("selection-stages");
        if(!wrap) return;
        const selected = Array.from(wrap.querySelectorAll("input[type='checkbox']"))
            .filter(cb => cb.checked)
            .map(cb => cb.dataset.stage)
            .filter(Boolean);
        if(!selected.length) return;
        if(!appData.settings) appData.settings = {};
        appData.settings.selectionStages = selected;
        app.save();
        if(appData.selection) {
            appData.selection.modes = appData.selection.modes || {};
            appData.selection.modes.stages = selected;
        }
        ui.renderSelection();
    },
    updateSelectionStageConfig: (lvl, stageKey, mode) => {
        if(!lvl || !stageKey) return;
        if(!appData.selection) {
            appData.selection = app.repairSelection({}, { activeLevels: app.getActiveLevels(), lessonItems: appData.items });
        }
        if(!appData.selection.stageConfigByLevel || typeof appData.selection.stageConfigByLevel !== "object") {
            appData.selection.stageConfigByLevel = {};
        }
        if(!appData.selection.stageConfigByLevel[lvl]) {
            appData.selection.stageConfigByLevel[lvl] = {};
        }
        appData.selection.stageConfigByLevel[lvl][stageKey] = mode === "free" ? "free" : "choice";
        app.save();
        if(userState.view === "select") ui.renderSelection();
    },
    applySelectionPreset: (preset) => {
        const presets = {
            beginner: ["align","justify"],
            intermediate: ["discriminate","align","justify"],
            advanced: ["discriminate","align","justify"]
        };
        if(!presets[preset]) return;
        if(!appData.settings) appData.settings = {};
        appData.settings.selectionStages = presets[preset];
        app.save();
        if(appData.selection) {
            appData.selection.modes = appData.selection.modes || {};
            appData.selection.modes.stages = presets[preset];
        }
        admin.syncUI();
        ui.renderSelection();
    },
    updateModulesActive: () => {
        const wrap = document.getElementById("modules-active");
        if(!wrap) return;
        const selected = Array.from(wrap.querySelectorAll("input[type='checkbox']"))
            .reduce((acc, cb) => {
                acc[cb.dataset.module] = cb.checked;
                return acc;
            }, {});
        if(!appData.settings) appData.settings = {};
        appData.settings.modulesActive = Object.assign({ selection: true, lab: true, desk: true }, selected);
        app.save();
        ui.init();
    },
    markLabComplete: () => {
        userState.labCompleted = true;
        app.save();
        ui.init();
    },
    resetSelectionProgress: () => {
        userState.completed = [];
        userState.completedLevels = [];
        userState.score = 0;
        userState.showDone = false;
        userState.selectionCompleted = false;
        userState.selectionStage = 1;
        userState.selectionKey = "";
        userState.selectionProgress = {};
        userState.selectionEliminated = [];
        userState.selectionChosen = [];
        userState.deskQueue = [];
        ui._selectionCorrectItem = null;
        ui._selectionQuote = null;
        userState.labCompleted = false;
        app.save();
        ui.init();
    },
    getItemLevel: (item) => {
        const lvl = Array.isArray(item.levels) && item.levels.length ? parseInt(item.levels[0], 10) : 1;
        return (lvl >= 1 && lvl <= 9) ? lvl : 1;
    },
    getSlotBase: (slot) => {
        const raw = String(slot || "").toLowerCase();
        const tail = raw.startsWith("manual_") ? raw.split("_")[1] : raw;
        if(tail === "analysis" || tail === "effect" || tail === "point") return "point";
        if(tail.startsWith("link")) return "link";
        return tail;
    },
    buildModelAnswerFromTemplate: (item, level) => {
        const cfg = (appData.sentenceConfig && appData.sentenceConfig[level]) || (appData.sentenceConfig && appData.sentenceConfig[3]) || [];
        const pick = (list) => {
            if(!Array.isArray(list) || !list.length) return "";
            const raw = list[Math.floor(Math.random() * list.length)];
            if(typeof raw === "string") return raw;
            if(raw && typeof raw === "object" && typeof raw.text === "string") return raw.text;
            return "";
        };
        const linkKey = `l${level}`;
        const slotValue = (slot) => {
            const base = admin.getSlotBase(slot);
            if(base === "quote") return item.original || "";
            if(base === "point") return item.effect || item.translation || "";
            if(base === "marker") return item.marker || pick(appData.banks && appData.banks.markers);
            if(base === "starter") return item.starter || pick(appData.banks && appData.banks.starters);
            if(base === "method") return item.method || pick(appData.banks && appData.banks.methods);
            if(base === "link") {
                const links = (appData.banks && appData.banks.links && appData.banks.links[linkKey]) || (appData.banks && appData.banks.links && appData.banks.links.l3);
                return item.link || pick(links);
            }
            return "";
        };
        const parts = cfg.map(slot => {
            const base = admin.getSlotBase(slot);
            const val = slotValue(slot);
            if(!val) return "";
            const label = base.toUpperCase();
            return `${label}: ${val}`;
        }).filter(Boolean);
        return parts.join(" | ");
    },
    parseModelAnswer: (text) => {
        const raw = String(text || "").trim();
        if(!raw) return {};
        const parts = raw.split(/\s*\|\s*/);
        const out = {};
        const normalizeKey = (k) => k.trim().toLowerCase().replace(/\s+/g, "_");
        parts.forEach(part => {
            const idx = part.indexOf(":");
            if(idx <= 0) return;
            const key = normalizeKey(part.slice(0, idx));
            const value = part.slice(idx + 1).trim();
            if(!value) return;
            out[key] = value;
        });
        return out;
    },
    applyModelSlotsToItem: (item, slotMap, overwrite) => {
        const setIf = (key, value) => {
            if(!value) return;
            if(!overwrite && item[key]) return;
            item[key] = value;
        };
        setIf("marker", slotMap.marker);
        setIf("starter", slotMap.starter);
        setIf("method", slotMap.method);
        setIf("link", slotMap.link || slotMap.link_l1 || slotMap.link_l2 || slotMap.link_l3);
        setIf("effect", slotMap.point || slotMap.analysis || slotMap.effect);
    },
    splitModelAnswerForItem: (item, overwrite) => {
        const modelAnswer = item.modelAnswer || "";
        const slotMap = admin.parseModelAnswer(modelAnswer);
        if(Object.keys(slotMap).length) {
            admin.applyModelSlotsToItem(item, slotMap, overwrite);
            return true;
        }
        return false;
    },
    applyModelAnswersFromItems: (opts = {}) => {
        const overwrite = !!opts.overwrite;
        const generate = !!opts.generate;
        const items = Array.isArray(appData.items) ? appData.items : [];
        if(!items.length) return 0;
        let updated = 0;
        items.forEach(item => {
            if(!item) return;
            const hasModel = !!(item.modelAnswer && String(item.modelAnswer).trim());
            let applied = false;
            if(hasModel) {
                applied = admin.splitModelAnswerForItem(item, overwrite);
            }
            if(!applied && generate) {
                const level = admin.getItemLevel(item);
                const built = admin.buildModelAnswerFromTemplate(item, level);
                if(built) {
                    if(overwrite || !item.modelAnswer) item.modelAnswer = built;
                    applied = admin.splitModelAnswerForItem(item, overwrite);
                }
            }
            if(applied) updated += 1;
        });
        return updated;
    },
    generateAndSplitModelAnswers: (opts = {}) => {
        const overwrite = !!opts.overwrite;
        const items = Array.isArray(appData.items) ? appData.items : [];
        if(!items.length) return alert("No lesson items to update.");
        const updated = admin.applyModelAnswersFromItems({ overwrite, generate: true });
        app.save();
        admin.renderQuoteList();
        ui.init();
        alert(`Model answers processed for ${updated} / ${items.length} items.`);
    },
    setWorksheetMatchMode: (v) => {
        if(!appData.settings) appData.settings = {};
        appData.settings.worksheetMatchMode = ["aligned","jumbled","list"].includes(v) ? v : "jumbled";
        app.save();
    },
    // QUOTE LIST
    renderQuoteList: function() {
        const c = document.getElementById("quote-editor-list"); c.innerHTML = "";
        appData.items.forEach((item, idx) => {
            const div = document.createElement("div"); div.className = "quote-editor"; div.id = "quote-editor-" + idx;
            div.innerHTML = `
                <div class="editor-header">#${idx+1} <button class="btn btn-danger btn-small" onclick="admin.delQuote(${idx})">Del</button></div>
                <div class="input-group"><label>Quote</label><input value="${app.escapeHtml(item.original || "")}" onchange="admin.updQuote(${idx},'original',this.value,this)"></div>
                <div class="input-group"><label>Translation</label><input value="${item.translation}" onchange="admin.updQuote(${idx},'translation',this.value)"></div>
                <div class="input-group"><label>Translation Distractors (CSV)</label><input value="${(item.translationDistractors||[]).join(',')}" onchange="admin.updQuote(${idx},'translationDistractors',this.value.split(','))"></div>
                <div class="input-group"><label>Analysis (Effect)</label><input value="${item.effect || ''}" onchange="admin.updQuote(${idx},'effect',this.value)"></div>
                <div class="input-group"><label>Analysis Distractors (CSV)</label><input value="${(item.effectDistractors||[]).join(',')}" onchange="admin.updQuote(${idx},'effectDistractors',this.value.split(','))"></div>
                <div class="input-group"><label>Model Answer (slot labels)</label><textarea onchange="admin.updQuote(${idx},'modelAnswer',this.value)" style="height:60px;">${app.escapeHtml(item.modelAnswer || "")}</textarea></div>
                <div class="level-checks">
                    <label>Worksheet: <input type="checkbox" ${item.includeInWorksheet?'checked':''} onchange="admin.updQuote(${idx},'includeInWorksheet',this.checked)"></label>
                    | Lvl (one per quote):
                    ${(app.getActiveLevels().length ? app.getActiveLevels() : [1,2,3]).map(l=>`<label>${l}<input type="checkbox" ${item.levels.includes(l)?'checked':''} onchange="admin.togLvl(${idx},${l})"></label>`).join('')}
                </div>
            `;
            c.appendChild(div);
        });
    },
    updQuote: (idx, k, v, inputEl) => {
        if(k === "original" && v) {
            const others = (appData.items || []).filter((_, i) => i !== idx);
            const match = app.quoteMatchesExisting(v, others);
            if(match) {
                if(!confirm(`This quote is very similar to an existing one: "${(match.original || "").slice(0, 60)}...". Add anyway?`)) {
                    if(inputEl) inputEl.value = appData.items[idx].original || "";
                    return;
                }
            }
        }
        appData.items[idx][k] = v;
        app.save();
    },
    togLvl: (idx, l) => {
        const i = appData.items[idx];
        const activeLevels = app.getActiveLevels();
        if (!activeLevels.length) return;
        if (i.levels.includes(l)) {
            i.levels = i.levels.filter(x => x !== l);
            if (!i.levels.length) i.levels = [activeLevels[0]];
        } else {
            i.levels = [l];
        }
        app.save();
    },
    delQuote: (idx) => { appData.items.splice(idx, 1); app.save(); admin.renderQuoteList(); },
    addQuote: () => { 
        const activeLevels = app.getActiveLevels();
        const singleLevel = activeLevels.length ? [activeLevels[0]] : [1];
        appData.items.push({ id:"q"+Date.now(), original:"New Quote", translation:"Meaning", translationDistractors:["Wrong"], effect:"Analysis", effectDistractors:["Wrong analysis"], type:"tone", levels: singleLevel, includeInWorksheet:true }); 
        app.save(); admin.renderQuoteList();
    },

    // GLOBAL STRUCTURE LIST
    renderGlobalList: function() {
        const c = document.getElementById("global-editor-list"); c.innerHTML = "";
        appData.globalStructure.items.forEach((item, idx) => {
            const div = document.createElement("div"); div.className = "struct-editor";
            div.innerHTML = `
                <div class="editor-header">Q${idx+1} <button class="btn btn-danger btn-small" onclick="admin.delGlobal(${idx})">Del</button></div>
                <div class="input-group"><label>Question</label><input value="${item.question}" onchange="admin.updGlobal(${idx},'question',this.value)"></div>
                <div class="input-group"><label>Correct</label><input value="${item.correct}" onchange="admin.updGlobal(${idx},'correct',this.value)"></div>
                <div class="input-group"><label>Distractors (CSV)</label><input value="${(item.distractors||[]).join(',')}" onchange="admin.updGlobal(${idx},'distractors',this.value.split(','))"></div>
            `;
            c.appendChild(div);
        });
    },
    updGlobal: (idx, k, v) => { appData.globalStructure.items[idx][k] = v; app.save(); },
    delGlobal: (idx) => { appData.globalStructure.items.splice(idx, 1); app.save(); admin.renderGlobalList(); },
    addGlobalQuestion: () => {
        appData.globalStructure.items.push({ id:"g"+Date.now(), question:"New Question?", correct:"Answer", distractors:["Wrong"] });
        app.save(); admin.renderGlobalList();
    },

    // AI
    bindAiAutoPrompt: () => {
        if(admin.aiAutoBound) return;
        const ids = [
            "ai-question","ai-input","ai-mode","ai-count",
            "ai-level-1","ai-level-2","ai-level-3",
            "ai-l1-count","ai-l1-words","ai-l1-complex","ai-l1-subtle","ai-l1-ellipsis",
            "ai-l2-count","ai-l2-words","ai-l2-complex","ai-l2-subtle","ai-l2-ellipsis",
            "ai-l3-count","ai-l3-words","ai-l3-complex","ai-l3-subtle","ai-l3-ellipsis",
            "ai-l4-count","ai-l4-words","ai-l4-complex","ai-l4-subtle","ai-l4-ellipsis",
            "ai-l5-count","ai-l5-words","ai-l5-complex","ai-l5-subtle","ai-l5-ellipsis",
            "ai-l6-count","ai-l6-words","ai-l6-complex","ai-l6-subtle","ai-l6-ellipsis",
            "ai-l7-count","ai-l7-words","ai-l7-complex","ai-l7-subtle","ai-l7-ellipsis",
            "ai-l8-count","ai-l8-words","ai-l8-complex","ai-l8-subtle","ai-l8-ellipsis",
            "ai-l9-count","ai-l9-words","ai-l9-complex","ai-l9-subtle","ai-l9-ellipsis"
        ];
        let autoTimer = null;
        const handler = () => {
            if(autoTimer) clearTimeout(autoTimer);
            autoTimer = setTimeout(() => {
                try {
                    const txt = document.getElementById("ai-input").value;
                    if(txt && txt.trim()) {
                        const trimmed = txt.trim();
                        if(trimmed.length > 60000) return;
                        if(!app.isLikelyJson(trimmed)) {
                            if(!appData.sourceText || appData.sourceText.trim() !== trimmed) {
                                appData.sourceText = trimmed;
                                app.save();
                                ui.init();
                            }
                        }
                        admin.generatePrompt(true);
                    }
                } catch(e) {
                    // avoid crash overlay from AI auto prompt
                }
            }, 150);
        };
        ids.forEach(id => {
            const el = document.getElementById(id);
            if(!el) return;
            el.addEventListener("input", handler);
            el.addEventListener("change", handler);
        });
        ["ai-input","ai-prompt-out","selection-prompt-out","unified-prompt-out","unified-json-in"].forEach(id => {
            const el = document.getElementById(id);
            if(!el) return;
            el.addEventListener("focus", () => { ui._pauseSelectionGate = true; });
            el.addEventListener("blur", () => { ui._pauseSelectionGate = false; });
        });
        admin.aiAutoBound = true;
    },
    useSourceText: () => {
        const txt = document.getElementById("ai-input").value || "";
        if(app.isLikelyJson(txt)) return alert("That looks like JSON. Paste plain source text instead.");
        const cleaned = app.cleanSourceText(txt);
        if(!cleaned) return alert("Paste source text first.");
        appData.sourceText = cleaned;
        app.save();
        ui.init();
    },
    loadSavedSourceQuestion: () => {
        const aiInput = document.getElementById("ai-input");
        const aiQuestion = document.getElementById("ai-question");
        if(aiInput && appData && appData.sourceText) {
            aiInput.value = appData.sourceText;
        }
        if(aiQuestion && appData && appData.question) {
            aiQuestion.value = appData.question;
        }
    },
    generateBothPrompts: () => {
        admin.generatePrompt();
        admin.generateSelectionPrompt();
    },
    generateUnifiedPrompt: () => {
        const text = (document.getElementById("ai-input").value || "").trim() || (appData.sourceText || "");
        const q = document.getElementById("ai-question").value || "How does the writer use language?";
        if(!text.trim()) return alert("Paste source text first.");
        const stages = (appData.settings && appData.settings.selectionStages) ? appData.settings.selectionStages : ["discriminate","align","justify"];
        const activeLevels = app.getActiveLevels();
        const levelBank = app.getLevelBank();
        const targetSummary = activeLevels.map(lvl => {
            const entry = levelBank[lvl] || {};
            const tq = entry.quoteTarget || 4;
            const td = entry.distractorCount || 4;
            return `- L${lvl}: ${tq} correct quotes, ${td} distractors`;
        }).join("\\n");
        const totalTarget = activeLevels.reduce((sum, lvl) => {
            const entry = levelBank[lvl] || {};
            return sum + (entry.quoteTarget || 4) + (entry.distractorCount || 4);
        }, 0);
        const prompt = `Role: Expert English Teacher
Task: Create ONE JSON object that includes BOTH:
1) A lesson for Tone & Structure Architect
2) A quote-selection training module

Source Text (FULL ‚Äî do not truncate or paraphrase):
"""${text}"""
Focus Question: "${q}"

Output JSON schema:
{
  lesson: { ...the lesson JSON your app already uses... },
  selection: { ...the quote-selection JSON schema below... }
}

Lesson schema (use these exact keys):
{
  meta:{title, author, version},
  sourceText, question,
  settings:{autoProgress, practiceMode, practiceModeLevel, practiceForceAuto, practiceFixedTemplate, worksheetMatchMode, activeLevels[], aiPromptAllLevels, quoteTarget, strictMode, selectionStages[], modulesActive{selection,lab,desk}, levelRules{1:{maxWords,ellipsesMaxWords}...}, levelBank{1:{maxWords,ellipsesMaxWords,languageTier,quoteTarget,distractorCount}...}},
  banks:{markers[], starters[], methods[], points[], links{l1[],l2[],l3[]}},
  sentenceConfig:{1:[...],2:[...],3:[...],4:[...],5:[...],6:[...],7:[...],8:[...],9:[...]},
  globalStructure:{enabled:true, items:[{id, question, correct, distractors[]}]},
  items:[{id, original, translation, translationDistractors[], type, effect, effectDistractors[], levels:[1..9], includeInWorksheet:true, modelAnswer, marker?, starter?, method?, link?}]
}
modelAnswer must be a single string with slot labels: "MARKER: ... | STARTER: ... | QUOTE: ... | METHOD: ... | POINT: ... | LINK: ...".

Quote-selection schema (NO empty strings):
{
  meta:{title, level, author, version},
  text:{source, type, wordCount},
  question:{prompt, focusTags[]},
  structurePrompts:[...],
  items:[{id, quote, correct:true|false, reasons[2], distractors:[{quote, reason}], levels:[1..9], device:"tone|language|structure", deviceReason}],
  modes:{selectionMode:"closed"|"open", showHints:true|false, requireReason:true|false, quoteCount, stages:${JSON.stringify(stages)}}
}

Lesson requirements: keep the same as the Tone & Structure lesson prompt (quotes, distractors, banks, sentenceConfig, globalStructure, settings).
Lesson items requirements (ALL active levels):
Create lesson.items for each level using levelBank targets.
Total lesson.items target = ${totalTarget} items (correct + distractors). If you cannot supply that many real quotes, include as many as possible, and mark items as appropriate types.

Selection requirements (ALL active levels):
${targetSummary}
Each correct quote must include device (tone/language/structure) and deviceReason.
Include structurePrompts (7‚Äì10) that guide structural discussion (e.g., paragraphing shifts, time/sequence, zoom, placement, repetition, circular structure, juxtaposition).
Structure quotes must be about organisation/sequence (time shifts, paragraphing, zoom in/out, opening/closing, contrast/juxtaposition, cyclical structure). Do NOT label content-only or cause/effect-only lines as structure unless the wording itself signals structure (e.g., "throughout history", "over time", "at first...later", "the final paragraph").
Ensure each active level includes at least one STRUCTURE correct quote and at least one TONE or LANGUAGE quote.
Each correct quote must include 2 reasons and 2+ distractors with reasons (no blanks).
If a quote cannot be justified as noise, include it as a distractor anyway with a plausible reason.
If a quote is correct, include at least one reason (prefer 2) and never leave reasons blank.
Avoid reusing the same answer text across reasons or deviceReason.
Use UK English spelling throughout (e.g., humanises, emphasises, organise).
Match the language complexity for each item to its levelBank.languageTier (low/medium/advanced) across all levels globally.
Do NOT use placeholders.
Total target = ${totalTarget} quotes. If the text cannot supply that many real quotes, include as many as possible and mark each as correct:true/false accordingly.
Make incorrect quotes plausible (near-miss): choose lines that are thematically related but do not answer the question as well as the correct quotes. Avoid obvious random lines.

Output ONLY valid JSON.`;
        const out = document.getElementById("unified-prompt-out");
        if(out) out.value = prompt;
    },
    copyUnifiedPrompt: async () => {
        const out = document.getElementById("unified-prompt-out");
        if(!out || !out.value.trim()) return alert("Generate the unified prompt first.");
        try {
            await navigator.clipboard.writeText(out.value);
            alert("Unified prompt copied to clipboard.");
        } catch(e) {
            out.focus();
            out.select();
            alert("Copy failed. The prompt is selected‚Äîpress Ctrl/Cmd+C.");
        }
    },
    pasteUnifiedJson: async () => {
        try {
            const txt = await navigator.clipboard.readText();
            if(!txt || !txt.trim()) return alert("Clipboard is empty.");
            const box = document.getElementById("unified-json-in");
            if(box) box.value = txt.trim();
        } catch(e) {
            alert("Paste failed. Use Ctrl/Cmd+V in the Unified JSON box.");
        }
    },
    mergeLessonConfig: (raw, prev, target) => {
        if(!prev || !target) return;
        const copy = (v) => JSON.parse(JSON.stringify(v));
        if(prev.sentenceConfig && (!target.sentenceConfig || !Object.keys(target.sentenceConfig).length)) {
            target.sentenceConfig = copy(prev.sentenceConfig);
        }
        if(prev.banks && (!target.banks || !Object.keys(target.banks).length)) {
            target.banks = copy(prev.banks);
        }
        if(prev.globalStructure && (!target.globalStructure || !Object.keys(target.globalStructure).length)) {
            target.globalStructure = copy(prev.globalStructure);
        }
        const prevSettings = prev.settings || {};
        target.settings = target.settings || {};
        if(prevSettings.levelRules) target.settings.levelRules = copy(prevSettings.levelRules);
        if(prevSettings.levelBank) target.settings.levelBank = copy(prevSettings.levelBank);
        if(prevSettings.activeLevels) target.settings.activeLevels = prevSettings.activeLevels.slice();
        if(prevSettings.selectionStages) target.settings.selectionStages = prevSettings.selectionStages.slice();
        if(prevSettings.modulesActive) {
            target.settings.modulesActive = Object.assign({ selection: true, lab: true, desk: true }, prevSettings.modulesActive);
        }
        if(prevSettings.worksheetMatchMode) target.settings.worksheetMatchMode = prevSettings.worksheetMatchMode;
        if(typeof prevSettings.practiceFixedTemplate === "boolean") target.settings.practiceFixedTemplate = prevSettings.practiceFixedTemplate;
        if(typeof prevSettings.practiceForceAuto === "boolean") target.settings.practiceForceAuto = prevSettings.practiceForceAuto;
        if(typeof prevSettings.startView === "string" && prevSettings.startView) {
            target.settings.startView = prevSettings.startView;
        } else if(typeof prevSettings.selectionStartsFirst === "boolean") {
            target.settings.startView = prevSettings.selectionStartsFirst ? "select" : "lab";
        }
        if(typeof prevSettings.strictMode === "boolean") target.settings.strictMode = prevSettings.strictMode;
    },
    seedLessonFromSelection: () => {
        const lessonItems = Array.isArray(appData.items) ? appData.items : [];
        if(!appData.selection || !Array.isArray(appData.selection.items)) return;
        const correctItems = appData.selection.items.filter(i => i && i.correct && i.quote);
        if(!correctItems.length) return;
        if(lessonItems.length >= correctItems.length) return;
        const existing = new Set(lessonItems.map(i => app.quoteKey(i && i.original)));
        const startIdx = lessonItems.length + 1;
        const seeded = correctItems
            .filter(i => !existing.has(app.quoteKey(i.quote)) && !app.quoteMatchesExisting(i.quote, lessonItems))
            .map((i, idx) => {
                const r = Array.isArray(i.reasons) ? i.reasons.find(Boolean) : "";
                const effect = (i.deviceReason || r || "").trim();
                return {
                    id: `auto_s${startIdx + idx}`,
                    original: i.quote,
                    translation: r || effect,
                    translationDistractors: [],
                    type: i.device || "language",
                    effect: effect,
                    effectDistractors: [],
                    levels: Array.isArray(i.levels) && i.levels.length ? i.levels.slice() : [1],
                    includeInWorksheet: true
                };
            });
        if(seeded.length) appData.items = lessonItems.concat(seeded);
    },
    loadUnifiedJson: () => {
        try {
            const raw = document.getElementById("unified-json-in").value;
            if(!raw || !raw.trim()) return alert("Paste unified JSON.");
            const j = JSON.parse(raw);
            const existingTemplates = admin.getTemplates();
            const lesson = j.lesson || (j.items && j.banks ? j : null);
            const selection = j.selection || (j.text && j.items && j.items[0] && j.items[0].quote ? j : null);
            if(lesson) {
                const prevKey = appData && appData.meta ? app.getStateKeyForMeta(appData.meta) : "";
                // Replace behavior: do not keep old banks/config unless provided.
                if(!lesson.banks) appData.banks = JSON.parse(JSON.stringify(defaultData.banks));
                if(!lesson.sentenceConfig) appData.sentenceConfig = JSON.parse(JSON.stringify(defaultData.sentenceConfig));
                if(!lesson.globalStructure) appData.globalStructure = JSON.parse(JSON.stringify(defaultData.globalStructure));
                const prev = appData ? JSON.parse(JSON.stringify(appData)) : null;
                const safe = app.repair(lesson);
                if(prevKey) localStorage.removeItem(prevKey);
                if(safe && safe.settings) {
                    safe.settings.quoteTarget = Array.isArray(safe.items) ? safe.items.length : safe.settings.quoteTarget;
                }
                if(!safe.settings.templates || !safe.settings.templates.length) safe.settings.templates = existingTemplates;
                appData = safe;
                admin.mergeLessonConfig(lesson, prev, appData);
            }
            if(selection) {
                if(!lesson) {
                    // Selection-only in unified load: reset banks/config to defaults
                    appData.banks = JSON.parse(JSON.stringify(defaultData.banks));
                    appData.sentenceConfig = JSON.parse(JSON.stringify(defaultData.sentenceConfig));
                    appData.globalStructure = JSON.parse(JSON.stringify(defaultData.globalStructure));
                }
                appData.selection = app.repairSelection(selection, { activeLevels: app.getActiveLevels(), lessonItems: appData.items });
                if(appData.settings && Array.isArray(appData.settings.selectionStages)) {
                    appData.selection.modes = appData.selection.modes || {};
                    appData.selection.modes.stages = appData.settings.selectionStages;
                }
                userState.selectionCompleted = false;
                userState.selectionStage = 1;
                userState.selectionKey = "";
                userState.selectionProgress = {};
                userState.selectionEliminated = [];
                userState.selectionChosen = [];
                admin.seedLessonFromSelection();
                admin.autoAssignSelectionLevels(false);
            }
            admin.applyModelAnswersFromItems({ overwrite: false, generate: false });
            app.save();
            ui.init();
            admin.renderAll();
        } catch(e) {
            const msg = e && e.message ? e.message : "Invalid JSON.";
            alert("Invalid JSON: " + msg);
        }
    },
    loadUnifiedFromClipboard: async () => {
        try {
            const txt = await navigator.clipboard.readText();
            if(!txt || !txt.trim()) return alert("Clipboard is empty.");
            const box = document.getElementById("unified-json-in");
            if(box) box.value = txt.trim();
            admin.loadUnifiedJson();
        } catch(e) {
            alert("Clipboard read failed. Use Paste Unified JSON instead.");
        }
    },
    toggleAiPanel: () => {
        const step2 = document.getElementById("ai-step2");
        if(!step2) return;
        const isHidden = step2.classList.contains("hidden");
        step2.classList.toggle("hidden", !isHidden);
        localStorage.setItem("tsa_ai_step2", isHidden ? "true" : "false");
    },
    ensureAiStepVisible: () => {
        const step2 = document.getElementById("ai-step2");
        if(!step2) return;
        const promptOut = document.getElementById("ai-prompt-out");
        const jsonIn = document.getElementById("ai-json-in");
        const hasPrompt = promptOut && promptOut.value && promptOut.value.trim();
        const hasJson = jsonIn && jsonIn.value && jsonIn.value.trim();
        if(hasPrompt || hasJson) step2.classList.remove("hidden");
    },
    getAiSettings: () => {
        const getLevel = (lvl) => {
            const enabledEl = document.getElementById(`ai-level-${lvl}`);
            const countEl = document.getElementById(`ai-l${lvl}-count`);
            const wordsEl = document.getElementById(`ai-l${lvl}-words`);
            const complexEl = document.getElementById(`ai-l${lvl}-complex`);
            const subtleEl = document.getElementById(`ai-l${lvl}-subtle`);
            const ellipsesEl = document.getElementById(`ai-l${lvl}-ellipsis`);
            return {
                enabled: enabledEl ? enabledEl.checked : false,
                count: countEl ? parseInt(countEl.value, 10) || 0 : 0,
                maxWords: wordsEl ? parseInt(wordsEl.value, 10) || 0 : 0,
                complexity: complexEl ? complexEl.value : "medium",
                subtlety: subtleEl ? subtleEl.value : "medium",
                ellipsesMaxWords: ellipsesEl ? parseInt(ellipsesEl.value, 10) || 0 : 0
            };
        };
        return {
            question: document.getElementById("ai-question").value,
            count: parseInt(document.getElementById("ai-count").value, 10) || 6,
            mode: document.getElementById("ai-mode").value,
            includeTone: appData && appData.settings ? appData.settings.aiIncludeTone !== false : true,
            includeStructure: appData && appData.settings ? appData.settings.aiIncludeStructure !== false : true,
            levels: Object.fromEntries(Array.from({length:9}, (_,i)=>i+1).map(l => [l, getLevel(l)]))
        };
    },
    applyAiSettings: (s) => {
        if(!s || typeof s !== 'object') return;
        if(typeof s.question === 'string') document.getElementById("ai-question").value = s.question;
        if(typeof s.count === 'number') document.getElementById("ai-count").value = s.count;
        if(typeof s.mode === 'string') document.getElementById("ai-mode").value = s.mode;
        if(!appData.settings) appData.settings = {};
        if(typeof s.includeTone === 'boolean') appData.settings.aiIncludeTone = s.includeTone;
        if(typeof s.includeStructure === 'boolean') appData.settings.aiIncludeStructure = s.includeStructure;
        const aiTone = document.getElementById("ai-include-tone");
        if(aiTone && typeof s.includeTone === 'boolean') aiTone.checked = s.includeTone;
        const aiStructure = document.getElementById("ai-include-structure");
        if(aiStructure && typeof s.includeStructure === 'boolean') aiStructure.checked = s.includeStructure;
        const applyLevel = (lvl) => {
            const l = s.levels && s.levels[lvl] ? s.levels[lvl] : {};
            const enabledEl = document.getElementById(`ai-level-${lvl}`);
            const countEl = document.getElementById(`ai-l${lvl}-count`);
            const wordsEl = document.getElementById(`ai-l${lvl}-words`);
            const complexEl = document.getElementById(`ai-l${lvl}-complex`);
            const subtleEl = document.getElementById(`ai-l${lvl}-subtle`);
            const ellipsesEl = document.getElementById(`ai-l${lvl}-ellipsis`);
            if(enabledEl && typeof l.enabled === 'boolean') enabledEl.checked = l.enabled;
            if(countEl && typeof l.count === 'number') countEl.value = l.count || "";
            if(wordsEl && typeof l.maxWords === 'number') wordsEl.value = l.maxWords || "";
            if(complexEl && typeof l.complexity === 'string') complexEl.value = l.complexity;
            if(subtleEl && typeof l.subtlety === 'string') subtleEl.value = l.subtlety;
            if(ellipsesEl && typeof l.ellipsesMaxWords === 'number') ellipsesEl.value = l.ellipsesMaxWords || "";
        };
        for(let i = 1; i <= 9; i++) applyLevel(i);
    },
    copyLevelBankToAi: () => {
        const bank = app.getLevelBank();
        if(!bank) return;
        for(let lvl = 1; lvl <= 9; lvl++) {
            const entry = bank[lvl] || {};
            const wordsEl = document.getElementById(`ai-l${lvl}-words`);
            const ellipsesEl = document.getElementById(`ai-l${lvl}-ellipsis`);
            const complexEl = document.getElementById(`ai-l${lvl}-complex`);
            const subtleEl = document.getElementById(`ai-l${lvl}-subtle`);
            if(wordsEl && entry.maxWords) wordsEl.value = entry.maxWords;
            if(ellipsesEl && entry.ellipsesMaxWords) ellipsesEl.value = entry.ellipsesMaxWords;
            if(entry.languageTier === "low") {
                if(complexEl) complexEl.value = "simple";
                if(subtleEl) subtleEl.value = "obvious";
            } else if(entry.languageTier === "medium") {
                if(complexEl) complexEl.value = "medium";
                if(subtleEl) subtleEl.value = "medium";
            } else if(entry.languageTier === "advanced") {
                if(complexEl) complexEl.value = "advanced";
                if(subtleEl) subtleEl.value = "subtle";
            }
        }
        admin.generatePrompt(true);
    },
    getTemplates: () => {
        let local = [];
        try {
            const raw = JSON.parse(localStorage.getItem("tsa_templates_v1") || "[]");
            if(Array.isArray(raw)) local = raw;
        } catch(e) {}
        const embedded = (appData && appData.settings && Array.isArray(appData.settings.templates))
            ? appData.settings.templates
            : [];
        const merged = [...local];
        embedded.forEach(t => {
            if(!t || !t.name) return;
            if(!merged.find(x => x && x.name === t.name)) merged.push(t);
        });
        return merged;
    },
    saveTemplates: (templates) => {
        localStorage.setItem("tsa_templates_v1", JSON.stringify(templates));
        if(appData && appData.settings) {
            appData.settings.templates = templates;
            app.save();
        }
    },
    refreshTemplateList: () => {
        const sel = document.getElementById("template-select");
        if(!sel) return;
        const templates = admin.getTemplates();
        sel.innerHTML = templates.length ? templates.map(t => `<option value="${t.name}">${t.name}</option>`).join('') : `<option value="">No templates</option>`;
    },
    saveTemplate: () => {
        const name = document.getElementById("template-name").value.trim();
        if(!name) return alert("Enter a template name.");
        const templates = admin.getTemplates();
        const settings = appData.settings || {};
        const templateSettings = {
            levelRules: JSON.parse(JSON.stringify(settings.levelRules || defaultData.settings.levelRules)),
            levelBank: JSON.parse(JSON.stringify(settings.levelBank || defaultData.settings.levelBank)),
            activeLevels: Array.isArray(settings.activeLevels) ? settings.activeLevels.slice() : defaultData.settings.activeLevels,
            selectionStages: Array.isArray(settings.selectionStages) ? settings.selectionStages.slice() : defaultData.settings.selectionStages,
            selectionStageConfig: appData.selection && appData.selection.stageConfigByLevel
                ? JSON.parse(JSON.stringify(appData.selection.stageConfigByLevel))
                : {},
            modulesActive: Object.assign({ selection: true, lab: true, desk: true }, settings.modulesActive || {}),
            worksheetMatchMode: settings.worksheetMatchMode || "jumbled",
            practiceFixedTemplate: !!settings.practiceFixedTemplate,
            practiceForceAuto: !!settings.practiceForceAuto,
            startView: settings.startView || "",
            strictMode: !!settings.strictMode
        };
        const payload = {
            name,
            aiSettings: admin.getAiSettings(),
            sentenceConfig: JSON.parse(JSON.stringify(appData.sentenceConfig)),
            banks: JSON.parse(JSON.stringify(appData.banks)),
            globalStructure: JSON.parse(JSON.stringify(appData.globalStructure)),
            levelBank: JSON.parse(JSON.stringify(settings.levelBank || defaultData.settings.levelBank)),
            settings: templateSettings
        };
        const idx = templates.findIndex(t => t.name === name);
        if(idx >= 0) templates[idx] = payload; else templates.push(payload);
        admin.saveTemplates(templates);
        admin.refreshTemplateList();
        document.getElementById("template-select").value = name;
    },
    loadTemplate: () => {
        const sel = document.getElementById("template-select");
        const name = sel ? sel.value : "";
        if(!name) return alert("Select a template.");
        const templates = admin.getTemplates();
        const t = templates.find(x => x.name === name);
        if(!t) return alert("Template not found.");
        admin.applyAiSettings(t.aiSettings);
        if(t.sentenceConfig && typeof t.sentenceConfig === 'object') {
            appData.sentenceConfig = JSON.parse(JSON.stringify(t.sentenceConfig));
        }
        if(t.banks && typeof t.banks === 'object') {
            appData.banks = JSON.parse(JSON.stringify(t.banks));
        }
        if(t.globalStructure && typeof t.globalStructure === 'object') {
            appData.globalStructure = JSON.parse(JSON.stringify(t.globalStructure));
            appData.globalStructure.enabled = true;
        }
        if(t.levelBank && typeof t.levelBank === "object") {
            appData.settings.levelBank = JSON.parse(JSON.stringify(t.levelBank));
        }
        if(t.settings && typeof t.settings === "object") {
            const s = t.settings;
            appData.settings = appData.settings || {};
            if(s.levelRules && typeof s.levelRules === "object") {
                appData.settings.levelRules = JSON.parse(JSON.stringify(s.levelRules));
            }
            if(s.levelBank && typeof s.levelBank === "object") {
                appData.settings.levelBank = JSON.parse(JSON.stringify(s.levelBank));
            }
            if(Array.isArray(s.activeLevels)) appData.settings.activeLevels = s.activeLevels.slice();
            if(Array.isArray(s.selectionStages)) appData.settings.selectionStages = s.selectionStages.slice();
            if(s.selectionStageConfig && typeof s.selectionStageConfig === "object") {
                if(!appData.selection) {
                    appData.selection = app.repairSelection({}, { activeLevels: app.getActiveLevels(), lessonItems: appData.items });
                }
                appData.selection.stageConfigByLevel = JSON.parse(JSON.stringify(s.selectionStageConfig));
            }
            if(s.modulesActive && typeof s.modulesActive === "object") {
                appData.settings.modulesActive = Object.assign({ selection: true, lab: true, desk: true }, s.modulesActive);
            }
            if(typeof s.worksheetMatchMode === "string") appData.settings.worksheetMatchMode = s.worksheetMatchMode;
            if(typeof s.practiceFixedTemplate === "boolean") appData.settings.practiceFixedTemplate = s.practiceFixedTemplate;
            if(typeof s.practiceForceAuto === "boolean") appData.settings.practiceForceAuto = s.practiceForceAuto;
            if(typeof s.startView === "string") appData.settings.startView = s.startView;
            else if(typeof s.selectionStartsFirst === "boolean") {
                appData.settings.startView = s.selectionStartsFirst ? "select" : "lab";
            }
            if(typeof s.strictMode === "boolean") appData.settings.strictMode = s.strictMode;
        }
        if(appData.items && appData.settings && appData.settings.levelBank) {
            const usePractice = appData.settings.practiceMode;
            const practiceLevel = appData.settings.practiceModeLevel;
            app.applyLevelRules(appData.items, appData.settings.levelBank, usePractice ? practiceLevel : undefined);
        }
        app.save();
        admin.renderAll();
    },
    generatePrompt: (silent) => {
        const aiCountEl = document.getElementById("ai-count");
        const activeLevels = (appData.settings && appData.settings.aiPromptAllLevels)
            ? Array.from({length:9}, (_,i)=>i+1)
            : app.getActiveLevels();
        const levelBank = app.getLevelBank();
        const autoTarget = activeLevels.reduce((sum, lvl) => {
            const entry = levelBank[lvl] || {};
            return sum + (entry.quoteTarget || 4) + (entry.distractorCount || 4);
        }, 0);
        if(aiCountEl) aiCountEl.value = String(autoTarget);
        const c = aiCountEl ? aiCountEl.value : autoTarget;
        const txt = (document.getElementById("ai-input").value || "").trim() || (appData.sourceText || "");
        const q = document.getElementById("ai-question").value || "How does the writer use language?";
        if(!txt) { if(!silent) alert("Paste text."); return; }
        
        const pointCount = Math.max(5, parseInt(c));
        if(!appData.settings) appData.settings = {};
        appData.settings.quoteTarget = parseInt(c, 10) || pointCount;
        const settings = admin.getAiSettings();
        const lvl = settings.levels;
        const enabledLevels = activeLevels;
        if(enabledLevels.length === 0) { if(!silent) alert("Select at least one level."); return; }
        const levelRules = enabledLevels.map(n => {
            const l = lvl[n] || {};
            const bankMax = levelBank[n] ? levelBank[n].maxWords : (n > 3 ? 30 + (n-3)*4 : 12);
            const maxWords = l.maxWords ? `max ${l.maxWords} words` : `max ${bankMax} words`;
            const count = l.count ? `Aim for ${l.count} items` : "Balanced items";
            const complexity = l.complexity || (n >= 6 ? "very advanced" : n >= 4 ? "advanced" : "medium");
            const subtlety = l.subtlety || (n >= 6 ? "very subtle" : n >= 4 ? "subtle" : "medium");
            const bankEllipses = levelBank[n] ? levelBank[n].ellipsesMaxWords : 7;
            const ellipsesRule = l.ellipsesMaxWords ? `ellipsis if > ${l.ellipsesMaxWords} words` : `ellipsis if > ${bankEllipses} words`;
            return `- L${n}: ${count}, ${maxWords}, ${complexity} meanings/analysis, ${subtlety} distractors, ${ellipsesRule}.`;
        }).join("\n");
        const levelRulesJson = JSON.stringify(Object.fromEntries(
            enabledLevels.map(n => [
                n,
                {
                    maxWords: (lvl[n] && lvl[n].maxWords) ? lvl[n].maxWords : (levelBank[n] ? levelBank[n].maxWords : 20),
                    ellipsesMaxWords: (lvl[n] && lvl[n].ellipsesMaxWords) ? lvl[n].ellipsesMaxWords : (levelBank[n] ? levelBank[n].ellipsesMaxWords : 7)
                }
            ])
        ));
        const levelBankJson = JSON.stringify(Object.fromEntries(
            enabledLevels.map(n => [
                n,
                {
                    maxWords: (levelBank[n] ? levelBank[n].maxWords : 20),
                    ellipsesMaxWords: (levelBank[n] ? levelBank[n].ellipsesMaxWords : 7),
                    languageTier: app.getLanguageTier(n)
                }
            ])
        ));
        const anyCounts = enabledLevels.some(n => (lvl[n] && (lvl[n].count || 0) > 0));
        const targetSplit = anyCounts ? enabledLevels.map(n => `${lvl[n].count || 0}`).join(" / ") : "balanced across selected levels";
        const aiDevices = app.getAiDevices();
        const allowedTypes = Object.keys(aiDevices).filter(k => aiDevices[k]);
        const typeLabel = allowedTypes.join("/");
        const balanceLine = allowedTypes.length === 1
            ? `   - All items must be ${allowedTypes[0]}.`
            : `   - Balance item types across enabled categories: ${allowedTypes.join(", ")}.`;
        const structureBlock = aiDevices.structure
            ? `7. Populate 'globalStructure': { enabled:true, items:[ {question, correct, distractors:[2]} ] } (Create 2 distinct questions about the whole text structure, relevant to the Focus Question).
   - Also include selection.structurePrompts (7‚Äì10) that align with these globalStructure ideas (paragraphing shifts, time/sequence, zoom, placement, repetition, circular structure, juxtaposition).`
            : `7. Skip globalStructure and selection.structurePrompts (structure is disabled).`;

        document.getElementById("ai-prompt-out").value = `Role: Expert English Teacher. 
Task: Create a JSON lesson for students.
Source Text: "${txt.substring(0,800)}..."
Focus Question: "${q}"

Requirements:
1. Create ${c} items. Each item object must have: { id, original (quote from text), translation (meaning), translationDistractors (2 wrong meanings), type (${typeLabel}), effect (analysis sentence), effectDistractors (2 wrong analysis sentences), levels:[1..10], includeInWorksheet:true, modelAnswer }.
   - modelAnswer must be a single string with slot labels, e.g. "MARKER: ... | STARTER: ... | QUOTE: ... | METHOD: ... | POINT: ... | LINK: ...".
   - If you can, also include per-slot fields: marker, starter, method, link (optional but preferred).
${balanceLine}
2. Assign EACH item to one level only (${enabledLevels.join(", ")}). Ensure lower levels are simpler and higher levels are more nuanced.
   - Ensure each level meets its quote target from the Level Bank. Do not leave any level short.
3. Level rules (STRICT): 
${levelRules}
   - Enforce max word limits per level. If a quote exceeds max words, shorten with ellipses per level rule and keep it faithful to the text.
   - Do NOT output quotes longer than the max for that level.
4. Manage cognitive load: keep L1 very accessible to reduce overload, L2 for regular practice, L3 to stretch comprehension, memory, and attention. Increase subtlety gradually across levels.
5. Quality target: L2 and L3 meanings/effects should model Eduqas Grade 4+ responses; L1 is simplified practice phrasing.
6. If you cannot match the exact target split (${targetSplit}) then keep the level proportions close.
${structureBlock}
8. Provide 'sentenceConfig' for each level to build grammatically correct sentences. Use:
   - L1: ["starter","quote","link_l1","point"]
   - L2: ["marker","starter","quote","method","point","link_l2"]
   - L3: ["marker","starter","quote","method","point","link_l3"]
   - L4: ["marker","starter","quote","method","manual_point","link_l3"]
   - L5: ["marker","starter","quote","manual_method","point","link_l3"]
   - L6: ["marker","manual_starter","quote","method","point","link_l3"]
   - L7: ["manual_marker","starter","quote","method","point","link_l3"]
   - L8: ["marker","starter","quote","method","point","manual_link"]
   - L9: ["marker","starter","quote","method","manual_analysis","link_l3"]
   - L10: ["marker","starter","quote","method","manual_effect","link_l3"]
9. Populate 'banks' with enough unique items per level to avoid repetition across the app:
   - markers (20+), starters (20+), methods (20+), points (${Math.max(pointCount, 20)}+), links:{l1:[10+ simple],l2:[10+ medium],l3:[10+ advanced]}.
   - Create points FIRST as full, grammatically complete analysis clauses (no capital letter needed), and make them distinct per level.
   - Ensure points slot into the sentenceConfig smoothly (e.g., after method or link), so the assembled sentence reads well without manual edits.
   - Keep markers/starter/link wording consistent with those point clauses and avoid repeating the same phrases across levels.
   - Links should be clause-openers that do NOT repeat verbs from the next element (e.g., "This suggests that" + analysis).
10. Ensure sentence elements and answers are compatible:
   - Every item should have a unique translation, effect, and point phrasing so answers are not reused for different slots.
   - Avoid reusing the same answer text across translation, effect, or point slots.
11. If possible, include per-item options for slot-level accuracy:
    - marker or markers + markerDistractors (2)
    - starter or starters + starterDistractors (2)
    - method or methods + methodDistractors (2)
    - effect + effectDistractors (2) for analysis/point slots
12. Include settings: { autoProgress:true, practiceMode:false, practiceModeLevel:1, practiceForceAuto:false, practiceFixedTemplate:false, worksheetMatchMode:"jumbled", levelRules: ${levelRulesJson}, levelBank: ${levelBankJson} }.

Output ONLY valid JSON.`;
        const step2 = document.getElementById("ai-step2");
        if(step2) {
            step2.classList.remove("hidden");
            localStorage.setItem("tsa_ai_step2", "true");
        }
    },
    loadJson: (exportAfter) => {
        try {
            let j = JSON.parse(document.getElementById("ai-json-in").value.replace(/```json|```/g, ''));
            if(Array.isArray(j)) j = { items: j };
            const mode = document.getElementById("ai-mode").value;
            const existingTemplates = admin.getTemplates();
            if(j && j.text && j.items && j.items[0] && j.items[0].quote) {
                // Clear carryover banks/config when loading selection-only JSON
                appData.banks = JSON.parse(JSON.stringify(defaultData.banks));
                appData.sentenceConfig = JSON.parse(JSON.stringify(defaultData.sentenceConfig));
                appData.globalStructure = JSON.parse(JSON.stringify(defaultData.globalStructure));
                appData.selection = app.repairSelection(j, { activeLevels: app.getActiveLevels(), lessonItems: appData.items });
                if(appData.settings && Array.isArray(appData.settings.selectionStages)) {
                    appData.selection.modes = appData.selection.modes || {};
                    appData.selection.modes.stages = appData.settings.selectionStages;
                }
                admin.seedLessonFromSelection();
                admin.autoAssignSelectionLevels(false);
                userState.selectionCompleted = false;
                userState.selectionStage = 1;
                userState.selectionKey = "";
                userState.selectionProgress = {};
                userState.selectionEliminated = [];
                userState.selectionChosen = [];
                userState.labCompleted = false;
                app.save();
                ui.init();
                admin.renderAll();
                return;
            }
            const prev = appData ? JSON.parse(JSON.stringify(appData)) : null;
            const prevKey = prev && prev.meta ? app.getStateKeyForMeta(prev.meta) : "";
            const safe = app.repair(j);
            const aiText = (document.getElementById("ai-input").value || "").trim();
            const aiQuestion = (document.getElementById("ai-question").value || "").trim();
            if(aiText && !j.sourceText) safe.sourceText = aiText;
            if(aiQuestion && !j.question) safe.question = aiQuestion;
            if((!j.meta || !j.meta.title) && aiQuestion) safe.meta.title = aiQuestion;

            const aiSettings = admin.getAiSettings && admin.getAiSettings();
            if(aiSettings && aiSettings.levels) {
                const rules = {};
                [1,2,3].forEach(lvl => {
                    rules[lvl] = {
                        maxWords: aiSettings.levels[lvl].maxWords || defaultData.settings.levelBank[lvl].maxWords,
                        ellipsesMaxWords: aiSettings.levels[lvl].ellipsesMaxWords || defaultData.settings.levelBank[lvl].ellipsesMaxWords
                    };
                });
                if(!safe.settings) safe.settings = {};
                if(!safe.settings.levelRules || typeof safe.settings.levelRules !== 'object') safe.settings.levelRules = {};
                if(!safe.settings.levelBank || typeof safe.settings.levelBank !== 'object') safe.settings.levelBank = JSON.parse(JSON.stringify(defaultData.settings.levelBank));
                [1,2,3].forEach(lvl => {
                    if(!safe.settings.levelRules[lvl]) safe.settings.levelRules[lvl] = rules[lvl];
                    if(!safe.settings.levelRules[lvl].maxWords) safe.settings.levelRules[lvl].maxWords = rules[lvl].maxWords;
                    if(!safe.settings.levelRules[lvl].ellipsesMaxWords) safe.settings.levelRules[lvl].ellipsesMaxWords = rules[lvl].ellipsesMaxWords;
                    if(!safe.settings.levelBank[lvl]) safe.settings.levelBank[lvl] = {};
                    safe.settings.levelBank[lvl].maxWords = rules[lvl].maxWords;
                    safe.settings.levelBank[lvl].ellipsesMaxWords = rules[lvl].ellipsesMaxWords;
                });
                const usePractice = safe.settings && safe.settings.practiceMode;
                const practiceLevel = safe.settings && safe.settings.practiceModeLevel;
                app.applyLevelRules(safe.items, safe.settings.levelBank, usePractice ? practiceLevel : undefined);
            }
            
            if(mode === "replace") {
                appData = safe;
                if(prevKey) localStorage.removeItem(prevKey);
                // If JSON doesn't include fresh banks/config, reset to defaults to avoid old lesson bleed.
                if(!j.banks) appData.banks = JSON.parse(JSON.stringify(defaultData.banks));
                if(!j.sentenceConfig) appData.sentenceConfig = JSON.parse(JSON.stringify(defaultData.sentenceConfig));
                if(!j.globalStructure) appData.globalStructure = JSON.parse(JSON.stringify(defaultData.globalStructure));
                admin.mergeLessonConfig(j, prev, appData);
                if(appData && appData.settings) {
                    appData.settings.quoteTarget = Array.isArray(appData.items) ? appData.items.length : appData.settings.quoteTarget;
                }
                if(!appData.settings.templates || !appData.settings.templates.length) {
                    appData.settings.templates = existingTemplates;
                }
                userState.completed = [];
                userState.completedLevels = [];
                userState.filter = "all";
                userState.showDone = false;
                userState.level = 1;
            } else if (mode === "append") {
                const current = appData.items || [];
                const incoming = (safe.items || []).filter(i => {
                    const orig = i && i.original ? i.original : "";
                    return orig && !app.quoteMatchesExisting(orig, current);
                });
                appData.items = [...current, ...incoming];
            }
            admin.applyModelAnswersFromItems({ overwrite: false, generate: false });
            app.save();
            ui.init();
            ui.renderLab();
            admin.renderAll();
            const step2 = document.getElementById("ai-step2");
            if(step2) step2.classList.remove("hidden");
            localStorage.setItem("tsa_ai_step2", "true");
            if(exportAfter) admin.exportStandalone();
        } catch(e) {
            const msg = e && e.message ? e.message : "Invalid JSON or corrupted file.";
            alert("Invalid JSON: " + msg);
        }
    },
    loadSelectionJson: () => {
        try {
            const raw = document.getElementById("selection-json-in").value;
            if(!raw || !raw.trim()) return alert("Paste selection JSON.");
            const j = JSON.parse(raw);
            const missing = [];
            if(!j || !Array.isArray(j.items) || !j.items.length) {
                return alert("Selection JSON must include items with quotes and reasons.");
            }
            const correctItems = j.items.filter(i => i && i.correct);
            const incorrectItems = j.items.filter(i => i && i.correct === false);
            const distractorCount = correctItems.reduce((sum, item) => {
                const ds = Array.isArray(item.distractors) ? item.distractors : [];
                return sum + ds.length;
            }, 0);
            j.items.forEach((item, idx) => {
                const i = idx + 1;
                if(!item || !item.quote) missing.push(`Item ${i}: missing quote`);
                if(item && item.correct) {
                    const reasons = Array.isArray(item.reasons) ? item.reasons.filter(Boolean) : [];
                    if(!reasons.length) missing.push(`Item ${i}: correct quote missing reason`);
                }
                const distractors = Array.isArray(item.distractors) ? item.distractors : [];
                distractors.forEach((d, di) => {
                    if(!d || !d.quote) missing.push(`Item ${i} distractor ${di+1}: missing quote`);
                    if(!d || !d.reason) missing.push(`Item ${i} distractor ${di+1}: missing reason`);
                });
            });
            if(!correctItems.length) {
                missing.push("At least 1 correct quote is required.");
            }
            if(!incorrectItems.length && distractorCount < 2) {
                missing.push("Provide incorrect items or at least 2 distractors.");
            }
            if(missing.length) {
                return alert("Selection JSON has missing fields:\n" + missing.slice(0, 10).join("\n"));
            }
            appData.selection = app.repairSelection(j, { activeLevels: app.getActiveLevels(), lessonItems: appData.items });
            if(appData.settings && Array.isArray(appData.settings.selectionStages)) {
                appData.selection.modes = appData.selection.modes || {};
                appData.selection.modes.stages = appData.settings.selectionStages;
            }
            admin.seedLessonFromSelection();
            admin.autoAssignSelectionLevels(false);
            userState.selectionCompleted = false;
            userState.selectionStage = 1;
            userState.selectionKey = "";
            userState.selectionProgress = {};
            userState.selectionEliminated = [];
            userState.selectionChosen = [];
            userState.labCompleted = false;
            app.save();
            ui.init();
            admin.renderAll();
        } catch(e) {
            const msg = e && e.message ? e.message : "Invalid JSON.";
            alert("Invalid JSON. Paste ONLY the JSON output (no plain text). Details: " + msg);
        }
    },
    generateSelectionPrompt: () => {
        const text = (document.getElementById("ai-input").value || "").trim() || (appData.sourceText || "");
        const q = document.getElementById("ai-question").value || "How does the writer use language?";
        if(!text.trim()) return alert("Paste source text first.");
        const activeLevels = app.getActiveLevels();
        const levelBank = app.getLevelBank();
        const aiDevices = app.getAiDevices();
        const allowedTypes = Object.keys(aiDevices).filter(k => aiDevices[k]);
        const typeLabel = allowedTypes.join("/");
        const targetSummary = activeLevels.map(lvl => {
            const entry = levelBank[lvl] || {};
            const tq = entry.quoteTarget || 4;
            const td = entry.distractorCount || 4;
            return `- L${lvl}: ${tq} correct quotes, ${td} distractors`;
        }).join("\\n");
        const totalTarget = activeLevels.reduce((sum, lvl) => {
            const entry = levelBank[lvl] || {};
            return sum + (entry.quoteTarget || 4) + (entry.distractorCount || 4);
        }, 0);
        const prompt = `Role: Expert English Teacher
Task: Create a JSON template for quote-selection practice.

Source Text: "${text.substring(0,800)}..."
Focus Question: "${q}"

Requirements:
1. Output valid JSON following this schema (NO empty strings):
{
  meta:{title, level, author, version},
  text:{source, type, wordCount},
  question:{prompt, focusTags[]},
  structurePrompts:[...],
  items:[{id, quote, correct:true|false, reasons[2], distractors:[{quote, reason}], levels:[1..9], device:"${typeLabel}", deviceReason}],
  modes:{selectionMode:"closed"|"open", showHints:true|false, requireReason:true|false, quoteCount, stages:["recognize","guided","justify","open"]}
}
2. Create quotes for ALL active levels (required):
${targetSummary}
   - Assign each item to one level via levels:[level]
   - Ensure each level has AT LEAST its target number of correct quotes (no short levels)
   - All quotes must be from the source text
3. For every correct quote, include device (${typeLabel}) and a short deviceReason.
4. ${aiDevices.structure ? "Include structurePrompts (7‚Äì10) that guide structural discussion (e.g., paragraphing shifts, time/sequence, zoom, placement, repetition, circular structure, juxtaposition)." : "Skip structurePrompts (structure is disabled)."}
5. Write at least 1 short reason for the correct quote (no blanks). Prefer 2.
6. Each correct quote must include 2+ distractors, each with a reason explaining why it is weaker (no blanks).
7. Use accessible language (Entry 3 ‚Äì Grade 3).
8. Avoid reusing the same answer text across reasons or deviceReason.
9. If a quote cannot be justified as noise, include it anyway with a plausible reason.
10. Use UK English spelling throughout (e.g., humanises, emphasises, organise).
11. Match the language complexity for each item to its levelBank.languageTier (low/medium/advanced) across all levels globally.
12. Do NOT use placeholders like "Reason needed." or "Weaker choice." Use real reasons.
13. Total target = ${totalTarget} quotes. If the text cannot supply that many real quotes, include as many as possible and mark each as correct:true/false accordingly.
14. Make incorrect quotes plausible (near-miss): choose lines that are thematically related but do not answer the question as well as the correct quotes. Avoid obvious random lines.

Output ONLY JSON.`;
        const out = document.getElementById("selection-prompt-out");
        if(out) out.value = prompt;
    },
    copySelectionPrompt: async () => {
        const out = document.getElementById("selection-prompt-out");
        if(!out || !out.value.trim()) return alert("Generate the prompt first.");
        try {
            await navigator.clipboard.writeText(out.value);
            alert("Prompt copied to clipboard.");
        } catch(e) {
            out.focus();
            out.select();
            alert("Copy failed. The prompt is selected‚Äîpress Ctrl/Cmd+C.");
        }
    },
    pasteSelectionJson: async () => {
        try {
            const txt = await navigator.clipboard.readText();
            if(!txt || !txt.trim()) return alert("Clipboard is empty.");
            const box = document.getElementById("selection-json-in");
            if(box) box.value = txt.trim();
        } catch(e) {
            alert("Paste failed. Use Ctrl/Cmd+V in the Selection JSON box.");
        }
    },
    clearSelectionGate: () => {
        userState.selectionCompleted = true;
        app.save();
        ui.init();
    },
    renderSelectionEditor: () => {
        admin.ensureSelectionData();
        const wrap = document.getElementById("selection-editor-list");
        if(!wrap) return;
        const sel = appData.selection;
        const focusTags = Array.isArray(sel.question.focusTags) ? sel.question.focusTags.join(", ") : "";
        const levelBank = app.getLevelBank();
        const activeLevels = app.getActiveLevels();
        const getTarget = (lvl) => {
            const entry = levelBank && levelBank[lvl] ? levelBank[lvl] : {};
            return (entry.quoteTarget) ? parseInt(entry.quoteTarget, 10)
                : (appData.settings && appData.settings.quoteTarget) ? parseInt(appData.settings.quoteTarget, 10)
                : (sel.modes && sel.modes.quoteTarget) ? parseInt(sel.modes.quoteTarget, 10)
                : (sel.modes && sel.modes.quoteCount) ? parseInt(sel.modes.quoteCount, 10)
                : 4;
        };
        const correctCountFor = (lvl) => sel.items.filter(i => i && i.correct && Array.isArray(i.levels) && i.levels.includes(lvl)).length;
        const incorrectCountFor = (lvl) => sel.items.filter(i => i && !i.correct && Array.isArray(i.levels) && i.levels.includes(lvl)).length;
        let totalTarget = 0;
        let totalCorrect = 0;
        let totalIncorrect = 0;
        const summaryRows = activeLevels.map(lvl => {
            const target = getTarget(lvl);
            const correct = correctCountFor(lvl);
            const incorrect = incorrectCountFor(lvl);
            totalTarget += target;
            totalCorrect += correct;
            totalIncorrect += incorrect;
            const status = correct < target
                ? `<span style="color:var(--error); font-weight:700;">Short by ${target - correct}</span>`
                : `<span style="color:var(--success); font-weight:700;">OK</span>`;
            return `<div style="display:grid; grid-template-columns: 60px 1fr 1fr; gap:8px; align-items:center; padding:4px 0; border-bottom:1px dashed var(--border);">
                <div style="font-weight:700;">L${lvl}</div>
                <div>Correct: <strong>${correct}</strong> / ${target} ${status}</div>
                <div>Distractors: <strong>${incorrect}</strong></div>
            </div>`;
        }).join("");
        const totalStatus = totalCorrect < totalTarget
            ? `<span style="color:var(--error); font-weight:700;">Short by ${totalTarget - totalCorrect}</span>`
            : `<span style="color:var(--success); font-weight:700;">OK</span>`;
        const totalsRow = `<div style="display:grid; grid-template-columns: 60px 1fr 1fr; gap:8px; align-items:center; padding:6px 0; margin-top:4px;">
            <div style="font-weight:700;">All</div>
            <div>Total correct: <strong>${totalCorrect}</strong> / ${totalTarget} ${totalStatus}</div>
            <div>Total distractors: <strong>${totalIncorrect}</strong></div>
        </div>`;
        wrap.innerHTML = `
            <div class="input-group">
                <label>Enable Quote Selection</label>
                <label style="display:flex; align-items:center; gap:6px; font-size:0.9rem;">
                    <input type="checkbox" id="selection-enabled" ${sel.enabled ? "checked" : ""} onchange="admin.updateSelectionMeta('enabled', this.checked)"> Enabled
                </label>
            </div>
            <div class="input-group">
                <label>Question Prompt</label>
                <input type="text" id="selection-question" value="${app.escapeHtml(sel.question.prompt || "")}" onchange="admin.updateSelectionMeta('prompt', this.value)">
            </div>
            <div class="input-group">
                <label>Focus Tags (CSV, synonyms with ":" e.g., fear: dread, terror)</label>
                <input type="text" id="selection-focus-tags" value="${app.escapeHtml(focusTags)}" onchange="admin.updateSelectionMeta('focusTags', this.value)">
            </div>
            <div class="input-group">
                <label>Structural prompts (one per line)</label>
                <textarea id="selection-structure-prompts" onchange="admin.updateSelectionMeta('structurePrompts', this.value)" style="height:90px;">${app.escapeHtml((sel.structurePrompts || []).join("\\n"))}</textarea>
                <div style="margin-top:6px;">
                    <button class="btn btn-outline btn-small" onclick="admin.useGlobalStructurePrompts()">Use Global Structure questions</button>
                </div>
            </div>
            <div class="input-group">
                <label>Quote Count (shown per stage)</label>
                <input type="number" id="selection-quote-count" min="2" max="10" value="${parseInt(sel.modes.quoteCount, 10) || 4}" onchange="admin.updateSelectionMeta('quoteCount', this.value)">
            </div>
            <div class="input-group">
                <label>Quick Pick Mode</label>
                <label style="display:flex; align-items:center; gap:6px; font-size:0.9rem;">
                    <input type="checkbox" ${sel.modes.quickPick ? "checked" : ""} onchange="admin.updateSelectionMeta('quickPick', this.checked)"> Pick one quote at a time (skip other stages)
                </label>
            </div>
            <div class="input-group">
                <label>Selection Devices</label>
                <div class="level-checks" style="margin-top:0;">
                    <label>Language<input type="checkbox" ${appData.settings.selectionDevices && appData.settings.selectionDevices.language !== false ? "checked" : ""} onchange="admin.setSelectionDevice('language', this.checked)"></label>
                    <label>Tone<input type="checkbox" ${appData.settings.selectionDevices && appData.settings.selectionDevices.tone ? "checked" : ""} onchange="admin.setSelectionDevice('tone', this.checked)"></label>
                    <label>Structure<input type="checkbox" ${appData.settings.selectionDevices && appData.settings.selectionDevices.structure ? "checked" : ""} onchange="admin.setSelectionDevice('structure', this.checked)"></label>
                </div>
                <div style="font-size:0.8rem; opacity:0.7;">Only selected devices appear in Quote Selection.</div>
            </div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; margin:6px 0 10px 0;">
                <button class="btn btn-outline btn-small" onclick="admin.capSelectionCountsToTargets()">Cap counts to targets</button>
            </div>
            <div class="input-group">
                <label>Correct-only Choices</label>
                <label style="display:flex; align-items:center; gap:6px; font-size:0.9rem;">
                    <input type="checkbox" ${sel.modes.correctOnly ? "checked" : ""} onchange="admin.updateSelectionMeta('correctOnly', this.checked)"> Show only correct quotes (no wrong choices)
                </label>
            </div>
            <div class="input-group">
                <label>Require Justification</label>
                <label style="display:flex; align-items:center; gap:6px; font-size:0.9rem;">
                    <input type="checkbox" ${sel.modes.requireReason ? "checked" : ""} onchange="admin.updateSelectionMeta('requireReason', this.checked)"> Require reason before saving quotes
                </label>
            </div>
            <div class="input-group">
                <label>Quote Check (per level)</label>
                <div style="font-size:0.85rem; opacity:0.8; margin-bottom:2px;">Targets come from Level Bank ‚Üí Quotes.</div>
                <div style="font-size:0.8rem; opacity:0.7; margin-bottom:6px;">Set quote targets and distractors per level in the Level Bank.</div>
                <div>${summaryRows || "<div style='opacity:0.7;'>No active levels found.</div>"}</div>
                ${summaryRows ? totalsRow : ""}
                ${summaryRows ? `<div style="margin-top:8px;"><button class="btn btn-outline btn-small" onclick="admin.autoFillCorrectQuotes()">Auto-fill correct quotes to targets</button></div>` : ""}
            </div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; margin:6px 0 10px 0;">
                <button class="btn btn-outline btn-small" onclick="admin.autoFillSelectionDevices()">Auto-fill device (tone/language/structure)</button>
                <button class="btn btn-outline btn-small" onclick="admin.autoFillSelectionDeviceReasons()">Auto-fill device reason</button>
                <button class="btn btn-outline btn-small" onclick="admin.autoAssignSelectionLevels()">Auto-assign levels (match targets)</button>
                <button class="btn btn-outline btn-small" onclick="admin.autoAssignSelectionLevels(true)">Auto-assign levels (unassigned only)</button>
            </div>
            <div id="selection-cap-status" style="font-size:0.8rem; opacity:0.7; margin:6px 0;"></div>
            <div style="font-weight:700; margin:10px 0 6px 0;">Quotes</div>
            ${sel.items.map((item, idx) => {
                const reasons = Array.isArray(item.reasons) ? item.reasons.join("\\n") : "";
                const distractors = Array.isArray(item.distractors)
                    ? item.distractors.map(d => `${d.quote || ""} || ${d.reason || ""}`).join("\\n")
                    : "";
                const inSource = app.quoteInSource(item.quote, sel.text && sel.text.source ? sel.text.source : appData.sourceText);
                return `
                    <div class="quote-editor" id="selection-editor-${idx}">
                        <div class="editor-header">#${idx+1}
                            <button class="btn btn-danger btn-small" onclick="admin.delSelectionItem(${idx})">Del</button>
                        </div>
                        <div class="input-group"><label>Quote</label><input value="${app.escapeHtml(item.quote || "")}" onchange="admin.updateSelectionItem(${idx}, 'quote', this.value)"></div>
                        ${inSource ? "" : `<div style="font-size:0.8rem; color:var(--error); margin-bottom:6px;">Not found in source text.</div>`}
                        <div class="input-group"><label>Device (tone / language / structure)</label>
                            <select onchange="admin.updateSelectionItem(${idx}, 'device', this.value)">
                                <option value="" ${!item.device ? "selected" : ""}>Select...</option>
                                <option value="tone" ${item.device==="tone" ? "selected" : ""}>Tone</option>
                                <option value="language" ${item.device==="language" ? "selected" : ""}>Language</option>
                                <option value="structure" ${item.device==="structure" ? "selected" : ""}>Structure</option>
                            </select>
                        </div>
                        <div class="input-group"><label>Device reason (short)</label><input value="${app.escapeHtml(item.deviceReason || "")}" onchange="admin.updateSelectionItem(${idx}, 'deviceReason', this.value)"></div>
                        <div class="input-group"><label>Analysis-worthy</label><label style="display:flex; align-items:center; gap:6px; font-size:0.9rem;"><input type="checkbox" ${item.correct ? "checked" : ""} onchange="admin.updateSelectionItem(${idx}, 'correct', this.checked)"> Correct</label></div>
                        <div class="input-group"><label>Reasons (one per line)</label><textarea onchange="admin.updateSelectionItem(${idx}, 'reasons', this.value)" style="height:70px;">${app.escapeHtml(reasons)}</textarea></div>
                        <div class="input-group"><label>Distractors (one per line: quote || reason)</label><textarea onchange="admin.updateSelectionItem(${idx}, 'distractors', this.value)" style="height:90px;">${app.escapeHtml(distractors)}</textarea></div>
                    </div>
                `;
            }).join("")}
        `;
    },
    updateSelectionMeta: (key, value) => {
        admin.ensureSelectionData();
        if(key === "enabled") {
            appData.selection.enabled = !!value;
        } else if(key === "prompt") {
            appData.selection.question.prompt = String(value || "");
            appData.question = appData.selection.question.prompt || appData.question;
        } else if(key === "focusTags") {
            const tags = String(value || "").split(",").map(t => t.trim()).filter(Boolean);
            appData.selection.question.focusTags = tags;
        } else if(key === "structurePrompts") {
            const prompts = String(value || "").split(/\n+/).map(v => v.trim()).filter(Boolean);
            appData.selection.structurePrompts = prompts;
        } else if(key === "quoteCount") {
            const n = Math.max(2, Math.min(10, parseInt(value, 10) || 4));
            appData.selection.modes.quoteCount = n;
        } else if(key === "requireReason") {
            appData.selection.modes.requireReason = !!value;
        } else if(key === "quickPick") {
            appData.selection.modes.quickPick = !!value;
        } else if(key === "correctOnly") {
            appData.selection.modes.correctOnly = !!value;
        }
        app.save();
        ui.init();
        admin.renderSelectionEditor();
    },
    updateSelectionItem: (idx, key, value) => {
        admin.ensureSelectionData();
        const item = appData.selection.items[idx];
        if(!item) return;
        if(!Array.isArray(item.levels) || !item.levels.length) {
            item.levels = [app.getEffectiveLevel()];
        }
        if(key === "quote") {
            item.quote = String(value || "");
        } else if(key === "device") {
            const v = String(value || "").toLowerCase();
            item.device = (v === "tone" || v === "language" || v === "structure") ? v : "";
        } else if(key === "deviceReason") {
            item.deviceReason = String(value || "").trim();
        } else if(key === "correct") {
            item.correct = !!value;
        } else if(key === "reasons") {
            item.reasons = String(value || "").split(/\n+/).map(v => v.trim()).filter(Boolean);
        } else if(key === "distractors") {
            const lines = String(value || "").split(/\n+/).map(v => v.trim()).filter(Boolean);
            item.distractors = lines.map((line, i) => {
                const parts = line.split("||").map(p => p.trim());
                return { id: `sd${idx+1}_${i+1}`, quote: parts[0] || "", reason: parts[1] || "" };
            });
        }
        app.save();
        ui.renderSelection();
    },
    useGlobalStructurePrompts: () => {
        admin.ensureSelectionData();
        const globals = appData.globalStructure && Array.isArray(appData.globalStructure.items)
            ? appData.globalStructure.items
            : [];
        const prompts = globals
            .map(g => g && g.question ? String(g.question).trim() : "")
            .filter(Boolean);
        if(!prompts.length) return alert("No Global Structure questions found.");
        appData.selection.structurePrompts = prompts;
        app.save();
        admin.renderSelectionEditor();
    },
    autoFillCorrectQuotes: () => {
        admin.ensureSelectionData();
        const sel = appData.selection;
        if(!sel || !Array.isArray(sel.items) || !sel.items.length) return;
        const levelBank = app.getLevelBank();
        const activeLevels = app.getActiveLevels();
        const getTarget = (lvl) => {
            const entry = levelBank && levelBank[lvl] ? levelBank[lvl] : {};
            return (entry.quoteTarget) ? parseInt(entry.quoteTarget, 10)
                : (appData.settings && appData.settings.quoteTarget) ? parseInt(appData.settings.quoteTarget, 10)
                : (sel.modes && sel.modes.quoteTarget) ? parseInt(sel.modes.quoteTarget, 10)
                : (sel.modes && sel.modes.quoteCount) ? parseInt(sel.modes.quoteCount, 10)
                : 4;
        };
        const isLevelMatch = (item, lvl) => (!Array.isArray(item.levels) || item.levels.includes(lvl));
        const normalizeLine = (s) => String(s || "").replace(/\s+/g, " ").trim();
        const buildDistractorsFromQuotes = (base, pool, count) => {
            const items = pool
                .map(p => ({ quote: p, reason: "This quote doesn't support the answer as well." }))
                .filter(p => p.quote && app.quoteKey(p.quote) !== app.quoteKey(base));
            return app.shuffle(items).slice(0, count).map((d, i) => ({ id: `sd_auto_${Date.now()}_${i+1}`, quote: d.quote, reason: d.reason }));
        };
        activeLevels.forEach(lvl => {
            const target = getTarget(lvl);
            const correctItems = sel.items.filter(i => i && i.correct && isLevelMatch(i, lvl));
            let needed = Math.max(0, target - correctItems.length);
            if(!needed) return;
            const promotable = sel.items.filter(i => i && !i.correct && isLevelMatch(i, lvl));
            promotable.slice(0, needed).forEach(i => {
                i.correct = true;
                if(!Array.isArray(i.reasons) || !i.reasons.length) i.reasons = ["Strong evidence."];
                // Rebuild distractors from other quotes at the same level.
                const sameLevelQuotes = sel.items
                    .filter(x => x && x.quote && x !== i && isLevelMatch(x, lvl))
                    .map(x => normalizeLine(x.quote));
                i.distractors = buildDistractorsFromQuotes(normalizeLine(i.quote), sameLevelQuotes, 2);
            });
        });
        app.save();
        admin.renderSelectionEditor();
        ui.renderSelection();
    },
    autoFillSelectionDevices: () => {
        admin.ensureSelectionData();
        if(!Array.isArray(appData.items) || !appData.items.length) {
            return alert("No lesson items found to map devices from.");
        }
        const lessonMap = new Map();
        appData.items.forEach(it => {
            const key = it && it.original ? app.quoteKey(it.original) : "";
            const type = it && typeof it.type === "string" ? it.type.toLowerCase() : "";
            if(key && (type === "tone" || type === "language" || type === "structure")) {
                lessonMap.set(key, type);
            }
        });
        let updated = 0;
        appData.selection.items.forEach(item => {
            if(item && item.quote && !item.device) {
                const key = app.quoteKey(item.quote);
                const device = lessonMap.get(key);
                if(device) {
                    item.device = device;
                    updated += 1;
                }
            }
        });
        if(updated) {
            app.save();
            admin.renderSelectionEditor();
        } else {
            alert("No devices were auto-filled. Make sure quotes match lesson items and have type set.");
        }
    },
    autoFillSelectionDeviceReasons: () => {
        admin.ensureSelectionData();
        let updated = 0;
        appData.selection.items.forEach(item => {
            if(!item || item.deviceReason) return;
            const reasons = Array.isArray(item.reasons) ? item.reasons.filter(Boolean) : [];
            if(reasons.length) {
                item.deviceReason = reasons[0];
                updated += 1;
                return;
            }
            if(item.device) {
                item.deviceReason = `This quote shows ${item.device}.`;
                updated += 1;
            }
        });
        if(updated) {
            app.save();
            admin.renderSelectionEditor();
        } else {
            alert("No device reasons were auto-filled.");
        }
    },
    autoAssignSelectionLevels: (unassignedOnly) => {
        admin.ensureSelectionData();
        const sel = appData.selection;
        if(!sel || !Array.isArray(sel.items) || !sel.items.length) return;
        const levelBank = app.getLevelBank();
        const activeLevels = app.getActiveLevels();
        const isInSource = (q) => app.quoteInSource(q, sel.text && sel.text.source ? sel.text.source : appData.sourceText);
        const baseFilter = (i) => i && i.quote && isInSource(i.quote);
        const levelUnset = (i) => !Array.isArray(i.levels) || !i.levels.length;
        const correctItems = sel.items.filter(i => i && i.correct && baseFilter(i) && (!unassignedOnly || levelUnset(i)));
        const incorrectItems = sel.items.filter(i => i && !i.correct && baseFilter(i) && (!unassignedOnly || levelUnset(i)));
        const targets = {};
        activeLevels.forEach(lvl => {
            const entry = levelBank[lvl] || {};
            targets[lvl] = {
                correct: entry.quoteTarget || 0,
                incorrect: entry.distractorCount || 0
            };
        });
        const assignPool = (items, key, preserve) => {
            let idx = 0;
            const levels = activeLevels.slice();
            const expanded = [];
            levels.forEach(lvl => {
                const count = targets[lvl][key] || 0;
                for(let i = 0; i < count; i++) expanded.push(lvl);
            });
            if(!expanded.length) return;
            items.forEach(item => {
                const lvl = expanded[idx % expanded.length];
                if(!preserve || !Array.isArray(item.levels) || !item.levels.length) {
                    item.levels = [lvl];
                }
                idx += 1;
            });
        };
        // Auto-assign only when a level is short (preserve existing assignments).
        // Count unique quotes per level (same quote text only counts once).
        const countByLevel = (items, uniqueByQuote) => {
            const counts = Object.fromEntries(activeLevels.map(l => [l, 0]));
            if(uniqueByQuote) {
                activeLevels.forEach(lvl => {
                    const keys = new Set();
                    items.forEach(it => {
                        const lvlAssigned = Array.isArray(it.levels) && it.levels.length ? it.levels[0] : null;
                        if(lvlAssigned === lvl && it.quote) {
                            keys.add(app.quoteKey(it.quote));
                        }
                    });
                    counts[lvl] = keys.size;
                });
            } else {
                items.forEach(it => {
                    const lvl = Array.isArray(it.levels) && it.levels.length ? it.levels[0] : null;
                    if(lvl && counts[lvl] !== undefined) counts[lvl] += 1;
                });
            }
            return counts;
        };
        const correctCounts = countByLevel(correctItems, true);
        activeLevels.forEach(lvl => {
            const needed = Math.max(0, (targets[lvl].correct || 0) - (correctCounts[lvl] || 0));
            if(!needed) return;
            const alreadyOnLevel = new Set(
                correctItems.filter(i => Array.isArray(i.levels) && i.levels.includes(lvl)).map(i => app.quoteKey(i.quote))
            );
            const candidates = correctItems.filter(i => !Array.isArray(i.levels) || !i.levels.length || !i.levels.includes(lvl));
            let assigned = 0;
            for(let i = 0; i < candidates.length && assigned < needed; i++) {
                const it = candidates[i];
                const key = app.quoteKey(it.quote);
                if(alreadyOnLevel.has(key)) continue;
                alreadyOnLevel.add(key);
                it.levels = [lvl];
                assigned += 1;
            }
        });
        const incorrectCounts = countByLevel(incorrectItems, true);
        activeLevels.forEach(lvl => {
            const needed = Math.max(0, (targets[lvl].incorrect || 0) - (incorrectCounts[lvl] || 0));
            if(!needed) return;
            const alreadyOnLevel = new Set(
                incorrectItems.filter(i => Array.isArray(i.levels) && i.levels.includes(lvl)).map(i => app.quoteKey(i.quote))
            );
            const candidates = incorrectItems.filter(i => !Array.isArray(i.levels) || !i.levels.length || !i.levels.includes(lvl));
            let assigned = 0;
            for(let i = 0; i < candidates.length && assigned < needed; i++) {
                const it = candidates[i];
                const key = app.quoteKey(it.quote);
                if(alreadyOnLevel.has(key)) continue;
                alreadyOnLevel.add(key);
                it.levels = [lvl];
                assigned += 1;
            }
        });
        app.save();
        admin.renderSelectionEditor();
        ui.renderSelection();
    },
    capSelectionCountsToTargets: () => {
        admin.ensureSelectionData();
        const sel = appData.selection;
        if(!sel || !Array.isArray(sel.items)) return;
        const levelBank = app.getLevelBank();
        const activeLevels = app.getActiveLevels();
        const getLevels = (item) => Array.isArray(item.levels)
            ? item.levels.map(n => parseInt(n, 10)).filter(n => !isNaN(n))
            : [];
        const isLevelMatch = (item, lvl) => getLevels(item).includes(lvl);
        const summary = [];
        activeLevels.forEach(lvl => {
            const entry = levelBank[lvl] || {};
            const targetCorrect = entry.quoteTarget || 0;
            const targetIncorrect = entry.distractorCount || 0;
            const correctItems = sel.items.filter(i => i && i.correct && isLevelMatch(i, lvl));
            const incorrectItems = sel.items.filter(i => i && !i.correct && isLevelMatch(i, lvl));
            if(correctItems.length > targetCorrect) {
                correctItems.slice(targetCorrect).forEach(i => { i.correct = false; });
            }
            if(incorrectItems.length > targetIncorrect) {
                incorrectItems.slice(targetIncorrect).forEach(i => { i.correct = false; });
            }
            const afterCorrect = sel.items.filter(i => i && i.correct && isLevelMatch(i, lvl)).length;
            const afterIncorrect = sel.items.filter(i => i && !i.correct && isLevelMatch(i, lvl)).length;
            summary.push(`L${lvl}: targetC=${targetCorrect} targetI=${targetIncorrect} afterC=${afterCorrect} afterI=${afterIncorrect}`);
        });
        app.save();
        admin.renderSelectionEditor();
        ui.renderSelection();
        const status = document.getElementById("selection-cap-status");
        if(status) status.textContent = "Cap counts summary: " + summary.join(" | ");
        alert("Cap counts summary:\n" + summary.join("\n"));
    },
    addSelectionItem: () => {
        admin.ensureSelectionData();
        appData.selection.items.push({
            id: "s" + Date.now(),
            quote: "New quote",
            correct: false,
            reasons: ["Reason 1", "Reason 2"],
            distractors: [{ id: "sd_new_1", quote: "Distractor quote", reason: "Weaker reason" }],
            levels: [app.getEffectiveLevel()]
        });
        app.save();
        admin.renderSelectionEditor();
    },
    delSelectionItem: (idx) => {
        admin.ensureSelectionData();
        appData.selection.items.splice(idx, 1);
        app.save();
        admin.renderSelectionEditor();
        ui.renderSelection();
    },

    // BANK EDITOR
    editBank: (key) => {
        currentBankKey = key;
        document.getElementById('bank-editor-ui').classList.remove('hidden');
        document.getElementById('bank-name-display').innerText = "Editing: " + key.toUpperCase();
        
        let list = [];
        if(key.includes('link')) {
            const l = key.split('_')[1];
            list = appData.banks.links[l] || [];
        } else {
            list = appData.banks[key] || [];
        }

        const cont = document.getElementById('bank-list-container');
        cont.innerHTML = list.map((val, i) => 
            `<span class="bank-tag">${val}<button onclick="admin.removeBankItem(${i})">x</button></span>`
        ).join('');
    },

    addBankItem: () => {
        const val = document.getElementById('bank-add-input').value;
        if(!val || !currentBankKey) return;
        
        if(currentBankKey.includes('link')) {
            const l = currentBankKey.split('_')[1];
            if(!appData.banks.links[l]) appData.banks.links[l] = [];
            appData.banks.links[l].push(val);
        } else {
            if(!appData.banks[currentBankKey]) appData.banks[currentBankKey] = [];
            appData.banks[currentBankKey].push(val);
        }
        app.save();
        admin.editBank(currentBankKey); 
        document.getElementById('bank-add-input').value = '';
    },

    removeBankItem: (idx) => {
        if(currentBankKey.includes('link')) {
            const l = currentBankKey.split('_')[1];
            appData.banks.links[l].splice(idx, 1);
        } else {
            appData.banks[currentBankKey].splice(idx, 1);
        }
        app.save();
        admin.editBank(currentBankKey);
    },

    renderConfig: function(lvl) {
        currentConfigLevel = lvl;
        const sel = document.getElementById('config-level-select');
        if(sel) sel.value = String(lvl);
        const cont = document.getElementById('config-slots'); cont.innerHTML = '';
        if(!appData.selection) {
            appData.selection = app.repairSelection({}, { activeLevels: app.getActiveLevels(), lessonItems: appData.items });
        }
        const slots = appData.sentenceConfig[lvl];
        const allOpts = ['marker', 'starter', 'quote', 'method', 'analysis', 'link_l1', 'link_l2', 'link_l3', 'point', 'manual_marker', 'manual_starter', 'manual_method', 'manual_point', 'manual_link', 'manual_analysis', 'manual_effect'];
        
        for(let i=0; i<6; i++) {
            const sel = document.createElement('select');
            sel.innerHTML = `<option value="none">None</option>` + allOpts.map(o => `<option value="${o}" ${slots[i]===o?'selected':''}>${o}</option>`).join('');
            sel.onchange = () => {
                const arr = Array.from(cont.querySelectorAll('select')).map(s=>s.value).filter(v=>v!=='none');
                appData.sentenceConfig[lvl] = arr; app.save();
            };
            cont.appendChild(sel);
        }
        const stageKeys = ["discriminate","align","justify"];
        if(!appData.selection.stageConfigByLevel || typeof appData.selection.stageConfigByLevel !== "object") {
            appData.selection.stageConfigByLevel = {};
        }
        if(!appData.selection.stageConfigByLevel[lvl]) {
            appData.selection.stageConfigByLevel[lvl] = {};
        }
        stageKeys.forEach(k => {
            if(appData.selection.stageConfigByLevel[lvl][k] !== "free") {
                appData.selection.stageConfigByLevel[lvl][k] = "choice";
            }
        });
        const stageWrap = document.createElement("div");
        stageWrap.style.marginTop = "10px";
        stageWrap.innerHTML = `
            <div style="font-size:0.85rem; font-weight:700; margin-bottom:6px;">Quote Selection Tab Modes (Level ${lvl})</div>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
                <label style="font-size:0.85rem;">Tone/Language/Structure
                    <select data-stage="align" style="width:100%; padding:4px; margin-top:4px;">
                        <option value="choice">Choice</option>
                        <option value="free">Free response</option>
                    </select>
                </label>
                <label style="font-size:0.85rem;">Justify
                    <select data-stage="justify" style="width:100%; padding:4px; margin-top:4px;">
                        <option value="choice">Choice</option>
                        <option value="free">Free response</option>
                    </select>
                </label>
            </div>
        `;
        Array.from(stageWrap.querySelectorAll("select")).forEach(s => {
            const key = s.dataset.stage;
            s.value = appData.selection.stageConfigByLevel[lvl][key] || "choice";
            s.addEventListener("change", () => admin.updateSelectionStageConfig(lvl, key, s.value));
        });
        cont.appendChild(stageWrap);
    },
    renderLevelBank: function() {
        const wrap = document.getElementById("level-bank-editor");
        if(!wrap) return;
        if(!appData.settings.levelBank) appData.settings.levelBank = JSON.parse(JSON.stringify(defaultData.settings.levelBank));
        const rows = [];
        for(let lvl = 1; lvl <= 9; lvl++) {
            const entry = appData.settings.levelBank[lvl] || defaultData.settings.levelBank[lvl];
            const freeSelect = !!entry.freeSelectFromText;
            rows.push(`
                <div class="level-bank-row" style="display:grid; gap:6px; align-items:center; margin-bottom:6px;">
                    <div style="font-weight:700;">L${lvl}</div>
                    <input type="number" min="3" value="${entry.maxWords}" data-lvl="${lvl}" data-key="maxWords" class="level-bank-input" placeholder="Max words">
                    <input type="number" min="3" value="${entry.ellipsesMaxWords}" data-lvl="${lvl}" data-key="ellipsesMaxWords" class="level-bank-input" placeholder="Ellipses at">
                    <select data-lvl="${lvl}" data-key="languageTier" class="level-bank-input">
                        <option value="low" ${entry.languageTier==="low"?"selected":""}>Low</option>
                        <option value="medium" ${entry.languageTier==="medium"?"selected":""}>Medium</option>
                        <option value="advanced" ${entry.languageTier==="advanced"?"selected":""}>Advanced</option>
                    </select>
                    <input type="number" min="1" value="${entry.quoteTarget || ""}" data-lvl="${lvl}" data-key="quoteTarget" class="level-bank-input" placeholder="Quotes">
                    <input type="number" min="1" value="${entry.distractorCount || ""}" data-lvl="${lvl}" data-key="distractorCount" class="level-bank-input" placeholder="Distractors">
                    <div style="display:flex; align-items:center; gap:6px; min-width:0;">
                        <input type="checkbox" id="level-bank-tap-${lvl}" data-lvl="${lvl}" data-key="freeSelectFromText" class="level-bank-free-select" ${freeSelect ? "checked" : ""} aria-label="Tap text for level ${lvl}">
                        <label for="level-bank-tap-${lvl}" style="font-size:0.8rem; white-space:nowrap; cursor:pointer; margin:0;">Tap text</label>
                    </div>
                </div>
            `);
        }
        wrap.innerHTML = `
            <div class="level-bank-header" style="display:grid; gap:6px; font-size:0.85rem; opacity:0.8; margin-bottom:6px;">
                <div>Level</div>
                <div>Max words</div>
                <div>Ellipses at</div>
                <div>Language tier</div>
                <div>Quote target (correct)</div>
                <div>Weak quotes (incorrect)</div>
                <div title="Student selects quote by tapping/dragging in the passage">Free select</div>
            </div>
            ${rows.join("")}
        `;
        Array.from(wrap.querySelectorAll(".level-bank-input")).forEach(el => {
            el.addEventListener("change", () => admin.updateLevelBank(el));
            el.addEventListener("input", () => admin.updateLevelBank(el));
        });
        Array.from(wrap.querySelectorAll(".level-bank-free-select")).forEach(el => {
            el.addEventListener("change", function() { admin.updateLevelBank(this); });
            el.addEventListener("click", function(e) { e.stopPropagation(); });
        });
    },
    updateLevelBank: function(el) {
        const lvl = parseInt(el.dataset.lvl, 10);
        const key = el.dataset.key;
        if(!lvl || !key) return;
        if(!appData.settings.levelBank) appData.settings.levelBank = JSON.parse(JSON.stringify(defaultData.settings.levelBank));
        if(!appData.settings.levelBank[lvl]) appData.settings.levelBank[lvl] = {};
        if(key === "freeSelectFromText") {
            appData.settings.levelBank[lvl].freeSelectFromText = el.checked;
        } else if(key === "languageTier") {
            appData.settings.levelBank[lvl].languageTier = el.value;
        } else {
            const min = (key === "quoteTarget" || key === "distractorCount") ? 1 : 3;
            const val = Math.max(min, parseInt(el.value, 10) || 0);
            appData.settings.levelBank[lvl][key] = val;
        }
        app.save();
        ui.renderSelection();
    },

    // EXPORTS
    exportWorksheet: function() {
        let content = `<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
        <head><meta charset='utf-8'><title>Worksheet</title>
        <style>body{font-family:'Aptos','Calibri',sans-serif;} .box{border:1px solid #999; padding:10px; margin-bottom:15px; break-inside:avoid; page-break-inside:avoid;} .dotted{border-bottom:1px dotted #000; display:inline-block; width:95%; margin-top:5px;} .rubric-line{display:block; margin-top:10px;} .rubric-slot{display:inline-block; vertical-align:bottom; margin-right:16px; margin-bottom:8px; font-size:0.9rem;} .rubric-label{font-style:italic; font-weight:600; font-size:0.85rem; opacity:0.8; text-transform:none;} .rubric-blank{border-bottom:1px dotted #000; min-width:180px; height:18px;} .glossary-table{width:100%; border-collapse:collapse; margin:6px 0 8px 0; break-inside:avoid; page-break-inside:avoid;} .glossary-table td{padding:4px 6px; border-bottom:1px dotted #ccc;}</style>
        </head><body>
        <h1>${appData.meta.title}</h1>
        <p><strong>Question:</strong> ${app.escapeHtml(appData.question || "")}</p>
        <p>${appData.sourceText.replace(/\n/g, '<br>')}</p>`;
        
        const shuffle = (arr) => {
            const a = arr.slice();
            for(let i = a.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        };
        const extractScanWords = (text, maxCount = 6) => {
            const stop = new Set(["the","and","that","with","this","from","were","their","have","has","had","into","over","under","after","before","about","there","they","them","then","than","when","where","which","while","your","you","his","her","its","our","ours","was","are","is","be","been","being","but","for","not","too","very","also","only","each","every","some","such","these","those","who","whom","what","why","how","can","could","would","should","will","shall","may","might","must","as","of","in","on","at","to","by","a","an"]);
            const words = String(text || "")
                .replace(/[^A-Za-z'\- ]/g, " ")
                .split(/\s+/)
                .map(w => w.replace(/^'+|'+$/g, ""))
                .filter(w => w.length >= 5);
            const seen = new Set();
            const picked = [];
            words.forEach(w => {
                const key = w.toLowerCase();
                if(stop.has(key) || seen.has(key)) return;
                seen.add(key);
                picked.push({ word: w, meaning: "" });
            });
            return picked.slice(0, maxCount);
        };
        const includedForScan = appData.items.filter(i => i.includeInWorksheet);
        const scanRows = includedForScan.map(i => {
            const txt = i.originalFull || i.original || "";
            const words = extractScanWords(txt, 3).map(w => w.word);
            return words.filter(Boolean);
        }).filter(r => r.length);
        if(scanRows.length) {
            content += `<div class="box"><p><strong>Scan for words</strong></p>`;
            content += `<table class="glossary-table">`;
            scanRows.forEach(row => {
                const words = row.map(w => `<strong>${app.escapeHtml(w)}</strong>`).join(' / ');
                content += `<tr><td style="width:60%;">${words}</td><td><span class="dotted" style="width:100%;"></span></td></tr>`;
            });
            content += `</table></div><hr>`;
        } else {
            content += `<hr>`;
        }
        const uiLevel = parseInt((document.getElementById("level-selector") || {}).value, 10) || 1;
        const level = app.getEffectiveLevel ? app.getEffectiveLevel() : uiLevel;
        let structure = appData.sentenceConfig[level] || appData.sentenceConfig[3] || ["starter", "quote", "point"];
        if(appData.settings && appData.settings.practiceMode && appData.settings.practiceFixedTemplate) {
            structure = app.getPracticeTemplate(level);
        }
        if(appData.settings && appData.settings.practiceMode && appData.settings.practiceForceAuto) {
            const linkSlot = `link_l${level}`;
            const mapSlot = (slot) => {
                if(!slot || !slot.startsWith("manual")) return slot;
                const tail = slot.split("_")[1] || "";
                if(tail === "marker") return "marker";
                if(tail === "starter") return "starter";
                if(tail === "method") return "method";
                if(tail === "link") return linkSlot;
                return "point";
            };
            structure = structure.map(mapSlot);
        }

        const worksheetQuote = (item) => {
            const raw = item.originalFull || item.original || "";
            const ruleSet = appData.settings && appData.settings.levelBank ? appData.settings.levelBank : {};
            const rule = ruleSet[level] || {};
            const maxWords = parseInt(rule.maxWords, 10) || 0;
            const words = app.wordList(raw);
            if(maxWords > 0 && words.length > maxWords) return app.truncateWithEllipses(words, maxWords);
            return raw;
        };

        // Part A: Match
        const included = appData.items.filter(i=>i.includeInWorksheet);
        const matchSelect = document.getElementById("worksheet-match-mode");
        const matchMode = (appData.settings && appData.settings.worksheetMatchMode)
            || (matchSelect ? matchSelect.value : "jumbled");
        const meanings = included.map(i=>i.translation);
        if(matchMode === "list") {
            const shuffled = shuffle(meanings);
            content += `<h3>Part A: Match Meanings</h3><p><em>Choices: ${shuffled.join(' / ')}</em></p>`;
            included.forEach((item, idx) => {
                content += `<p>${idx+1}. "${worksheetQuote(item)}" = __________________</p>`;
            });
        } else {
            const rightSide = matchMode === "aligned" ? meanings : shuffle(meanings);
            content += `<h3>Part A: Match Meanings</h3>`;
            content += `<p><em>Draw a line through the middle column to match each quote with its interpretation.</em></p>`;
            content += `<table style="width:100%; border-collapse:collapse; margin-bottom:15px;">`;
            content += `<tr><th style="text-align:left; border-bottom:1px solid #999; padding:6px;">Quote</th><th style="text-align:center; border-bottom:1px solid #999; padding:6px;">Match</th><th style="text-align:left; border-bottom:1px solid #999; padding:6px;">Interpretation</th></tr>`;
            included.forEach((item, idx) => {
                const right = rightSide[idx] || "";
                content += `<tr>
                    <td style="border-bottom:1px dotted #ccc; padding:6px;">${idx+1}. "${worksheetQuote(item)}"</td>
                    <td style="border-bottom:1px dotted #ccc; padding:6px; text-align:center;">&nbsp;</td>
                    <td style="border-bottom:1px dotted #ccc; padding:6px;">${right}</td>
                </tr>`;
            });
            content += `</table>`;
        }

        // Part B: Sentence Construction
        content += `<br><h3>Part B: Sentence Construction</h3>`;
        const isValidSlot = (slot) => {
            if(!slot) return false;
            if(slot === "choice") return false;
            if(slot === "starter" || slot === "marker" || slot === "method" || slot === "quote" || slot === "point" || slot === "analysis") return true;
            if(slot.startsWith("manual_")) return true;
            if(slot.startsWith("link_")) return true;
            return false;
        };
        const labelForSlot = (slot) => {
            if(!isValidSlot(slot)) return null;
            const base = slot.startsWith("manual") ? (slot.split('_')[1] || "") : slot;
            if(base.includes("link")) return "Link";
            if(base === "point" || base === "analysis") return "Point";
            if(base === "quote") return "Quote";
            const cleaned = base.replace(/^./, c => c.toUpperCase()).replace(/_/g, " ");
            return cleaned;
        };
        appData.items.forEach((item, idx) => {
            if(!item.includeInWorksheet) return;
            content += `<div class="box"><p><strong>${idx+1}. Quote: "${worksheetQuote(item)}"</strong></p>`;
            
            let rubricSlots = structure.filter(isValidSlot);
            if(!rubricSlots.length) rubricSlots = ["starter","quote","point"];
            const labels = rubricSlots.map(labelForSlot).filter(Boolean);
            const header = labels.length
                ? labels.map(l => `<td style="padding:6px 8px; font-style:italic; font-size:0.85rem;">${l}</td>`).join("")
                : `<td style="padding:6px 8px; font-style:italic; font-size:0.85rem;">Starter</td><td style="padding:6px 8px; font-style:italic; font-size:0.85rem;">Quote</td><td style="padding:6px 8px; font-style:italic; font-size:0.85rem;">Point</td>`;
            const colCount = labels.length || 3;
            content += `
                <table style="width:100%; border:1px solid #999; border-collapse:collapse; margin-top:8px;">
                    <tr>${header}</tr>
                    <tr><td colspan="${colCount}" style="height:28px; border-top:1px solid #999;"></td></tr>
                    <tr><td colspan="${colCount}" style="height:28px; border-top:1px solid #999;"></td></tr>
                </table>
            </div>`;
        });
        
        content += `</body></html>`;
        const b = new Blob(['\ufeff'+content], {type:'application/msword'});
        const a = document.createElement("a"); a.href=URL.createObjectURL(b); a.download="Worksheet.doc"; a.click();
    },

    exportStandalone: () => {
        if(!appData.items || appData.items.length === 0) {
            const selItems = appData.selection && Array.isArray(appData.selection.items) ? appData.selection.items : [];
            if(selItems.length) {
                appData.items = selItems.map((s, idx) => {
                    const reasons = Array.isArray(s.reasons) ? s.reasons.filter(Boolean) : [];
                    const distractorReasons = Array.isArray(s.distractors)
                        ? s.distractors.map(d => d && d.reason).filter(Boolean)
                        : [];
                    return {
                        id: s.id || `q${idx + 1}`,
                        original: s.quote || "Quote",
                        translation: reasons[0] || "Meaning not provided.",
                        translationDistractors: distractorReasons.slice(0, 3),
                        type: "language",
                        effect: reasons[1] || reasons[0] || "",
                        effectDistractors: distractorReasons,
                        levels: [1,2,3],
                        includeInWorksheet: true
                    };
                });
            } else {
                return alert("No lesson data to export yet.");
            }
        }
        // 1. Prepare data with lock
        const exportData = JSON.parse(JSON.stringify(appData));
        exportData.isStandalone = true; 
        if(exportData.settings && exportData.settings.modulesActive && !exportData.settings.modulesActive.selection) {
            if(exportData.selection) {
                exportData.selection.enabled = false;
                exportData.selection.items = [];
            }
        }
        const exportSource = app.getSourceText();
        if(exportSource && exportSource.trim()) {
            exportData.sourceText = exportSource;
        } else if(!exportData.sourceText || !String(exportData.sourceText).trim()) {
            const aiInput = document.getElementById("ai-input");
            const sourceInline = document.getElementById("source-inline");
            const sourceModal = document.getElementById("source-content");
            const candidates = [
                aiInput && aiInput.value,
                sourceInline && sourceInline.innerText,
                sourceModal && sourceModal.innerText
            ].map(v => (v || "").trim()).filter(Boolean);
            if(candidates.length) exportData.sourceText = app.cleanSourceText(candidates[0]);
        }
        if(!exportData.sourceText || !String(exportData.sourceText).trim()) {
            const selText = exportData.selection && exportData.selection.text && exportData.selection.text.source;
            if(selText && String(selText).trim()) {
                exportData.sourceText = app.cleanSourceText(selText);
            }
        }
        if(exportData.selection) {
            exportData.selection.text = exportData.selection.text || {};
            exportData.selection.text.source = exportData.sourceText || "";
        }
        if(!exportData.meta) exportData.meta = {};
        if(!exportData.meta.id) exportData.meta.id = "lesson_" + Date.now();

        const exportDevices = app.getExportDevices();
        const allowedTypes = Object.keys(exportDevices).filter(k => exportDevices[k]);
        if(Array.isArray(exportData.items)) {
            exportData.items = exportData.items.filter(i => !i || !i.type || allowedTypes.includes(i.type));
            if(exportData.items.length === 0) {
                return alert("Export blocked: no lesson items match the selected device types.");
            }
        }
        if(exportData.selection && Array.isArray(exportData.selection.items)) {
            exportData.selection.items = exportData.selection.items.filter(i => {
                if(!i || !i.device) return true;
                return allowedTypes.includes(i.device);
            });
        }
        if(!exportDevices.structure) {
            if(exportData.globalStructure) {
                exportData.globalStructure.enabled = false;
                exportData.globalStructure.items = [];
            }
            if(exportData.selection && Array.isArray(exportData.selection.structurePrompts)) {
                exportData.selection.structurePrompts = [];
            }
        }

        // 2. Clone document to avoid mutating live DOM
        const clone = document.documentElement.cloneNode(true);
        const cloneDoc = document.implementation.createHTMLDocument();
        cloneDoc.replaceChild(clone, cloneDoc.documentElement);

        // 3. Remove teacher-only UI in the clone (keep reader controls so students can adjust the reader)
        const adminBtn = cloneDoc.querySelector('#btn-admin');
        if (adminBtn) adminBtn.remove();
        const adminModal = cloneDoc.querySelector('#modal-admin');
        if (adminModal) adminModal.remove();

        // 4. Inject standalone data at start of body
        const dataScript = cloneDoc.createElement('script');
        dataScript.textContent = `window.STANDALONE_LESSON = ${JSON.stringify(exportData)};`;
        cloneDoc.body.prepend(dataScript);

        // 5. Serialize with doctype
        const h = '<!DOCTYPE html>\n' + cloneDoc.documentElement.outerHTML;
        const b = new Blob([h], {type:'text/html'});
        const a = document.createElement('a'); a.href=URL.createObjectURL(b); a.download='StudentApp.html'; a.click();
    },
    saveConfig: () => {
        const b = new Blob([JSON.stringify(appData)], {type:'application/json'});
        const a = document.createElement('a'); a.href=URL.createObjectURL(b); a.download='config.json'; a.click();
    },
    exportTemplates: () => {
        const templates = admin.getTemplates();
        const payload = { templates };
        const b = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
        const a = document.createElement('a'); a.href=URL.createObjectURL(b); a.download='templates.json'; a.click();
    },
    importTemplates: (input) => {
        const f = input.files[0]; if(!f) return;
        const r = new FileReader();
        r.onload = e => {
            try {
                const parsed = JSON.parse(e.target.result);
                const incoming = Array.isArray(parsed) ? parsed : (parsed && parsed.templates) ? parsed.templates : [];
                if(!Array.isArray(incoming)) throw new Error("Invalid templates format.");
                const current = admin.getTemplates();
                const merged = [...current];
                incoming.forEach(t => {
                    if(!t || !t.name) return;
                    if(!merged.find(x => x && x.name === t.name)) merged.push(t);
                });
                admin.saveTemplates(merged);
                admin.refreshTemplateList();
                alert(`Imported ${incoming.length} template(s).`);
            } catch(err) {
                alert("Template import failed: " + (err && err.message ? err.message : "Invalid file"));
            }
        };
        r.readAsText(f);
        input.value = "";
    },
    loadFile: (input) => {
        const f = input.files[0]; if(!f) return;
        const name = (f.name || "").toLowerCase();
        const isPdf = f.type === "application/pdf" || name.endsWith(".pdf");
        const isDocx = f.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document" || name.endsWith(".docx");
        const isDoc = name.endsWith(".doc");
        if(isDoc) {
            alert("Word .doc files are not supported. Please save as .docx or .txt.");
            input.value = "";
            return;
        }
        if(isDocx) {
            const reader = new FileReader();
            reader.onload = async () => {
                try {
                    if(!window.mammoth) throw new Error("Word import library not loaded.");
                    const result = await window.mammoth.extractRawText({ arrayBuffer: reader.result });
                    const cleaned = app.cleanSourceText(result && result.value ? result.value : "");
                    if(!cleaned) throw new Error("No readable text found.");
                    if(!appData) appData = app.repair(defaultData);
                    appData.sourceText = cleaned;
                    app.save();
                    ui.init();
                    const aiInput = document.getElementById("ai-input");
                    if(aiInput) aiInput.value = cleaned;
                    localStorage.setItem("tsa_ai_step2", "true");
                    const step2 = document.getElementById("ai-step2");
                    if(step2) step2.classList.remove("hidden");
                    if(localStorage.getItem("tsa_unlocked") === "true") {
                        const adminModal = document.getElementById("modal-admin");
                        if(adminModal && !adminModal.classList.contains("open")) {
                            ui.openModal("modal-admin");
                        }
                    }
                    alert("Word document loaded. Use the AI panel to generate lesson data.");
                } catch(err) {
                    alert("Word import failed. Please save as .txt and try again.");
                } finally {
                    input.value = "";
                }
            };
            reader.onerror = () => {
                alert("Word import failed. Please try again.");
                input.value = "";
            };
            reader.readAsArrayBuffer(f);
            return;
        }
        if(isPdf) {
            const reader = new FileReader();
            reader.onload = async () => {
                app.isImportingPdf = true;
                try {
                    if(!window.pdfjsLib) throw new Error("PDF library not loaded.");
                    const loadPdf = async (disableWorker) => {
                        return await window.pdfjsLib.getDocument({ data: reader.result, disableWorker: !!disableWorker }).promise;
                    };
                    let pdf;
                    try {
                        pdf = await loadPdf(false);
                    } catch(e) {
                        pdf = await loadPdf(true);
                    }
                    let text = "";
                    for(let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const content = await page.getTextContent();
                        const pageText = content.items.map(it => it.str).join(" ");
                        text += pageText + "\n\n";
                    }
                    const cleaned = app.cleanSourceText(text);
                    if(!cleaned) throw new Error("No readable text found.");
                    if(!appData) appData = app.repair(defaultData);
                    appData.sourceText = cleaned;
                    app.save();
                    ui.init();
                    const aiInput = document.getElementById("ai-input");
                    if(aiInput) aiInput.value = cleaned;
                    localStorage.setItem("tsa_ai_step2", "true");
                    const step2 = document.getElementById("ai-step2");
                    if(step2) step2.classList.remove("hidden");
                    if(localStorage.getItem("tsa_unlocked") === "true") {
                        const adminModal = document.getElementById("modal-admin");
                        if(adminModal && !adminModal.classList.contains("open")) {
                            ui.openModal("modal-admin");
                        }
                    }
                    alert("PDF loaded. Use the AI panel to generate lesson data.");
                } catch(err) {
                    alert("PDF import failed. Please save as .txt and try again.");
                } finally {
                    app.isImportingPdf = false;
                    input.value = "";
                }
            };
            reader.onerror = () => {
                alert("PDF import failed. Please try again.");
                app.isImportingPdf = false;
                input.value = "";
            };
            reader.readAsArrayBuffer(f);
            return;
        }
        const r = new FileReader();
        r.onload = e => {
            const raw = e.target.result || "";
            const text = String(raw || "");
            try {
                const parsed = JSON.parse(text);
                appData = app.repair(parsed);
                userState = { score: 0, level: 1, view: "", essay: "", completed: [], completedLevels: [], filter: "all", showDone: false, selectionCompleted: false, selectionStage: 1, selectionKey: "", selectionProgress: {}, selectionEliminated: [], labCompleted: false };
                app.save();
                ui.init();
                admin.renderAll();
                input.value = "";
            } catch(err) {
                const cleaned = app.cleanSourceText(text);
                if(!cleaned) {
                    alert("This file is not valid JSON or readable text.");
                    return;
                }
                if(!appData) appData = app.repair(defaultData);
                appData.sourceText = cleaned;
                app.save();
                ui.init();
                const aiInput = document.getElementById("ai-input");
                if(aiInput) aiInput.value = cleaned;
                localStorage.setItem("tsa_ai_step2", "true");
                const step2 = document.getElementById("ai-step2");
                if(step2) step2.classList.remove("hidden");
                if(localStorage.getItem("tsa_unlocked") === "true") {
                    const adminModal = document.getElementById("modal-admin");
                    if(adminModal && !adminModal.classList.contains("open")) {
                        ui.openModal("modal-admin");
                    }
                }
                alert("Source text loaded. Use the AI panel to generate lesson data.");
                input.value = "";
            }
        };
        r.readAsText(f);
    }
};

window.onload = app.init;
</script>
</body>
</html>
